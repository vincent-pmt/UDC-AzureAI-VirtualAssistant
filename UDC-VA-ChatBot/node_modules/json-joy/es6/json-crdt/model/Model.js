"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Model = exports.UNDEFINED = void 0;
const ArrayRga_1 = require("../types/rga-array/ArrayRga");
const ArrInsOp_1 = require("../../json-crdt-patch/operations/ArrInsOp");
const ArrOp_1 = require("../../json-crdt-patch/operations/ArrOp");
const BinaryRga_1 = require("../types/rga-binary/BinaryRga");
const BinInsOp_1 = require("../../json-crdt-patch/operations/BinInsOp");
const BinOp_1 = require("../../json-crdt-patch/operations/BinOp");
const Const_1 = require("../types/const/Const");
const ConstOp_1 = require("../../json-crdt-patch/operations/ConstOp");
const DelOp_1 = require("../../json-crdt-patch/operations/DelOp");
const clock_1 = require("../../json-crdt-patch/clock");
const NodeIndex_1 = require("./NodeIndex");
const ObjectLww_1 = require("../types/lww-object/ObjectLww");
const ObjOp_1 = require("../../json-crdt-patch/operations/ObjOp");
const ObjSetOp_1 = require("../../json-crdt-patch/operations/ObjSetOp");
const constants_1 = require("../../json-crdt-patch/constants");
const util_1 = require("./util");
const RootLww_1 = require("../types/lww-root/RootLww");
const StringRga_1 = require("../types/rga-string/StringRga");
const StrInsOp_1 = require("../../json-crdt-patch/operations/StrInsOp");
const StrOp_1 = require("../../json-crdt-patch/operations/StrOp");
const ValOp_1 = require("../../json-crdt-patch/operations/ValOp");
const ValSetOp_1 = require("../../json-crdt-patch/operations/ValSetOp");
const ValueLww_1 = require("../types/lww-value/ValueLww");
const printTree_1 = require("../../util/print/printTree");
const util_2 = require("../../json-pack/msgpack/util");
const Encoder_1 = require("../codec/structural/json/Encoder");
const Decoder_1 = require("../codec/structural/json/Decoder");
const encoder = new Encoder_1.Encoder();
const decoder = new Decoder_1.Decoder();
exports.UNDEFINED = new Const_1.Const(constants_1.ORIGIN, undefined);
class Model {
    static withLogicalClock(clockOrSessionId) {
        const clock = typeof clockOrSessionId === 'number'
            ? new clock_1.VectorClock(clockOrSessionId, 1)
            : clockOrSessionId || new clock_1.VectorClock((0, util_1.randomSessionId)(), 1);
        return new Model(clock);
    }
    static withServerClock(time = 0) {
        const clock = new clock_1.ServerVectorClock(1, time);
        return new Model(clock);
    }
    static fromBinary(data) {
        return decoder.decode((0, util_2.decode)(data));
    }
    constructor(clock) {
        this.root = new RootLww_1.RootLww(this, constants_1.ORIGIN);
        this.index = new NodeIndex_1.NodeIndex();
        this.clock = clock;
        if (!clock.time)
            clock.time = 1;
    }
    applyBatch(batch) {
        const patches = batch.patches;
        const { length } = patches;
        for (let i = 0; i < length; i++)
            this.applyPatch(patches[i]);
    }
    applyPatch(patch) {
        const ops = patch.ops;
        const { length } = ops;
        for (let i = 0; i < length; i++)
            this.applyOperation(ops[i]);
    }
    applyOperation(op) {
        this.clock.observe(op.id, op.span());
        const index = this.index;
        if (op instanceof StrInsOp_1.StrInsOp) {
            const node = index.get(op.obj);
            if (node instanceof StringRga_1.StringRga)
                node.ins(op.ref, op.id, op.data);
        }
        else if (op instanceof ObjOp_1.ObjOp) {
            if (!index.get(op.id))
                index.set(new ObjectLww_1.ObjectLww(this, op.id));
        }
        else if (op instanceof ArrOp_1.ArrOp) {
            if (!index.get(op.id))
                index.set(new ArrayRga_1.ArrayRga(this, op.id));
        }
        else if (op instanceof StrOp_1.StrOp) {
            if (!index.get(op.id))
                index.set(new StringRga_1.StringRga(op.id));
        }
        else if (op instanceof ValOp_1.ValOp) {
            if (!index.get(op.id)) {
                const val = index.get(op.val);
                if (val)
                    index.set(new ValueLww_1.ValueLww(this, op.id, op.val));
            }
        }
        else if (op instanceof ConstOp_1.ConstOp) {
            if (!index.get(op.id))
                index.set(new Const_1.Const(op.id, op.val));
        }
        else if (op instanceof ObjSetOp_1.ObjSetOp) {
            const node = index.get(op.obj);
            const tuples = op.data;
            const length = tuples.length;
            if (node instanceof ObjectLww_1.ObjectLww) {
                for (let i = 0; i < length; i++) {
                    const tuple = tuples[i];
                    const valueNode = index.get(tuple[1]);
                    if (!valueNode)
                        continue;
                    if (node.id.time >= tuple[1].time)
                        continue;
                    const old = node.put(tuple[0] + '', valueNode.id);
                    if (old)
                        this.deleteNodeTree(old);
                }
            }
        }
        else if (op instanceof ValSetOp_1.ValSetOp) {
            const obj = op.obj;
            const node = obj.sid === 0 && obj.time === 0 ? this.root : index.get(obj);
            if (node instanceof ValueLww_1.ValueLww) {
                const newValue = index.get(op.val);
                if (newValue) {
                    const old = node.set(op.val);
                    if (old)
                        this.deleteNodeTree(old);
                }
            }
        }
        else if (op instanceof ArrInsOp_1.ArrInsOp) {
            const node = index.get(op.obj);
            if (node instanceof ArrayRga_1.ArrayRga) {
                const nodes = [];
                const data = op.data;
                const length = data.length;
                for (let i = 0; i < length; i++) {
                    const stamp = data[i];
                    const valueNode = index.get(stamp);
                    if (!valueNode)
                        continue;
                    if (node.id.time >= stamp.time)
                        continue;
                    nodes.push(stamp);
                }
                if (nodes.length)
                    node.ins(op.ref, op.id, nodes);
            }
        }
        else if (op instanceof DelOp_1.DelOp) {
            const node = index.get(op.obj);
            if (node instanceof ArrayRga_1.ArrayRga) {
                const length = op.what.length;
                for (let i = 0; i < length; i++) {
                    const span = op.what[i];
                    for (let j = 0; j < span.span; j++) {
                        const id = node.getById(new clock_1.Timestamp(span.sid, span.time + j));
                        if (id)
                            this.deleteNodeTree(id);
                    }
                }
                node.delete(op.what);
            }
            else if (node instanceof StringRga_1.StringRga)
                node.delete(op.what);
            else if (node instanceof BinaryRga_1.BinaryRga)
                node.delete(op.what);
        }
        else if (op instanceof BinOp_1.BinOp) {
            if (!index.get(op.id))
                index.set(new BinaryRga_1.BinaryRga(op.id));
        }
        else if (op instanceof BinInsOp_1.BinInsOp) {
            const node = index.get(op.obj);
            if (node instanceof BinaryRga_1.BinaryRga)
                node.ins(op.ref, op.id, op.data);
        }
    }
    deleteNodeTree(value) {
        const isSystemNode = value.sid === 0;
        if (isSystemNode)
            return;
        const node = this.index.get(value);
        if (!node)
            return;
        node.children((child) => this.deleteNodeTree(child.id));
        this.index.delete(value);
    }
    fork(sessionId = (0, util_1.randomSessionId)()) {
        const copy = Model.fromBinary(this.toBinary());
        if (copy.clock.sid !== sessionId && copy.clock instanceof clock_1.VectorClock)
            copy.clock = copy.clock.fork(sessionId);
        return copy;
    }
    clone() {
        return this.fork(this.clock.sid);
    }
    view() {
        return this.root.view();
    }
    toString(tab = '') {
        const nl = () => '';
        return (this.constructor.name +
            (0, printTree_1.printTree)(tab, [
                (tab) => this.root.toString(tab),
                nl,
                (tab) => this.index.toString(tab),
                nl,
                (tab) => this.clock.toString(tab),
            ]));
    }
    toBinary() {
        return (0, util_2.encode)(encoder.encode(this));
    }
}
exports.Model = Model;
