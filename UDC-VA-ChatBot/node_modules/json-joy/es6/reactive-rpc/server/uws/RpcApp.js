"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcApp = void 0;
const tslib_1 = require("tslib");
const util_1 = require("./util");
const router_1 = require("../../../util/router");
const RpcMessageBatchProcessor_1 = require("../../common/rpc/RpcMessageBatchProcessor");
const error_1 = require("../../common/rpc/caller/error");
const context_1 = require("../context");
const RpcMessageCodecs_1 = require("../../common/codec/RpcMessageCodecs");
const Value_1 = require("../../common/messages/Value");
const RpcCodecs_1 = require("../../common/codec/RpcCodecs");
const common_1 = require("../../common");
const HDR_BAD_REQUEST = Buffer.from('400 Bad Request', 'utf8');
const HDR_NOT_FOUND = Buffer.from('404 Not Found', 'utf8');
const HDR_INTERNAL_SERVER_ERROR = Buffer.from('500 Internal Server Error', 'utf8');
const ERR_NOT_FOUND = error_1.RpcError.fromCode(error_1.RpcErrorCodes.NOT_FOUND, 'Not Found');
const ERR_INTERNAL = error_1.RpcError.internal();
class RpcApp {
    constructor(options) {
        this.options = options;
        this.router = new router_1.Router();
        this.app = options.uws;
        this.maxRequestBodySize = options.maxRequestBodySize;
        this.codecs = new RpcCodecs_1.RpcCodecs(options.codecs, new RpcMessageCodecs_1.RpcMessageCodecs());
        this.batchProcessor = new RpcMessageBatchProcessor_1.RpcMessageBatchProcessor({ caller: options.caller });
    }
    enableCors() {
        (0, util_1.enableCors)(this.options.uws);
    }
    routeRaw(method, path, handler) {
        method = method.toLowerCase();
        this.router.add(method + path, handler);
    }
    route(method, path, handler) {
        this.routeRaw(method, path, (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = yield handler(ctx);
            const res = ctx.res;
            if (res.aborted)
                return;
            const codec = ctx.resCodec;
            const encoder = codec.encoder;
            const writer = encoder.writer;
            writer.reset();
            if (res instanceof Value_1.Value) {
                if (res.type)
                    res.type.encoder(codec.format)(res.data, encoder);
                else
                    encoder.writeAny(res.data);
            }
            else {
                encoder.writeAny(result);
            }
            if (res.aborted)
                return;
            ctx.sendResponse(writer.flush());
        }));
    }
    enableHttpPing(path = '/ping') {
        this.route('GET', path, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return 'pong';
        }));
        return this;
    }
    enableHttpRpc(path = '/rpc') {
        this.routeRaw('POST', path, (ctx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const res = ctx.res;
                const bodyUint8 = yield ctx.requestBody(this.maxRequestBodySize);
                if (res.aborted)
                    return;
                const messageCodec = ctx.msgCodec;
                const incomingMessages = messageCodec.decodeBatch(ctx.reqCodec, bodyUint8);
                const outgoingMessages = yield this.batchProcessor.onBatch(incomingMessages, ctx);
                if (res.aborted)
                    return;
                const resCodec = ctx.resCodec;
                messageCodec.encodeBatch(resCodec, outgoingMessages);
                const buf = resCodec.encoder.writer.flush();
                if (res.aborted)
                    return;
                res.end(buf);
            }
            catch (err) {
                if (typeof err === 'object' && err)
                    if (err.message === 'Invalid JSON')
                        throw error_1.RpcError.invalidRequest();
                throw error_1.RpcError.from(err);
            }
        }));
        return this;
    }
    enableWsRpc(path = '/rpc') {
        const maxBackpressure = 4 * 1024 * 1024;
        this.app.ws(path, {
            idleTimeout: 0,
            maxPayloadLength: 4 * 1024 * 1024,
            upgrade: (res, req, context) => {
                const secWebSocketKey = req.getHeader('sec-websocket-key');
                const secWebSocketProtocol = req.getHeader('sec-websocket-protocol');
                const secWebSocketExtensions = req.getHeader('sec-websocket-extensions');
                const ctx = context_1.ConnectionContext.fromReqRes(req, res, null, this);
                res.upgrade({ ctx }, secWebSocketKey, secWebSocketProtocol, secWebSocketExtensions, context);
            },
            open: (ws_) => {
                const ws = ws_;
                const ctx = ws.ctx;
                const resCodec = ctx.resCodec;
                const msgCodec = ctx.msgCodec;
                const encoder = resCodec.encoder;
                const isBinary = resCodec.format !== 2 || msgCodec.format === 0;
                ws.rpc = new common_1.RpcMessageStreamProcessor({
                    caller: this.options.caller,
                    send: (messages) => {
                        if (ws.getBufferedAmount() > maxBackpressure)
                            return;
                        const writer = encoder.writer;
                        writer.reset();
                        msgCodec.encodeBatch(resCodec, messages);
                        const encoded = writer.flush();
                        ws.send(encoded, isBinary, false);
                    },
                    bufferSize: 1,
                    bufferTime: 0,
                });
            },
            message: (ws_, buf, isBinary) => {
                const ws = ws_;
                const ctx = ws.ctx;
                const reqCodec = ctx.reqCodec;
                const msgCodec = ctx.msgCodec;
                const uint8 = new Uint8Array(buf);
                const rpc = ws.rpc;
                try {
                    const messages = msgCodec.decodeBatch(reqCodec, uint8);
                    rpc.onMessages(messages, ctx);
                }
                catch (error) {
                    rpc.sendNotification('.err', error_1.RpcError.value(error_1.RpcError.invalidRequest()));
                }
            },
            close: (ws_, code, message) => {
                const ws = ws_;
                ws.rpc.stop();
            },
        });
        return this;
    }
    startRouting() {
        const matcher = this.router.compile();
        const codecs = this.codecs;
        let responseCodec = codecs.value.json;
        this.app.any('/*', (res, req) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            res.onAborted(() => {
                res.aborted = true;
            });
            const method = req.getMethod();
            const url = req.getUrl();
            try {
                const match = matcher(method + url);
                if (!match) {
                    res.cork(() => {
                        res.writeStatus(HDR_NOT_FOUND);
                        res.end(error_1.RpcErrorType.encode(responseCodec, ERR_NOT_FOUND));
                    });
                    return;
                }
                const handler = match.data;
                const params = match.params;
                const ctx = context_1.ConnectionContext.fromReqRes(req, res, params, this);
                responseCodec = ctx.resCodec;
                yield handler(ctx);
            }
            catch (err) {
                if (err instanceof error_1.RpcError) {
                    const error = err;
                    res.cork(() => {
                        res.writeStatus(HDR_BAD_REQUEST);
                        res.end(error_1.RpcErrorType.encode(responseCodec, error));
                    });
                    return;
                }
                if (err instanceof Value_1.Value && err.data instanceof error_1.RpcError) {
                    const error = err.data;
                    res.cork(() => {
                        res.writeStatus(HDR_BAD_REQUEST);
                        res.end(error_1.RpcErrorType.encode(responseCodec, error));
                    });
                    return;
                }
                console.error(err);
                res.cork(() => {
                    res.writeStatus(HDR_INTERNAL_SERVER_ERROR);
                    res.end(error_1.RpcErrorType.encode(responseCodec, ERR_INTERNAL));
                });
            }
        }));
    }
}
exports.RpcApp = RpcApp;
