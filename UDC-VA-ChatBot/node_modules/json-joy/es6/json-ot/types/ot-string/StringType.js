"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = exports.compose = exports.apply = exports.normalize = exports.append = exports.validate = void 0;
const validate = (op) => {
    if (!(op instanceof Array))
        return 1;
    if (op.length === 0)
        return 1;
    let last;
    for (let i = 0; i < op.length; i++) {
        const component = op[i];
        switch (typeof component) {
            case 'number': {
                if (!component)
                    return 2;
                if (component !== Math.round(component))
                    return 2;
                if (component > 0) {
                    const lastComponentIsRetain = typeof last === 'number' && last > 0;
                    if (lastComponentIsRetain)
                        return 3;
                }
                else {
                    const lastComponentIsDelete = typeof last === 'number' && last < 0;
                    if (lastComponentIsDelete)
                        return 3;
                }
                break;
            }
            case 'string': {
                if (!component.length)
                    return 2;
                const lastComponentIsInsert = typeof last === 'string';
                if (lastComponentIsInsert)
                    return 3;
                break;
            }
            case 'object': {
                if (!(component instanceof Array))
                    return 2;
                if (component.length !== 1)
                    return 2;
                const lastComponentIsRetainedDelete = last instanceof Array;
                if (lastComponentIsRetainedDelete)
                    return 3;
                break;
            }
            default:
                return 2;
        }
        last = component;
    }
    const isLastRetain = typeof last === 'number' && last > 0;
    if (isLastRetain)
        return 4;
    return 0;
};
exports.validate = validate;
const append = (op, component) => {
    if (!component)
        return;
    if (!op.length) {
        op.push(component);
        return;
    }
    const lastIndex = op.length - 1;
    const last = op[lastIndex];
    switch (typeof component) {
        case 'number': {
            if (typeof last === 'number') {
                if (component > 0 && last > 0)
                    op[lastIndex] = last + component;
                else if (component < 0 && last < 0)
                    op[lastIndex] = last + component;
                else
                    op.push(component);
            }
            else
                op.push(component);
            break;
        }
        case 'string': {
            if (typeof last === 'string')
                op[lastIndex] = last + component;
            else
                op.push(component);
            break;
        }
        case 'object': {
            if (last instanceof Array)
                last[0] = last + component[0];
            else
                op.push(component);
            break;
        }
    }
};
exports.append = append;
const componentLength = (component) => {
    switch (typeof component) {
        case 'number':
            return Math.abs(component);
        case 'string':
            return component.length;
        default:
            return component[0].length;
    }
};
const idDeleteComponent = (component) => {
    switch (typeof component) {
        case 'number':
            return component < 0;
        case 'object':
            return true;
        default:
            return false;
    }
};
const trim = (op) => {
    if (!op.length)
        return;
    const last = op[op.length - 1];
    const isLastRetain = typeof last === 'number' && last > 0;
    if (isLastRetain)
        op.pop();
};
const normalize = (op) => {
    const op2 = [];
    const length = op.length;
    for (let i = 0; i < length; i++)
        (0, exports.append)(op2, op[i]);
    trim(op2);
    return op2;
};
exports.normalize = normalize;
const apply = (str, op) => {
    const length = op.length;
    let res = '';
    let offset = 0;
    for (let i = 0; i < length; i++) {
        const component = op[i];
        switch (typeof component) {
            case 'number': {
                if (component > 0) {
                    const end = offset + component;
                    res += str.substring(offset, end);
                    offset = end;
                }
                else
                    offset -= component;
                break;
            }
            case 'string':
                res += component;
                break;
            case 'object':
                offset += component[0].length;
                break;
        }
    }
    return res + str.substring(offset);
};
exports.apply = apply;
const chunk = (component, offset, maxLength) => {
    switch (typeof component) {
        case 'number': {
            return component > 0 ? Math.min(component - offset, maxLength) : -Math.min(-component - offset, maxLength);
        }
        case 'string': {
            const end = Math.min(offset + maxLength, component.length);
            return component.substring(offset, end);
        }
        case 'object': {
            const str = component[0];
            const end = Math.min(offset + maxLength, str.length);
            return [str.substring(offset, end)];
        }
    }
};
const compose = (op1, op2) => {
    const op3 = [];
    const len1 = op1.length;
    const len2 = op2.length;
    let off1 = 0;
    let i1 = 0;
    for (let i2 = 0; i2 < len2; i2++) {
        const comp2 = op2[i2];
        let doDelete = false;
        switch (typeof comp2) {
            case 'number': {
                if (comp2 > 0) {
                    let length2 = comp2;
                    while (length2 > 0) {
                        const comp1 = op1[i1];
                        const comp = i1 >= len1 ? length2 : chunk(comp1, off1, length2);
                        const compLength = componentLength(comp);
                        const isDelete = idDeleteComponent(comp);
                        const length1 = componentLength(comp1 || comp);
                        (0, exports.append)(op3, comp);
                        off1 += compLength;
                        if (off1 >= length1) {
                            i1++;
                            off1 = 0;
                        }
                        if (!isDelete)
                            length2 -= compLength;
                    }
                }
                else
                    doDelete = true;
                break;
            }
            case 'string': {
                (0, exports.append)(op3, comp2);
                break;
            }
            case 'object': {
                doDelete = true;
                break;
            }
        }
        if (doDelete) {
            const isReversible = comp2 instanceof Array;
            const length2 = isReversible ? comp2[0].length : -comp2;
            let off2 = 0;
            while (off2 < length2) {
                const remaining = length2 - off2;
                const comp1 = op1[i1];
                const comp = i1 >= len1 ? remaining : chunk(comp1, off1, remaining);
                const compLength = componentLength(comp);
                const isDelete = idDeleteComponent(comp);
                const length1 = componentLength(comp1 || comp);
                if (isDelete)
                    (0, exports.append)(op3, comp);
                else if (typeof comp === 'number')
                    (0, exports.append)(op3, isReversible ? [comp2[0].substring(off2, off2 + compLength)] : -compLength);
                off1 += compLength;
                if (off1 >= length1) {
                    i1++;
                    off1 = 0;
                }
                if (!isDelete)
                    off2 += compLength;
            }
        }
    }
    if (i1 < len1 && off1)
        (0, exports.append)(op3, chunk(op1[i1++], off1, Infinity));
    for (; i1 < len1; i1++)
        (0, exports.append)(op3, op1[i1]);
    trim(op3);
    return op3;
};
exports.compose = compose;
const transform = (op1, op2, leftInsertFirst) => {
    const op3 = [];
    const len1 = op1.length;
    const len2 = op2.length;
    let i1 = 0;
    let i2 = 0;
    let off1 = 0;
    for (; i2 < len2; i2++) {
        const comp2 = op2[i2];
        let doDelete = false;
        switch (typeof comp2) {
            case 'number': {
                if (comp2 > 0) {
                    let length2 = comp2;
                    while (length2 > 0) {
                        const comp1 = op1[i1];
                        const comp = i1 >= len1 ? length2 : chunk(comp1, off1, length2);
                        const compLength = componentLength(comp);
                        const length1 = componentLength(comp1 || comp);
                        (0, exports.append)(op3, comp);
                        off1 += compLength;
                        if (off1 >= length1) {
                            i1++;
                            off1 = 0;
                        }
                        if (typeof comp !== 'string')
                            length2 -= compLength;
                    }
                }
                else
                    doDelete = true;
                break;
            }
            case 'string': {
                if (leftInsertFirst) {
                    if (typeof op1[i1] === 'string') {
                        const comp = chunk(op1[i1++], off1, Infinity);
                        off1 = 0;
                        (0, exports.append)(op3, comp);
                    }
                }
                (0, exports.append)(op3, comp2.length);
                break;
            }
            case 'object': {
                doDelete = true;
                break;
            }
        }
        if (doDelete) {
            const isReversible = comp2 instanceof Array;
            const length2 = isReversible ? comp2[0].length : -comp2;
            let off2 = 0;
            while (off2 < length2) {
                const remaining = length2 - off2;
                const comp1 = op1[i1];
                const comp = i1 >= len1 ? remaining : chunk(comp1, off1, remaining);
                const compLength = componentLength(comp);
                const length1 = componentLength(comp1 || comp);
                if (typeof comp === 'string')
                    (0, exports.append)(op3, comp);
                else
                    off2 += compLength;
                off1 += compLength;
                if (off1 >= length1) {
                    i1++;
                    off1 = 0;
                }
            }
        }
    }
    if (i1 < len1 && off1)
        (0, exports.append)(op3, chunk(op1[i1++], off1, Infinity));
    for (; i1 < len1; i1++)
        (0, exports.append)(op3, op1[i1]);
    trim(op3);
    return op3;
};
exports.transform = transform;
