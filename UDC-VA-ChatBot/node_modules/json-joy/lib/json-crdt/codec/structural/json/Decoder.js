"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decoder = void 0;
var tslib_1 = require("tslib");
var ArrayRga_1 = require("../../../types/rga-array/ArrayRga");
var BinaryRga_1 = require("../../../types/rga-binary/BinaryRga");
var Const_1 = require("../../../types/const/Const");
var RootLww_1 = require("../../../types/lww-root/RootLww");
var fromBase64_1 = require("../../../../util/base64/fromBase64");
var clock_1 = require("../../../../json-crdt-patch/clock");
var model_1 = require("../../../model");
var ObjectLww_1 = require("../../../types/lww-object/ObjectLww");
var StringRga_1 = require("../../../types/rga-string/StringRga");
var ValueLww_1 = require("../../../types/lww-value/ValueLww");
var Decoder = (function () {
    function Decoder() {
    }
    Decoder.prototype.decode = function (_a) {
        var time = _a.time, root = _a.root;
        var isServerClock = typeof time === 'number';
        var doc = isServerClock ? model_1.Model.withServerClock(time) : model_1.Model.withLogicalClock(this.cClock(time));
        this.cRoot(doc, root);
        return doc;
    };
    Decoder.prototype.cClock = function (timestamps) {
        var _a = tslib_1.__read(timestamps, 1), stamp = _a[0];
        var vectorClock = new clock_1.VectorClock(stamp[0], stamp[1]);
        var length = timestamps.length;
        for (var i = 1; i < length; i++) {
            var stamp_1 = timestamps[i];
            var _b = tslib_1.__read(stamp_1, 2), sessionId = _b[0], time = _b[1];
            vectorClock.observe((0, clock_1.ts)(sessionId, time), 1);
        }
        return vectorClock;
    };
    Decoder.prototype.cTs = function (stamp) {
        var isServerClock = typeof stamp === 'number';
        return isServerClock ? (0, clock_1.ts)(1, stamp) : (0, clock_1.ts)(stamp[0], stamp[1]);
    };
    Decoder.prototype.cRoot = function (doc, _a) {
        var node = _a.node;
        var val = node ? this.cNode(doc, node) : new Const_1.Const(doc.clock.tick(0), null);
        var root = new RootLww_1.RootLww(doc, val.id);
        doc.root = root;
    };
    Decoder.prototype.cNode = function (doc, node) {
        switch (node.type) {
            case 'obj':
                return this.cObj(doc, node);
            case 'arr':
                return this.cArr(doc, node);
            case 'str':
                return this.cStr(doc, node);
            case 'val':
                return this.cVal(doc, node);
            case 'const':
                return this.cConst(doc, node);
            case 'bin':
                return this.cBin(doc, node);
        }
        throw new Error('UNKNOWN_NODE');
    };
    Decoder.prototype.cObj = function (doc, node) {
        var e_1, _a;
        var id = this.cTs(node.id);
        var obj = new ObjectLww_1.ObjectLww(doc, id);
        var keys = Object.keys(node.keys);
        try {
            for (var keys_1 = tslib_1.__values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var key = keys_1_1.value;
                var keyNode = node.keys[key];
                obj.put(key, this.cNode(doc, keyNode).id);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        doc.index.set(obj);
        return obj;
    };
    Decoder.prototype.cArr = function (doc, node) {
        var _this = this;
        var rga = new ArrayRga_1.ArrayRga(doc, this.cTs(node.id));
        var chunks = node.chunks;
        var length = chunks.length;
        if (length) {
            var self_1 = this;
            var i_1 = 0;
            rga.ingest(length, function () {
                var c = chunks[i_1++];
                var id = self_1.cTs(c.id);
                if (typeof c.span === 'number')
                    return new ArrayRga_1.ArrayChunk(id, c.span, undefined);
                else {
                    var ids = c.nodes.map(function (n) { return _this.cNode(doc, n).id; });
                    return new ArrayRga_1.ArrayChunk(id, ids.length, ids);
                }
            });
        }
        doc.index.set(rga);
        return rga;
    };
    Decoder.prototype.cStr = function (doc, node) {
        var rga = new StringRga_1.StringRga(this.cTs(node.id));
        var chunks = node.chunks;
        var length = chunks.length;
        if (length) {
            var self_2 = this;
            var i_2 = 0;
            rga.ingest(length, function () {
                var c = chunks[i_2++];
                var id = self_2.cTs(c.id);
                if (typeof c.span === 'number')
                    return new StringRga_1.StringChunk(id, c.span, '');
                else {
                    var value = c.value;
                    return new StringRga_1.StringChunk(id, value.length, value);
                }
            });
        }
        doc.index.set(rga);
        return rga;
    };
    Decoder.prototype.cBin = function (doc, node) {
        var rga = new BinaryRga_1.BinaryRga(this.cTs(node.id));
        var chunks = node.chunks;
        var length = chunks.length;
        var self = this;
        if (length) {
            var i_3 = 0;
            rga.ingest(length, function () {
                var c = chunks[i_3++];
                var id = self.cTs(c.id);
                if (typeof c.span === 'number')
                    return new BinaryRga_1.BinaryChunk(id, c.span, undefined);
                else {
                    var value = c.value;
                    var buf = (0, fromBase64_1.fromBase64)(value);
                    return new BinaryRga_1.BinaryChunk(id, buf.length, buf);
                }
            });
        }
        doc.index.set(rga);
        return rga;
    };
    Decoder.prototype.cVal = function (doc, node) {
        var id = this.cTs(node.id);
        var val = this.cNode(doc, node.node);
        var obj = new ValueLww_1.ValueLww(doc, id, val.id);
        doc.index.set(obj);
        return obj;
    };
    Decoder.prototype.cConst = function (doc, node) {
        var id = this.cTs(node.id);
        var val = node.timestamp ? this.cTs(node.value) : node.value;
        var obj = new Const_1.Const(id, val);
        doc.index.set(obj);
        return obj;
    };
    return Decoder;
}());
exports.Decoder = Decoder;
