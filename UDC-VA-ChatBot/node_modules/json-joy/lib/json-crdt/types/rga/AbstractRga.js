"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractRga = void 0;
var tslib_1 = require("tslib");
var clock_1 = require("../../../json-crdt-patch/clock");
var isUint8Array_1 = require("../../../util/buffers/isUint8Array");
var util_1 = require("../../../util/trees/splay/util");
var util2_1 = require("../../../util/trees/splay/util2");
var util2_2 = require("../../../util/trees/util2");
var printBinary_1 = require("../../../util/print/printBinary");
var printTree_1 = require("../../../util/print/printTree");
var constants_1 = require("../../../json-crdt-patch/constants");
var compareById = function (c1, c2) {
    var ts1 = c1.id;
    var ts2 = c2.id;
    return ts1.sid - ts2.sid || ts1.time - ts2.time;
};
var updateLenOne = function (chunk) {
    var l = chunk.l;
    var r = chunk.r;
    chunk.len = (chunk.del ? 0 : chunk.span) + (l ? l.len : 0) + (r ? r.len : 0);
};
var updateLenOneLive = function (chunk) {
    var l = chunk.l;
    var r = chunk.r;
    chunk.len = chunk.span + (l ? l.len : 0) + (r ? r.len : 0);
};
var dLen = function (chunk, delta) {
    while (chunk) {
        chunk.len += delta;
        chunk = chunk.p;
    }
};
var next = function (curr) {
    var r = curr.r;
    if (r) {
        curr = r;
        var tmp = void 0;
        while ((tmp = curr.l))
            curr = tmp;
        return curr;
    }
    var p = curr.p;
    while (p && p.r === curr) {
        curr = p;
        p = p.p;
    }
    return p;
};
var prev = function (curr) {
    var l = curr.l;
    if (l) {
        curr = l;
        var tmp = void 0;
        while ((tmp = curr.r))
            curr = tmp;
        return curr;
    }
    var p = curr.p;
    while (p && p.l === curr) {
        curr = p;
        p = p.p;
    }
    return p;
};
var AbstractRga = (function () {
    function AbstractRga(id) {
        this.id = id;
        this.root = undefined;
        this.ids = undefined;
        this.count = 0;
    }
    AbstractRga.prototype.ins = function (after, id, content) {
        var rootId = this.id;
        var afterTime = after.time;
        var afterSid = after.sid;
        var isRootInsert = rootId.time === afterTime && rootId.sid === afterSid;
        if (isRootInsert) {
            this.insAfterRoot(after, id, content);
            return;
        }
        var curr = this.ids;
        var chunk = curr;
        while (curr) {
            var currId = curr.id;
            var currIdSid = currId.sid;
            if (currIdSid > afterSid) {
                curr = curr.l2;
            }
            else if (currIdSid < afterSid) {
                chunk = curr;
                curr = curr.r2;
            }
            else {
                var currIdTime = currId.time;
                if (currIdTime > afterTime) {
                    curr = curr.l2;
                }
                else if (currIdTime < afterTime) {
                    chunk = curr;
                    curr = curr.r2;
                }
                else {
                    chunk = curr;
                    break;
                }
            }
        }
        if (!chunk)
            return;
        var atId = chunk.id;
        var atIdTime = atId.time;
        var atIdSid = atId.sid;
        var atSpan = chunk.span;
        if (atIdSid !== afterSid)
            return;
        var offset = afterTime - atIdTime;
        if (offset >= atSpan)
            return;
        var offsetInInsertAtChunk = afterTime - atIdTime;
        this.insAfterChunk(after, chunk, offsetInInsertAtChunk, id, content);
    };
    AbstractRga.prototype.insAt = function (position, id, content) {
        if (!position) {
            var rootId = this.id;
            this.insAfterRoot(rootId, id, content);
            return rootId;
        }
        var found = this.findChunk(position - 1);
        if (!found)
            return undefined;
        var _a = tslib_1.__read(found, 2), at = _a[0], offset = _a[1];
        var atId = at.id;
        var after = offset === 0 ? atId : new clock_1.Timestamp(atId.sid, atId.time + offset);
        this.insAfterChunk(after, at, offset, id, content);
        return after;
    };
    AbstractRga.prototype.insAfterRoot = function (after, id, content) {
        var chunk = this.createChunk(id, content);
        var first = this.first();
        if (!first)
            this.setRoot(chunk);
        else if ((0, clock_1.compare)(first.id, id) < 0)
            this.insertBefore(chunk, first);
        else {
            if ((0, clock_1.containsId)(first.id, first.span, id))
                return;
            this.insertAfterRef(chunk, after, first);
        }
    };
    AbstractRga.prototype.insAfterChunk = function (after, chunk, chunkOffset, id, content) {
        var atId = chunk.id;
        var atIdTime = atId.time;
        var atIdSid = atId.sid;
        var atSpan = chunk.span;
        var newChunk = this.createChunk(id, content);
        var needsSplit = chunkOffset + 1 < atSpan;
        if (needsSplit) {
            var idSid = id.sid;
            var idTime = id.time;
            if (atIdSid === idSid && atIdTime <= idTime && atIdTime + atSpan - 1 >= idTime)
                return;
            if (idTime > after.time + 1 || idSid > after.sid) {
                this.insertInside(newChunk, chunk, chunkOffset + 1);
                this.splay(newChunk);
                return;
            }
        }
        this.insertAfterRef(newChunk, after, chunk);
        this.splay(newChunk);
    };
    AbstractRga.prototype.delete = function (spans) {
        var length = spans.length;
        for (var i = 0; i < length; i++)
            this.deleteSpan(spans[i]);
        this.onViewChange();
    };
    AbstractRga.prototype.deleteSpan = function (span) {
        var len = span.span;
        var t1 = span.time;
        var t2 = t1 + len - 1;
        var start = this.findById(span);
        if (!start)
            return;
        var chunk = start;
        var last = chunk;
        while (chunk) {
            last = chunk;
            var id = chunk.id;
            var chunkSpan = chunk.span;
            var c1 = id.time;
            var c2 = c1 + chunkSpan - 1;
            if (chunk.del) {
                if (c2 >= t2)
                    break;
                chunk = chunk.s;
                continue;
            }
            var deleteStartsFromLeft = t1 <= c1;
            var deleteStartsInTheMiddle = t1 <= c2;
            if (deleteStartsFromLeft) {
                var deleteFullyContainsChunk = t2 >= c2;
                if (deleteFullyContainsChunk) {
                    chunk.delete();
                    dLen(chunk, -chunk.span);
                    if (t2 <= c2)
                        break;
                }
                else {
                    var range = t2 - c1 + 1;
                    var newChunk = this.split(chunk, range);
                    chunk.delete();
                    updateLenOne(newChunk);
                    dLen(chunk, -chunk.span);
                    break;
                }
            }
            else if (deleteStartsInTheMiddle) {
                var deleteContainsRightSide = t2 >= c2;
                if (deleteContainsRightSide) {
                    var offset = t1 - c1;
                    var newChunk = this.split(chunk, offset);
                    newChunk.delete();
                    newChunk.len = newChunk.r ? newChunk.r.len : 0;
                    dLen(chunk, -newChunk.span);
                    if (t2 <= c2)
                        break;
                }
                else {
                    var right = this.split(chunk, t2 - c1 + 1);
                    var mid = this.split(chunk, t1 - c1);
                    mid.delete();
                    updateLenOne(right);
                    updateLenOne(mid);
                    dLen(chunk, -mid.span);
                    break;
                }
            }
            chunk = chunk.s;
        }
        if (last)
            this.mergeTombstones2(start, last);
    };
    AbstractRga.prototype.find = function (position) {
        var curr = this.root;
        while (curr) {
            var l = curr.l;
            var leftLength = l ? l.len : 0;
            var span = void 0;
            if (position < leftLength)
                curr = l;
            else if (curr.del) {
                position -= leftLength;
                curr = curr.r;
            }
            else if (position < leftLength + (span = curr.span)) {
                var ticks = position - leftLength;
                var id = curr.id;
                return !ticks ? id : new clock_1.Timestamp(id.sid, id.time + ticks);
            }
            else {
                position -= leftLength + span;
                curr = curr.r;
            }
        }
    };
    AbstractRga.prototype.findChunk = function (position) {
        var curr = this.root;
        while (curr) {
            var l = curr.l;
            var leftLength = l ? l.len : 0;
            var span = void 0;
            if (position < leftLength)
                curr = l;
            else if (curr.del) {
                position -= leftLength;
                curr = curr.r;
            }
            else if (position < leftLength + (span = curr.span)) {
                return [curr, position - leftLength];
            }
            else {
                position -= leftLength + span;
                curr = curr.r;
            }
        }
    };
    AbstractRga.prototype.findInterval = function (position, length) {
        var ranges = [];
        if (!length)
            return ranges;
        var curr = this.root;
        var offset = 0;
        while (curr) {
            var leftLength = curr.l ? curr.l.len : 0;
            if (position < leftLength)
                curr = curr.l;
            else if (curr.del) {
                position -= leftLength;
                curr = curr.r;
            }
            else if (position < leftLength + curr.span) {
                offset = position - leftLength;
                break;
            }
            else {
                position -= leftLength + curr.span;
                curr = curr.r;
            }
        }
        if (!curr)
            return ranges;
        if (curr.span >= length + offset) {
            var id_1 = curr.id;
            ranges.push((0, clock_1.tss)(id_1.sid, id_1.time + offset, length));
            return ranges;
        }
        var len = curr.span - offset;
        var id = curr.id;
        ranges.push((0, clock_1.tss)(id.sid, id.time + offset, len));
        length -= len;
        curr = next(curr);
        if (!curr)
            return ranges;
        do {
            if (curr.del)
                continue;
            var id_2 = curr.id;
            var span = curr.span;
            if (length <= span) {
                ranges.push((0, clock_1.tss)(id_2.sid, id_2.time, length));
                return ranges;
            }
            ranges.push((0, clock_1.tss)(id_2.sid, id_2.time, span));
            length -= span;
        } while ((curr = next(curr)) && length > 0);
        return ranges;
    };
    AbstractRga.prototype.findInterval2 = function (from, to) {
        var ranges = [];
        this.range0(undefined, from, to, function (chunk, off, len) {
            var id = chunk.id;
            ranges.push((0, clock_1.tss)(id.sid, id.time + off, len));
        });
        return ranges;
    };
    AbstractRga.prototype.range0 = function (startChunk, from, to, callback) {
        var chunk = startChunk ? startChunk : this.findById(from);
        if (startChunk)
            while (chunk && !(0, clock_1.containsId)(chunk.id, chunk.span, from))
                chunk = next(chunk);
        if (!chunk)
            return;
        if (!chunk.del) {
            var off = from.time - chunk.id.time;
            var toContainedInChunk = (0, clock_1.containsId)(chunk.id, chunk.span, to);
            if (toContainedInChunk) {
                var len_1 = to.time - from.time + 1;
                callback(chunk, off, len_1);
                return chunk;
            }
            var len = chunk.span - off;
            callback(chunk, off, len);
        }
        else {
            if ((0, clock_1.containsId)(chunk.id, chunk.span, to))
                return;
        }
        chunk = next(chunk);
        while (chunk) {
            var toContainedInChunk = (0, clock_1.containsId)(chunk.id, chunk.span, to);
            if (toContainedInChunk) {
                if (!chunk.del)
                    callback(chunk, 0, to.time - chunk.id.time + 1);
                return chunk;
            }
            if (!chunk.del)
                callback(chunk, 0, chunk.span);
            chunk = next(chunk);
        }
        return chunk;
    };
    AbstractRga.prototype.first = function () {
        var curr = this.root;
        while (curr) {
            var l = curr.l;
            if (l)
                curr = l;
            else
                return curr;
        }
        return curr;
    };
    AbstractRga.prototype.last = function () {
        var curr = this.root;
        while (curr) {
            var r = curr.r;
            if (r)
                curr = r;
            else
                return curr;
        }
        return curr;
    };
    AbstractRga.prototype.lastId = function () {
        var chunk = this.last();
        if (!chunk)
            return undefined;
        var id = chunk.id;
        var span = chunk.span;
        return span === 1 ? id : new clock_1.Timestamp(id.sid, id.time + span - 1);
    };
    AbstractRga.prototype.next = function (curr) {
        return next(curr);
    };
    AbstractRga.prototype.prev = function (curr) {
        return prev(curr);
    };
    AbstractRga.prototype.length = function () {
        var root = this.root;
        return root ? root.len : 0;
    };
    AbstractRga.prototype.size = function () {
        return this.count;
    };
    AbstractRga.prototype.pos = function (chunk) {
        var p = chunk.p;
        var l = chunk.l;
        if (!p)
            return l ? l.len : 0;
        var parentPos = this.pos(p);
        var isRightChild = p.r === chunk;
        if (isRightChild)
            return parentPos + (p.del ? 0 : p.span) + (l ? l.len : 0);
        var r = chunk.r;
        return parentPos - (chunk.del ? 0 : chunk.span) - (r ? r.len : 0);
    };
    AbstractRga.prototype.setRoot = function (chunk) {
        this.root = chunk;
        this.insertId(chunk);
        this.onViewChange();
    };
    AbstractRga.prototype.insertBefore = function (chunk, before) {
        var l = before.l;
        before.l = chunk;
        chunk.l = l;
        chunk.p = before;
        var lLen = 0;
        if (l) {
            l.p = chunk;
            lLen = l.len;
        }
        chunk.len = chunk.span + lLen;
        dLen(before, chunk.span);
        this.insertId(chunk);
        this.onViewChange();
    };
    AbstractRga.prototype.insertAfter = function (chunk, after) {
        var r = after.r;
        after.r = chunk;
        chunk.r = r;
        chunk.p = after;
        var rLen = 0;
        if (r) {
            r.p = chunk;
            rLen = r.len;
        }
        chunk.len = chunk.span + rLen;
        dLen(after, chunk.span);
        this.insertId(chunk);
        this.onViewChange();
    };
    AbstractRga.prototype.insertAfterRef = function (chunk, ref, left) {
        var id = chunk.id;
        var sid = id.sid;
        var time = id.time;
        var isSplit = false;
        for (;;) {
            var leftId = left.id;
            var leftNextTick = leftId.time + left.span;
            if (!left.s) {
                isSplit = leftId.sid === sid && leftNextTick === time && leftNextTick - 1 === ref.time;
                if (isSplit)
                    left.s = chunk;
            }
            var right = next(left);
            if (!right)
                break;
            var rightId = right.id;
            var rightIdTime = rightId.time;
            var rightIdSid = rightId.sid;
            if (rightIdTime < time)
                break;
            if (rightIdTime === time) {
                if (rightIdSid === sid)
                    return;
                if (rightIdSid < sid)
                    break;
            }
            left = right;
        }
        if (isSplit && !left.del) {
            this.mergeContent(left, chunk.data);
            left.s = undefined;
        }
        else
            this.insertAfter(chunk, left);
    };
    AbstractRga.prototype.mergeContent = function (chunk, content) {
        var span1 = chunk.span;
        chunk.merge(content);
        dLen(chunk, chunk.span - span1);
        this.onViewChange();
        return;
    };
    AbstractRga.prototype.insertInside = function (chunk, at, offset) {
        var p = at.p;
        var l = at.l;
        var r = at.r;
        var s = at.s;
        var len = at.len;
        var at2 = at.split(offset);
        at.s = at2;
        at2.s = s;
        at.l = at.r = at2.l = at2.r = undefined;
        at2.l = undefined;
        chunk.p = p;
        if (!l) {
            chunk.l = at;
            at.p = chunk;
        }
        else {
            chunk.l = l;
            l.p = chunk;
            var a = l.r;
            l.r = at;
            at.p = l;
            at.l = a;
            if (a)
                a.p = at;
        }
        if (!r) {
            chunk.r = at2;
            at2.p = chunk;
        }
        else {
            chunk.r = r;
            r.p = chunk;
            var b = r.l;
            r.l = at2;
            at2.p = r;
            at2.r = b;
            if (b)
                b.p = at2;
        }
        if (!p)
            this.root = chunk;
        else if (p.l === at)
            p.l = chunk;
        else
            p.r = chunk;
        updateLenOne(at);
        updateLenOne(at2);
        if (l)
            l.len = (l.l ? l.l.len : 0) + at.len + (l.del ? 0 : l.span);
        if (r)
            r.len = (r.r ? r.r.len : 0) + at2.len + (r.del ? 0 : r.span);
        chunk.len = len + chunk.span;
        var span = chunk.span;
        var curr = chunk.p;
        while (curr) {
            curr.len += span;
            curr = curr.p;
        }
        this.insertId(at2);
        this.insertIdFast(chunk);
        this.onViewChange();
    };
    AbstractRga.prototype.split = function (chunk, ticks) {
        var s = chunk.s;
        var newChunk = chunk.split(ticks);
        var r = chunk.r;
        chunk.s = newChunk;
        newChunk.r = r;
        newChunk.s = s;
        chunk.r = newChunk;
        newChunk.p = chunk;
        this.insertId(newChunk);
        if (r)
            r.p = newChunk;
        return newChunk;
    };
    AbstractRga.prototype.mergeTombstones = function (ch1, ch2) {
        if (!ch1.del || !ch2.del)
            return false;
        var id1 = ch1.id;
        var id2 = ch2.id;
        if (id1.sid !== id2.sid)
            return false;
        if (id1.time + ch1.span !== id2.time)
            return false;
        ch1.s = ch2.s;
        ch1.span += ch2.span;
        this.deleteChunk(ch2);
        return true;
    };
    AbstractRga.prototype.mergeTombstones2 = function (start, end) {
        var curr = start;
        while (curr) {
            var nextCurr = next(curr);
            if (!nextCurr)
                break;
            var merged = this.mergeTombstones(curr, nextCurr);
            if (!merged) {
                if (nextCurr === end) {
                    if (nextCurr) {
                        var n = next(nextCurr);
                        if (n)
                            this.mergeTombstones(nextCurr, n);
                    }
                    break;
                }
                curr = curr.s;
            }
        }
        var left = prev(start);
        if (left)
            this.mergeTombstones(left, start);
    };
    AbstractRga.prototype.removeTombstones = function () {
        var curr = this.first();
        var list = [];
        while (curr) {
            if (curr.del)
                list.push(curr);
            curr = next(curr);
        }
        for (var i = 0; i < list.length; i++)
            this.deleteChunk(list[i]);
    };
    AbstractRga.prototype.deleteChunk = function (chunk) {
        this.deleteId(chunk);
        var p = chunk.p;
        var l = chunk.l;
        var r = chunk.r;
        chunk.id = constants_1.ORIGIN;
        if (!l && !r) {
            if (!p)
                this.root = undefined;
            else {
                if (p.l === chunk)
                    p.l = undefined;
                else
                    p.r = undefined;
            }
        }
        else if (l && r) {
            var mostRightChildFromLeft = l;
            while (mostRightChildFromLeft.r)
                mostRightChildFromLeft = mostRightChildFromLeft.r;
            mostRightChildFromLeft.r = r;
            r.p = mostRightChildFromLeft;
            var rLen = r.len;
            var curr = void 0;
            curr = mostRightChildFromLeft;
            if (!p) {
                this.root = l;
                l.p = undefined;
            }
            else {
                if (p.l === chunk)
                    p.l = l;
                else
                    p.r = l;
                l.p = p;
            }
            while (curr && curr !== p) {
                curr.len += rLen;
                curr = curr.p;
            }
        }
        else {
            var child = (l || r);
            child.p = p;
            if (!p)
                this.root = child;
            else if (p.l === chunk)
                p.l = child;
            else
                p.r = child;
        }
    };
    AbstractRga.prototype.insertId = function (chunk) {
        this.ids = (0, util2_2.insert2)(this.ids, chunk, compareById);
        this.count++;
        this.ids = (0, util2_1.splay2)(this.ids, chunk);
    };
    AbstractRga.prototype.insertIdFast = function (chunk) {
        this.ids = (0, util2_2.insert2)(this.ids, chunk, compareById);
        this.count++;
    };
    AbstractRga.prototype.deleteId = function (chunk) {
        this.ids = (0, util2_2.remove2)(this.ids, chunk);
        this.count--;
    };
    AbstractRga.prototype.findById = function (after) {
        var afterSid = after.sid;
        var afterTime = after.time;
        var curr = this.ids;
        var chunk = curr;
        while (curr) {
            var currId = curr.id;
            var currIdSid = currId.sid;
            if (currIdSid > afterSid) {
                curr = curr.l2;
            }
            else if (currIdSid < afterSid) {
                chunk = curr;
                curr = curr.r2;
            }
            else {
                var currIdTime = currId.time;
                if (currIdTime > afterTime) {
                    curr = curr.l2;
                }
                else if (currIdTime < afterTime) {
                    chunk = curr;
                    curr = curr.r2;
                }
                else {
                    chunk = curr;
                    break;
                }
            }
        }
        if (!chunk)
            return;
        var atId = chunk.id;
        var atIdTime = atId.time;
        var atIdSid = atId.sid;
        var atSpan = chunk.span;
        if (atIdSid !== afterSid)
            return;
        if (afterTime < atIdTime)
            return;
        var offset = afterTime - atIdTime;
        if (offset >= atSpan)
            return;
        return chunk;
    };
    AbstractRga.prototype.splay = function (chunk) {
        var p = chunk.p;
        if (!p)
            return;
        var pp = p.p;
        var l2 = p.l === chunk;
        if (!pp) {
            if (l2)
                (0, util_1.rSplay)(chunk, p);
            else
                (0, util_1.lSplay)(chunk, p);
            this.root = chunk;
            updateLenOne(p);
            updateLenOneLive(chunk);
            return;
        }
        var l1 = pp.l === p;
        if (l1) {
            if (l2) {
                this.root = (0, util_1.llSplay)(this.root, chunk, p, pp);
            }
            else {
                this.root = (0, util_1.lrSplay)(this.root, chunk, p, pp);
            }
        }
        else {
            if (l2) {
                this.root = (0, util_1.rlSplay)(this.root, chunk, p, pp);
            }
            else {
                this.root = (0, util_1.rrSplay)(this.root, chunk, p, pp);
            }
        }
        updateLenOne(pp);
        updateLenOne(p);
        updateLenOneLive(chunk);
        this.splay(chunk);
    };
    AbstractRga.prototype.iterator = function () {
        var curr = this.first();
        return function () {
            var res = curr;
            if (curr)
                curr = next(curr);
            return res;
        };
    };
    AbstractRga.prototype.ingest = function (size, next) {
        if (size < 1)
            return;
        var splitLeftChunks = new Map();
        this.root = this._ingest(size, function () {
            var chunk = next();
            var id = chunk.id;
            var key = id.sid + '.' + id.time;
            var split = splitLeftChunks.get(key);
            if (split) {
                split.s = chunk;
                splitLeftChunks.delete(key);
            }
            var nextStampAfterSpan = (0, clock_1.tick)(id, chunk.span);
            splitLeftChunks.set(nextStampAfterSpan.sid + '.' + nextStampAfterSpan.time, chunk);
            return chunk;
        });
    };
    AbstractRga.prototype._ingest = function (size, next) {
        var leftSize = size >> 1;
        var rightSize = size - leftSize - 1;
        var c1 = leftSize > 0 ? this._ingest(leftSize, next) : undefined;
        var c2 = next();
        if (c1) {
            c2.l = c1;
            c1.p = c2;
        }
        var c3 = rightSize > 0 ? this._ingest(rightSize, next) : undefined;
        if (c3) {
            c2.r = c3;
            c3.p = c2;
        }
        updateLenOne(c2);
        this.insertId(c2);
        return c2;
    };
    AbstractRga.prototype.toString = function (tab) {
        var _this = this;
        if (tab === void 0) { tab = ''; }
        var view = this.view();
        var value = '';
        if ((0, isUint8Array_1.isUint8Array)(view))
            value += " { ".concat(('' + view).replaceAll(',', ', '), " }");
        else if (typeof view === 'string')
            value += "{ ".concat(view.length > 32 ? JSON.stringify(view.substring(0, 32)) + ' …' : JSON.stringify(view), " }");
        var header = "".concat(this.constructor.name, " ").concat((0, clock_1.toDisplayString)(this.id), " ").concat(value);
        return header + (0, printTree_1.printTree)(tab, [function (tab) { return (_this.root ? _this.printChunk(tab, _this.root) : '∅'); }]);
    };
    AbstractRga.prototype.printChunk = function (tab, chunk) {
        var _this = this;
        return (this.formatChunk(chunk) +
            (0, printBinary_1.printBinary)(tab, [
                chunk.l ? function (tab) { return _this.printChunk(tab, chunk.l); } : null,
                chunk.r ? function (tab) { return _this.printChunk(tab, chunk.r); } : null,
            ]));
    };
    AbstractRga.prototype.formatChunk = function (chunk) {
        var id = (0, clock_1.toDisplayString)(chunk.id);
        var str = "".concat(chunk.constructor.name, " ").concat(id, "!").concat(chunk.span, " len:").concat(chunk.len);
        if (chunk.del)
            str += " [".concat(chunk.span, "]");
        else {
            if ((0, isUint8Array_1.isUint8Array)(chunk.data))
                str += " { ".concat(chunk.data.toString(), " }");
            else if (typeof chunk.data === 'string') {
                var data = chunk.data.length > 32 ? JSON.stringify(chunk.data.substring(0, 32)) + ' …' : JSON.stringify(chunk.data);
                str += " { ".concat(data, " }");
            }
        }
        return str;
    };
    return AbstractRga;
}());
exports.AbstractRga = AbstractRga;
