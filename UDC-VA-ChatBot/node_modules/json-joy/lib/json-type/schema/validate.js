"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMinMax = exports.validateWithValidator = exports.validateTType = exports.validateTExample = exports.validateDisplay = void 0;
var tslib_1 = require("tslib");
var validateDisplay = function (_a) {
    var title = _a.title, description = _a.description, intro = _a.intro;
    if (title !== undefined && typeof title !== 'string')
        throw new Error('INVALID_TITLE');
    if (description !== undefined && typeof description !== 'string')
        throw new Error('INVALID_DESCRIPTION');
    if (intro !== undefined && typeof intro !== 'string')
        throw new Error('INVALID_INTRO');
};
exports.validateDisplay = validateDisplay;
var validateTExample = function (example) {
    (0, exports.validateDisplay)(example);
};
exports.validateTExample = validateTExample;
var validateTType = function (tType, __t) {
    (0, exports.validateDisplay)(tType);
    var id = tType.id;
    if (id !== undefined && typeof id !== 'string')
        throw new Error('INVALID_ID');
    if (tType.__t !== __t)
        throw new Error('INVALID_TYPE');
    var examples = tType.examples;
    if (examples) {
        if (!Array.isArray(examples))
            throw new Error('INVALID_EXAMPLES');
        examples.forEach(exports.validateTExample);
    }
};
exports.validateTType = validateTType;
var validateWithValidator = function (_a) {
    var e_1, _b;
    var validator = _a.validator;
    if (validator !== undefined) {
        if (Array.isArray(validator)) {
            try {
                for (var validator_1 = tslib_1.__values(validator), validator_1_1 = validator_1.next(); !validator_1_1.done; validator_1_1 = validator_1.next()) {
                    var v = validator_1_1.value;
                    if (typeof v !== 'string')
                        throw new Error('INVALID_VALIDATOR');
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (validator_1_1 && !validator_1_1.done && (_b = validator_1.return)) _b.call(validator_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else if (typeof validator !== 'string')
            throw new Error('INVALID_VALIDATOR');
    }
};
exports.validateWithValidator = validateWithValidator;
var validateMinMax = function (min, max) {
    if (min !== undefined) {
        if (typeof min !== 'number')
            throw new Error('MIN_TYPE');
        if (min < 0)
            throw new Error('MIN_NEGATIVE');
        if (min % 1 !== 0)
            throw new Error('MIN_DECIMAL');
    }
    if (max !== undefined) {
        if (typeof max !== 'number')
            throw new Error('MAX_TYPE');
        if (max < 0)
            throw new Error('MAX_NEGATIVE');
        if (max % 1 !== 0)
            throw new Error('MAX_DECIMAL');
    }
    if (min !== undefined && max !== undefined && min > max)
        throw new Error('MIN_MAX');
};
exports.validateMinMax = validateMinMax;
