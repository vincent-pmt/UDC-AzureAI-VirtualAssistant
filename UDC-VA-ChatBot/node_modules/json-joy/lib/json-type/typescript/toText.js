"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toText = void 0;
var wordWrap_1 = require("../../util/strings/wordWrap");
var util_1 = require("./util");
var formatComment = function (comment, __) {
    if (!comment)
        return '';
    var lines = (0, wordWrap_1.wordWrap)(comment, { width: 80 - 3 - __.length });
    return __ + '/**\n' + __ + ' * ' + lines.join('\n' + __ + ' * ') + '\n' + __ + ' */\n';
};
var toText = function (node, __) {
    if (__ === void 0) { __ = ''; }
    if (Array.isArray(node))
        return node.map(function (s) { return (0, exports.toText)(s, __); }).join('\n');
    var ____ = __ + util_1.TAB;
    switch (node.node) {
        case 'ModuleDeclaration': {
            var out = '';
            out += "".concat(__, "namespace ").concat(node.name, " {\n");
            out += (0, exports.toText)(node.statements, ____);
            out += "".concat(__, "}\n");
            return out;
        }
        case 'InterfaceDeclaration': {
            var name_1 = node.name, members = node.members, comment = node.comment;
            var out = '';
            out += formatComment(comment, __);
            out += "".concat(__, "interface ").concat(name_1, " {\n");
            out += (0, exports.toText)(members, ____);
            out += "\n".concat(__, "}\n");
            return out;
        }
        case 'PropertySignature': {
            var name_2 = (0, util_1.normalizeKey)(node.name);
            var out = '';
            out += formatComment(node.comment, __);
            return out + "".concat(__).concat(name_2).concat(node.optional ? '?' : '', ": ").concat((0, exports.toText)(node.type, __), ";");
        }
        case 'IndexSignature': {
            return "".concat(__, "[key: string]: ").concat((0, exports.toText)(node.type, __), ";");
        }
        case 'TypeAliasDeclaration': {
            var out = '';
            out += formatComment(node.comment, __);
            out += "".concat(__, "type ").concat(node.name, " = ").concat((0, exports.toText)(node.type), ";\n");
            return out;
        }
        case 'ArrayType': {
            var simple = (0, util_1.isSimpleType)(node.elementType);
            var inner = (0, exports.toText)(node.elementType, __);
            return simple ? "".concat(inner, "[]") : "Array<".concat(inner, ">");
        }
        case 'TupleType': {
            var hasObject = node.elements.some(function (e) { return e.node === 'TypeLiteral'; });
            if (hasObject) {
                return "[\n".concat(____).concat(node.elements.map(function (e) { return (0, exports.toText)(e, ____); }).join(',\n' + ____), "\n").concat(__, "]");
            }
            else
                return "[".concat(node.elements.map(function (e) { return (0, exports.toText)(e, __); }).join(', '), "]");
        }
        case 'GenericTypeAnnotation': {
            return node.id.name;
        }
        case 'StringKeyword': {
            return 'string';
        }
        case 'NumberKeyword': {
            return 'number';
        }
        case 'BooleanKeyword': {
            return 'boolean';
        }
        case 'NullKeyword': {
            return 'null';
        }
        case 'AnyKeyword': {
            return 'any';
        }
        case 'UnknownKeyword': {
            return 'unknown';
        }
        case 'TypeLiteral': {
            return "{\n".concat((0, exports.toText)(node.members, ____), "\n").concat(__, "}");
        }
        case 'StringLiteral': {
            return JSON.stringify(node.text);
        }
        case 'NumericLiteral': {
            return node.text;
        }
        case 'TrueKeyword': {
            return 'true';
        }
        case 'FalseKeyword': {
            return 'false';
        }
        case 'UnionType': {
            return node.types.map(function (t) { return (0, exports.toText)(t, ____); }).join(' | ');
        }
        case 'TypeReference': {
            return node.typeName;
        }
    }
    return '';
};
exports.toText = toText;
