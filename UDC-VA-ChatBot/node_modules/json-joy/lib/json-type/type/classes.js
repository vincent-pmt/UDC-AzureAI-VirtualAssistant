"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionStreamingType = exports.FunctionType = exports.OrType = exports.RefType = exports.ObjectType = exports.ObjectOptionalFieldType = exports.ObjectFieldType = exports.TupleType = exports.ArrayType = exports.BinaryType = exports.StringType = exports.NumberType = exports.BooleanType = exports.ConstType = exports.AnyType = void 0;
var tslib_1 = require("tslib");
var schema = tslib_1.__importStar(require("../schema"));
var util_1 = require("../util");
var json_clone_1 = require("../../json-clone");
var json_random_1 = require("../../json-random");
var json_binary_1 = require("../../json-binary");
var stringify_1 = require("../../json-text/stringify");
var printTree_1 = require("../../util/print/printTree");
var asString_1 = require("../../util/strings/asString");
var validate_1 = require("../schema/validate");
var ValidatorCodegenContext_1 = require("../codegen/validator/ValidatorCodegenContext");
var constants_1 = require("../constants");
var __deepEqual_1 = require("../../json-equal/$$deepEqual");
var normalizeAccessor_1 = require("../../util/codegen/util/normalizeAccessor");
var util_2 = require("../codegen/validator/util");
var JsonTextEncoderCodegenContext_1 = require("../codegen/json/JsonTextEncoderCodegenContext");
var CborEncoderCodegenContext_1 = require("../codegen/binary/CborEncoderCodegenContext");
var CborEncoder_1 = require("../../json-pack/cbor/CborEncoder");
var JsExpression_1 = require("../../util/codegen/util/JsExpression");
var MessagePackEncoderCodegenContext_1 = require("../codegen/binary/MessagePackEncoderCodegenContext");
var msgpack_1 = require("../../json-pack/msgpack");
var lazyFunction_1 = require("../../util/lazyFunction");
var JsonEncoderCodegenContext_1 = require("../codegen/binary/JsonEncoderCodegenContext");
var JsonEncoder_1 = require("../../json-pack/json/JsonEncoder");
var Writer_1 = require("../../util/buffers/Writer");
var CapacityEstimatorCodegenContext_1 = require("../codegen/capacity/CapacityEstimatorCodegenContext");
var json_size_1 = require("../../json-size");
var json_expression_1 = require("../../json-expression");
var augmentWithComment = function (type, node) {
    if (type.title || type.description) {
        var comment = '';
        if (type.title)
            comment += '# ' + type.title;
        if (type.title && type.description)
            comment += '\n\n';
        if (type.description)
            comment += type.description;
        node.comment = comment;
    }
};
var AbstractType = (function () {
    function AbstractType() {
        this.validators = {};
        this.encoders = new Map();
    }
    AbstractType.prototype.getTypeName = function () {
        return this.schema.__t;
    };
    AbstractType.prototype.getSchema = function () {
        return this.schema;
    };
    AbstractType.prototype.getValidatorNames = function () {
        var validator = this.schema.validator;
        if (!validator)
            return [];
        return Array.isArray(validator) ? validator : [validator];
    };
    AbstractType.prototype.toJsonSchema = function (ctx) {
        var schema = this.getSchema();
        var jsonSchema = {};
        if (schema.title)
            jsonSchema.title = schema.title;
        if (schema.description)
            jsonSchema.description = schema.description;
        if (schema.examples)
            jsonSchema.examples = schema.examples.map(function (example) { return example.value; });
        return jsonSchema;
    };
    AbstractType.prototype.options = function (options) {
        Object.assign(this.schema, options);
        return this;
    };
    AbstractType.prototype.getOptions = function () {
        var _a = this.schema, __t = _a.__t, options = tslib_1.__rest(_a, ["__t"]);
        return options;
    };
    AbstractType.prototype.validate = function (value) {
        var validator = this.validator('string');
        var err = validator(value);
        if (err)
            throw new Error(JSON.parse(err)[0]);
    };
    AbstractType.prototype.compileValidator = function (options) {
        var ctx = new ValidatorCodegenContext_1.ValidatorCodegenContext(tslib_1.__assign(tslib_1.__assign({ system: this.system, errors: 'object' }, options), { type: this }));
        this.codegenValidator(ctx, [], ctx.codegen.options.args[0]);
        return ctx.compile();
    };
    AbstractType.prototype.__compileValidator = function (kind) {
        return (this.validators[kind] = this.compileValidator({
            errors: kind,
            system: this.system,
            skipObjectExtraFieldsCheck: kind === 'boolean',
            unsafeMode: kind === 'boolean',
        }));
    };
    AbstractType.prototype.validator = function (kind) {
        var _this = this;
        return this.validators[kind] || (0, lazyFunction_1.lazy)(function () { return _this.__compileValidator(kind); });
    };
    AbstractType.prototype.compileJsonTextEncoder = function (options) {
        var ctx = new JsonTextEncoderCodegenContext_1.JsonTextEncoderCodegenContext(tslib_1.__assign(tslib_1.__assign({}, options), { system: this.system, type: this }));
        var r = ctx.codegen.options.args[0];
        var value = new JsExpression_1.JsExpression(function () { return r; });
        this.codegenJsonTextEncoder(ctx, value);
        return ctx.compile();
    };
    AbstractType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        throw new Error("".concat(this.constructor.name, ".codegenJsonTextEncoder() not implemented"));
    };
    AbstractType.prototype.jsonTextEncoder = function () {
        var _this = this;
        return (this.__jsonEncoder || (this.__jsonEncoder = (0, lazyFunction_1.lazy)(function () { return (_this.__jsonEncoder = _this.compileJsonTextEncoder({})); })));
    };
    AbstractType.prototype.compileEncoder = function (format, name) {
        switch (format) {
            case 0: {
                var encoder = this.compileCborEncoder({ name: name });
                this.encoders.set(0, encoder);
                return encoder;
            }
            case 1: {
                var encoder = this.compileMessagePackEncoder({ name: name });
                this.encoders.set(1, encoder);
                return encoder;
            }
            case 2: {
                var encoder = this.compileJsonEncoder({ name: name });
                this.encoders.set(2, encoder);
                return encoder;
            }
            default:
                throw new Error("Unsupported encoding format: ".concat(format));
        }
    };
    AbstractType.prototype.encoder = function (kind) {
        var _this = this;
        var encoders = this.encoders;
        var cachedEncoder = encoders.get(kind);
        if (cachedEncoder)
            return cachedEncoder;
        var temporaryWrappedEncoder = (0, lazyFunction_1.lazy)(function () { return _this.compileEncoder(kind); });
        encoders.set(kind, temporaryWrappedEncoder);
        return temporaryWrappedEncoder;
    };
    AbstractType.prototype.encode = function (codec, value) {
        var encoder = this.encoder(codec.format);
        var writer = codec.encoder.writer;
        writer.reset();
        encoder(value, codec.encoder);
        return writer.flush();
    };
    AbstractType.prototype.codegenValidator = function (ctx, path, r) {
        throw new Error("".concat(this.constructor.name, ".codegenValidator() not implemented"));
    };
    AbstractType.prototype.compileCborEncoder = function (options) {
        var ctx = new CborEncoderCodegenContext_1.CborEncoderCodegenContext(tslib_1.__assign(tslib_1.__assign({ system: this.system, encoder: new CborEncoder_1.CborEncoder() }, options), { type: this }));
        var r = ctx.codegen.options.args[0];
        var value = new JsExpression_1.JsExpression(function () { return r; });
        this.codegenCborEncoder(ctx, value);
        return ctx.compile();
    };
    AbstractType.prototype.codegenCborEncoder = function (ctx, value) {
        throw new Error("".concat(this.constructor.name, ".codegenCborEncoder() not implemented"));
    };
    AbstractType.prototype.compileMessagePackEncoder = function (options) {
        var ctx = new MessagePackEncoderCodegenContext_1.MessagePackEncoderCodegenContext(tslib_1.__assign(tslib_1.__assign({ system: this.system, encoder: new msgpack_1.MsgPackEncoder() }, options), { type: this }));
        var r = ctx.codegen.options.args[0];
        var value = new JsExpression_1.JsExpression(function () { return r; });
        this.codegenMessagePackEncoder(ctx, value);
        return ctx.compile();
    };
    AbstractType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        throw new Error("".concat(this.constructor.name, ".codegenMessagePackEncoder() not implemented"));
    };
    AbstractType.prototype.compileJsonEncoder = function (options) {
        var writer = new Writer_1.Writer();
        var ctx = new JsonEncoderCodegenContext_1.JsonEncoderCodegenContext(tslib_1.__assign(tslib_1.__assign({ system: this.system, encoder: new JsonEncoder_1.JsonEncoder(writer) }, options), { type: this }));
        var r = ctx.codegen.options.args[0];
        var value = new JsExpression_1.JsExpression(function () { return r; });
        this.codegenJsonEncoder(ctx, value);
        return ctx.compile();
    };
    AbstractType.prototype.codegenJsonEncoder = function (ctx, value) {
        throw new Error("".concat(this.constructor.name, ".codegenJsonEncoder() not implemented"));
    };
    AbstractType.prototype.compileCapacityEstimator = function (options) {
        var ctx = new CapacityEstimatorCodegenContext_1.CapacityEstimatorCodegenContext(tslib_1.__assign(tslib_1.__assign({ system: this.system }, options), { type: this }));
        var r = ctx.codegen.options.args[0];
        var value = new JsExpression_1.JsExpression(function () { return r; });
        this.codegenCapacityEstimator(ctx, value);
        return ctx.compile();
    };
    AbstractType.prototype.codegenCapacityEstimator = function (ctx, value) {
        throw new Error("".concat(this.constructor.name, ".codegenCapacityEstimator() not implemented"));
    };
    AbstractType.prototype.capacityEstimator = function () {
        var _this = this;
        return (this.__capacityEstimator ||
            (this.__capacityEstimator = (0, lazyFunction_1.lazy)(function () { return (_this.__capacityEstimator = _this.compileCapacityEstimator({})); })));
    };
    AbstractType.prototype.random = function () {
        return json_random_1.RandomJson.generate({ nodeCount: 5 });
    };
    AbstractType.prototype.toTypeScriptAst = function () {
        var node = { node: 'UnknownKeyword' };
        return node;
    };
    AbstractType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        return JSON.stringify(value);
    };
    AbstractType.prototype.toStringTitle = function () {
        return this.getTypeName();
    };
    AbstractType.prototype.toStringOptions = function () {
        var options = this.getOptions();
        if (Object.keys(options).length === 0)
            return '';
        return (0, stringify_1.stringify)(options);
    };
    AbstractType.prototype.toString = function (tab) {
        if (tab === void 0) { tab = ''; }
        var options = this.toStringOptions();
        return this.toStringTitle() + (options ? " ".concat(options) : '');
    };
    return AbstractType;
}());
var AnyType = (function (_super) {
    tslib_1.__extends(AnyType, _super);
    function AnyType(schema) {
        var _this = _super.call(this) || this;
        _this.schema = schema;
        return _this;
    }
    AnyType.prototype.toJsonSchema = function (ctx) {
        return tslib_1.__assign({ type: ['string', 'number', 'boolean', 'null', 'array', 'object'] }, _super.prototype.toJsonSchema.call(this, ctx));
    };
    AnyType.prototype.validateSchema = function () {
        (0, validate_1.validateTType)(this.getSchema(), 'any');
    };
    AnyType.prototype.codegenValidator = function (ctx, path, r) {
        ctx.emitCustomValidators(this, path, r);
    };
    AnyType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        ctx.js("s += stringify(".concat(value.use(), ");"));
    };
    AnyType.prototype.codegenBinaryEncoder = function (ctx, value) {
        ctx.codegen.link('Value');
        var r = ctx.codegen.var(value.use());
        ctx.codegen.if("".concat(r, " instanceof Value"), function () {
            ctx.codegen.if("".concat(r, ".type"), function () {
                var type = ctx instanceof CborEncoderCodegenContext_1.CborEncoderCodegenContext
                    ? 0
                    : ctx instanceof MessagePackEncoderCodegenContext_1.MessagePackEncoderCodegenContext
                        ? 1
                        : 2;
                ctx.js("".concat(r, ".type.encoder(").concat(type, ")(").concat(r, ".data, encoder);"));
            }, function () {
                ctx.js("encoder.writeAny(".concat(r, ".data);"));
            });
        }, function () {
            ctx.js("encoder.writeAny(".concat(r, ");"));
        });
    };
    AnyType.prototype.codegenCborEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    AnyType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    AnyType.prototype.codegenJsonEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    AnyType.prototype.codegenCapacityEstimator = function (ctx, value) {
        var codegen = ctx.codegen;
        codegen.link('Value');
        var r = codegen.var(value.use());
        codegen.if("".concat(r, " instanceof Value"), function () {
            codegen.if("".concat(r, ".type"), function () {
                ctx.codegen.js("size += ".concat(r, ".type.capacityEstimator()(").concat(r, ".data);"));
            }, function () {
                ctx.codegen.js("size += maxEncodingCapacity(".concat(r, ".data);"));
            });
        }, function () {
            ctx.codegen.js("size += maxEncodingCapacity(".concat(r, ");"));
        });
    };
    AnyType.prototype.random = function () {
        return json_random_1.RandomJson.generate({ nodeCount: 5 });
    };
    AnyType.prototype.toTypeScriptAst = function () {
        return { node: 'AnyKeyword' };
    };
    return AnyType;
}(AbstractType));
exports.AnyType = AnyType;
var ConstType = (function (_super) {
    tslib_1.__extends(ConstType, _super);
    function ConstType(schema) {
        var _this = _super.call(this) || this;
        _this.schema = schema;
        _this.__json = JSON.stringify(schema.value);
        return _this;
    }
    ConstType.prototype.value = function () {
        return this.schema.value;
    };
    ConstType.prototype.toJsonSchema = function (ctx) {
        var schema = this.schema;
        return tslib_1.__assign({ type: typeof this.schema.value, const: schema.value }, _super.prototype.toJsonSchema.call(this, ctx));
    };
    ConstType.prototype.getOptions = function () {
        var _a = this.schema, __t = _a.__t, value = _a.value, options = tslib_1.__rest(_a, ["__t", "value"]);
        return options;
    };
    ConstType.prototype.validateSchema = function () {
        (0, validate_1.validateTType)(this.getSchema(), 'const');
    };
    ConstType.prototype.codegenValidator = function (ctx, path, r) {
        var value = this.schema.value;
        var equals = (0, __deepEqual_1.$$deepEqual)(value);
        var fn = ctx.codegen.addConstant(equals);
        ctx.js("if (!".concat(fn, "(").concat(r, ")) return ").concat(ctx.err(constants_1.ValidationError.CONST, path)));
        ctx.emitCustomValidators(this, path, r);
    };
    ConstType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        ctx.writeText(JSON.stringify(this.schema.value));
    };
    ConstType.prototype.codegenBinaryEncoder = function (ctx, value) {
        var _this = this;
        ctx.blob(ctx.gen(function (encoder) {
            encoder.writeAny(_this.schema.value);
        }));
    };
    ConstType.prototype.codegenCborEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    ConstType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    ConstType.prototype.codegenJsonEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    ConstType.prototype.codegenCapacityEstimator = function (ctx, value) {
        ctx.inc((0, json_size_1.maxEncodingCapacity)(this.value()));
    };
    ConstType.prototype.random = function () {
        return (0, json_clone_1.cloneBinary)(this.schema.value);
    };
    ConstType.prototype.toTypeScriptAst = function () {
        var value = this.schema.value;
        if (value === null) {
            var node = { node: 'NullKeyword' };
            return node;
        }
        switch (typeof value) {
            case 'string': {
                var node = { node: 'StringLiteral', text: value };
                return node;
            }
            case 'number': {
                var node = { node: 'NumericLiteral', text: value.toString() };
                return node;
            }
            case 'boolean': {
                var node = { node: value ? 'TrueKeyword' : 'FalseKeyword' };
                return node;
            }
            case 'object': {
                var node = { node: 'ObjectKeyword' };
                return node;
            }
            default: {
                var node = { node: 'UnknownKeyword' };
                return node;
            }
        }
    };
    ConstType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        return this.__json;
    };
    ConstType.prototype.toString = function (tab) {
        if (tab === void 0) { tab = ''; }
        return "".concat(_super.prototype.toString.call(this, tab), " \u2192 ").concat(JSON.stringify(this.schema.value));
    };
    return ConstType;
}(AbstractType));
exports.ConstType = ConstType;
var BooleanType = (function (_super) {
    tslib_1.__extends(BooleanType, _super);
    function BooleanType(schema) {
        var _this = _super.call(this) || this;
        _this.schema = schema;
        return _this;
    }
    BooleanType.prototype.toJsonSchema = function (ctx) {
        return tslib_1.__assign({ type: 'boolean' }, _super.prototype.toJsonSchema.call(this, ctx));
    };
    BooleanType.prototype.validateSchema = function () {
        (0, validate_1.validateTType)(this.getSchema(), 'bool');
    };
    BooleanType.prototype.codegenValidator = function (ctx, path, r) {
        var err = ctx.err(constants_1.ValidationError.BOOL, path);
        ctx.js("if(typeof ".concat(r, " !== \"boolean\") return ").concat(err, ";"));
        ctx.emitCustomValidators(this, path, r);
    };
    BooleanType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        ctx.js("s += ".concat(value.use(), " ? 'true' : 'false';"));
    };
    BooleanType.prototype.codegenBinaryEncoder = function (ctx, value) {
        ctx.js("encoder.writeBoolean(".concat(value.use(), ");"));
    };
    BooleanType.prototype.codegenCborEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    BooleanType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    BooleanType.prototype.codegenJsonEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    BooleanType.prototype.codegenCapacityEstimator = function (ctx, value) {
        ctx.inc(5);
    };
    BooleanType.prototype.random = function () {
        return json_random_1.RandomJson.genBoolean();
    };
    BooleanType.prototype.toTypeScriptAst = function () {
        return { node: 'BooleanKeyword' };
    };
    BooleanType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        return (value ? 'true' : 'false');
    };
    return BooleanType;
}(AbstractType));
exports.BooleanType = BooleanType;
var NumberType = (function (_super) {
    tslib_1.__extends(NumberType, _super);
    function NumberType(schema) {
        var _this = _super.call(this) || this;
        _this.schema = schema;
        return _this;
    }
    NumberType.prototype.toJsonSchema = function (ctx) {
        var schema = this.getSchema();
        var jsonSchema = tslib_1.__assign({ type: 'number' }, _super.prototype.toJsonSchema.call(this, ctx));
        if (schema.format && util_1.ints.has(schema.format))
            jsonSchema.type = 'integer';
        if (schema.gt !== undefined)
            jsonSchema.exclusiveMinimum = schema.gt;
        if (schema.gte !== undefined)
            jsonSchema.minimum = schema.gte;
        if (schema.lt !== undefined)
            jsonSchema.exclusiveMaximum = schema.lt;
        if (schema.lte !== undefined)
            jsonSchema.maximum = schema.lte;
        return jsonSchema;
    };
    NumberType.prototype.validateSchema = function () {
        var schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'num');
        (0, validate_1.validateWithValidator)(schema);
        var format = schema.format, gt = schema.gt, gte = schema.gte, lt = schema.lt, lte = schema.lte;
        if (gt !== undefined && typeof gt !== 'number')
            throw new Error('GT_TYPE');
        if (gte !== undefined && typeof gte !== 'number')
            throw new Error('GTE_TYPE');
        if (lt !== undefined && typeof lt !== 'number')
            throw new Error('LT_TYPE');
        if (lte !== undefined && typeof lte !== 'number')
            throw new Error('LTE_TYPE');
        if (gt !== undefined && gte !== undefined)
            throw new Error('GT_GTE');
        if (lt !== undefined && lte !== undefined)
            throw new Error('LT_LTE');
        if ((gt !== undefined || gte !== undefined) && (lt !== undefined || lte !== undefined))
            if ((gt !== null && gt !== void 0 ? gt : gte) > (lt !== null && lt !== void 0 ? lt : lte))
                throw new Error('GT_LT');
        if (format !== undefined) {
            if (typeof format !== 'string')
                throw new Error('FORMAT_TYPE');
            if (!format)
                throw new Error('FORMAT_EMPTY');
            switch (format) {
                case 'i':
                case 'u':
                case 'f':
                case 'i8':
                case 'i16':
                case 'i32':
                case 'i64':
                case 'u8':
                case 'u16':
                case 'u32':
                case 'u64':
                case 'f32':
                case 'f64':
                    break;
                default:
                    throw new Error('FORMAT_INVALID');
            }
        }
    };
    NumberType.prototype.codegenValidator = function (ctx, path, r) {
        var _a = this.schema, format = _a.format, gt = _a.gt, gte = _a.gte, lt = _a.lt, lte = _a.lte;
        if (format && util_1.ints.has(format)) {
            var errInt = ctx.err(constants_1.ValidationError.INT, path);
            ctx.js("if(!Number.isInteger(".concat(r, ")) return ").concat(errInt, ";"));
            if (util_1.uints.has(format)) {
                var err = ctx.err(constants_1.ValidationError.UINT, path);
                ctx.js("if(".concat(r, " < 0) return ").concat(err, ";"));
                switch (format) {
                    case 'u8': {
                        ctx.js("if(".concat(r, " > 0xFF) return ").concat(err, ";"));
                        break;
                    }
                    case 'u16': {
                        ctx.js("if(".concat(r, " > 0xFFFF) return ").concat(err, ";"));
                        break;
                    }
                    case 'u32': {
                        ctx.js("if(".concat(r, " > 0xFFFFFFFF) return ").concat(err, ";"));
                        break;
                    }
                }
            }
            else {
                switch (format) {
                    case 'i8': {
                        ctx.js("if(".concat(r, " > 0x7F || ").concat(r, " < -0x80) return ").concat(errInt, ";"));
                        break;
                    }
                    case 'i16': {
                        ctx.js("if(".concat(r, " > 0x7FFF || ").concat(r, " < -0x8000) return ").concat(errInt, ";"));
                        break;
                    }
                    case 'i32': {
                        ctx.js("if(".concat(r, " > 0x7FFFFFFF || ").concat(r, " < -0x80000000) return ").concat(errInt, ";"));
                        break;
                    }
                }
            }
        }
        else if (util_1.floats.has(format)) {
            var err = ctx.err(constants_1.ValidationError.NUM, path);
            ctx.codegen.js("if(!Number.isFinite(".concat(r, ")) return ").concat(err, ";"));
        }
        else {
            var err = ctx.err(constants_1.ValidationError.NUM, path);
            ctx.codegen.js("if(typeof ".concat(r, " !== \"number\") return ").concat(err, ";"));
        }
        if (gt !== undefined) {
            var err = ctx.err(constants_1.ValidationError.GT, path);
            ctx.codegen.js("if(".concat(r, " <= ").concat(gt, ") return ").concat(err, ";"));
        }
        if (gte !== undefined) {
            var err = ctx.err(constants_1.ValidationError.GTE, path);
            ctx.codegen.js("if(".concat(r, " < ").concat(gte, ") return ").concat(err, ";"));
        }
        if (lt !== undefined) {
            var err = ctx.err(constants_1.ValidationError.LT, path);
            ctx.codegen.js("if(".concat(r, " >= ").concat(lt, ") return ").concat(err, ";"));
        }
        if (lte !== undefined) {
            var err = ctx.err(constants_1.ValidationError.LTE, path);
            ctx.codegen.js("if(".concat(r, " > ").concat(lte, ") return ").concat(err, ";"));
        }
        ctx.emitCustomValidators(this, path, r);
    };
    NumberType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        ctx.js("s += ".concat(value.use(), ";"));
    };
    NumberType.prototype.codegenBinaryEncoder = function (ctx, value) {
        var format = this.schema.format;
        var v = value.use();
        if (util_1.uints.has(format))
            ctx.js("encoder.writeUInteger(".concat(v, ");"));
        else if (util_1.ints.has(format))
            ctx.js("encoder.writeInteger(".concat(v, ");"));
        else if (util_1.floats.has(format))
            ctx.js("encoder.writeFloat(".concat(v, ");"));
        else
            ctx.js("encoder.writeNumber(".concat(v, ");"));
    };
    NumberType.prototype.codegenCborEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    NumberType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    NumberType.prototype.codegenJsonEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    NumberType.prototype.codegenCapacityEstimator = function (ctx, value) {
        ctx.inc(22);
    };
    NumberType.prototype.random = function () {
        var num = Math.random();
        var min = Number.MIN_SAFE_INTEGER;
        var max = Number.MAX_SAFE_INTEGER;
        if (this.schema.gt !== undefined)
            min = this.schema.gt;
        if (this.schema.gte !== undefined)
            min = this.schema.gte + 0.000000000000001;
        if (this.schema.lt !== undefined)
            max = this.schema.lt;
        if (this.schema.lte !== undefined)
            max = this.schema.lte - 0.000000000000001;
        if (this.schema.format) {
            switch (this.schema.format) {
                case 'i8':
                    min = Math.max(min, -0x80);
                    max = Math.min(max, 0x7f);
                    break;
                case 'i16':
                    min = Math.max(min, -0x8000);
                    max = Math.min(max, 0x7fff);
                    break;
                case 'i32':
                    min = Math.max(min, -0x80000000);
                    max = Math.min(max, 0x7fffffff);
                    break;
                case 'i64':
                case 'i':
                    min = Math.max(min, -0x8000000000);
                    max = Math.min(max, 0x7fffffffff);
                    break;
                case 'u8':
                    min = Math.max(min, 0);
                    max = Math.min(max, 0xff);
                    break;
                case 'u16':
                    min = Math.max(min, 0);
                    max = Math.min(max, 0xffff);
                    break;
                case 'u32':
                    min = Math.max(min, 0);
                    max = Math.min(max, 0xffffffff);
                    break;
                case 'u64':
                case 'u':
                    min = Math.max(min, 0);
                    max = Math.min(max, 0xffffffffffff);
                    break;
            }
            return Math.round(num * (max - min)) + min;
        }
        num = num * (max - min) + min;
        if (Math.random() > 0.7)
            num = Math.round(num);
        if (num === -0)
            return 0;
        return num;
    };
    NumberType.prototype.toTypeScriptAst = function () {
        return { node: 'NumberKeyword' };
    };
    NumberType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        return ('' + value);
    };
    return NumberType;
}(AbstractType));
exports.NumberType = NumberType;
var StringType = (function (_super) {
    tslib_1.__extends(StringType, _super);
    function StringType(schema) {
        var _this = _super.call(this) || this;
        _this.schema = schema;
        return _this;
    }
    StringType.prototype.toJsonSchema = function (ctx) {
        var schema = this.getSchema();
        var jsonSchema = tslib_1.__assign({ type: 'string' }, _super.prototype.toJsonSchema.call(this, ctx));
        if (schema.min !== undefined)
            jsonSchema.minLength = schema.min;
        if (schema.max !== undefined)
            jsonSchema.maxLength = schema.max;
        return jsonSchema;
    };
    StringType.prototype.validateSchema = function () {
        var schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'str');
        (0, validate_1.validateWithValidator)(schema);
        var min = schema.min, max = schema.max, ascii = schema.ascii, noJsonEscape = schema.noJsonEscape;
        (0, validate_1.validateMinMax)(min, max);
        if (ascii !== undefined) {
            if (typeof ascii !== 'boolean')
                throw new Error('ASCII');
        }
        if (noJsonEscape !== undefined) {
            if (typeof noJsonEscape !== 'boolean')
                throw new Error('NO_JSON_ESCAPE_TYPE');
        }
    };
    StringType.prototype.codegenValidator = function (ctx, path, r) {
        var error = ctx.err(constants_1.ValidationError.STR, path);
        ctx.js("if(typeof ".concat(r, " !== \"string\") return ").concat(error, ";"));
        var _a = this.schema, min = _a.min, max = _a.max;
        if (typeof min === 'number' && min === max) {
            var err = ctx.err(constants_1.ValidationError.STR_LEN, path);
            ctx.js("if(".concat(r, ".length !== ").concat(min, ") return ").concat(err, ";"));
        }
        else {
            if (typeof min === 'number') {
                var err = ctx.err(constants_1.ValidationError.STR_LEN, path);
                ctx.js("if(".concat(r, ".length < ").concat(min, ") return ").concat(err, ";"));
            }
            if (typeof max === 'number') {
                var err = ctx.err(constants_1.ValidationError.STR_LEN, path);
                ctx.js("if(".concat(r, ".length > ").concat(max, ") return ").concat(err, ";"));
            }
        }
        ctx.emitCustomValidators(this, path, r);
    };
    StringType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        if (this.schema.noJsonEscape) {
            ctx.writeText('"');
            ctx.js("s += ".concat(value.use(), ";"));
            ctx.writeText('"');
        }
        else
            ctx.js("s += asString(".concat(value.use(), ");"));
    };
    StringType.prototype.codegenBinaryEncoder = function (ctx, value) {
        var ascii = this.schema.ascii;
        var v = value.use();
        if (ascii)
            ctx.js("encoder.writeAsciiStr(".concat(v, ");"));
        else
            ctx.js("encoder.writeStr(".concat(v, ");"));
    };
    StringType.prototype.codegenCborEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    StringType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    StringType.prototype.codegenJsonEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    StringType.prototype.codegenCapacityEstimator = function (ctx, value) {
        ctx.inc(5);
        ctx.codegen.js("size += ".concat(5, " * ").concat(value.use(), ".length;"));
    };
    StringType.prototype.random = function () {
        var length = Math.round(Math.random() * 10);
        var _a = this.schema, min = _a.min, max = _a.max;
        if (min !== undefined && length < min)
            length = min + length;
        if (max !== undefined && length > max)
            length = max;
        return json_random_1.RandomJson.genString(length);
    };
    StringType.prototype.toTypeScriptAst = function () {
        return { node: 'StringKeyword' };
    };
    StringType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        return (this.schema.noJsonEscape ? '"' + value + '"' : (0, asString_1.asString)(value));
    };
    return StringType;
}(AbstractType));
exports.StringType = StringType;
var BinaryType = (function (_super) {
    tslib_1.__extends(BinaryType, _super);
    function BinaryType(type, options) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this.schema = schema.s.Binary(schema.s.any, options);
        return _this;
    }
    BinaryType.prototype.getSchema = function () {
        return tslib_1.__assign(tslib_1.__assign({}, this.schema), { type: this.type.getSchema() });
    };
    BinaryType.prototype.toJsonSchema = function (ctx) {
        return tslib_1.__assign({ type: 'binary' }, _super.prototype.toJsonSchema.call(this, ctx));
    };
    BinaryType.prototype.getOptions = function () {
        var _a = this.schema, __t = _a.__t, type = _a.type, options = tslib_1.__rest(_a, ["__t", "type"]);
        return options;
    };
    BinaryType.prototype.validateSchema = function () {
        (0, validate_1.validateTType)(this.getSchema(), 'bin');
        this.type.validateSchema();
    };
    BinaryType.prototype.codegenValidator = function (ctx, path, r) {
        var hasBuffer = typeof Buffer === 'function';
        var err = ctx.err(constants_1.ValidationError.BIN, path);
        ctx.js("if(!(".concat(r, " instanceof Uint8Array)").concat(hasBuffer ? " && !Buffer.isBuffer(".concat(r, ")") : '', ") return ").concat(err, ";"));
        ctx.emitCustomValidators(this, path, r);
    };
    BinaryType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        ctx.linkBase64();
        ctx.writeText('"data:application/octet-stream;base64,');
        ctx.js("s += toBase64(".concat(value.use(), ");"));
        ctx.writeText('"');
    };
    BinaryType.prototype.codegenBinaryEncoder = function (ctx, value) {
        ctx.js("encoder.writeBin(".concat(value.use(), ");"));
    };
    BinaryType.prototype.codegenCborEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    BinaryType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    BinaryType.prototype.codegenJsonEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    BinaryType.prototype.codegenCapacityEstimator = function (ctx, value) {
        ctx.inc(41);
        ctx.codegen.js("size += ".concat(2, " * ").concat(value.use(), ".length;"));
    };
    BinaryType.prototype.random = function () {
        var octets = json_random_1.RandomJson.genString()
            .split('')
            .map(function (c) { return c.charCodeAt(0); });
        return new Uint8Array(octets);
    };
    BinaryType.prototype.toTypeScriptAst = function () {
        return {
            node: 'GenericTypeAnnotation',
            id: {
                node: 'Identifier',
                name: 'Uint8Array',
            },
        };
    };
    BinaryType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        return ('"' + (0, json_binary_1.stringifyBinary)(value) + '"');
    };
    BinaryType.prototype.toString = function (tab) {
        var _this = this;
        if (tab === void 0) { tab = ''; }
        return _super.prototype.toString.call(this, tab) + (0, printTree_1.printTree)(tab, [function (tab) { return _this.type.toString(tab); }]);
    };
    return BinaryType;
}(AbstractType));
exports.BinaryType = BinaryType;
var ArrayType = (function (_super) {
    tslib_1.__extends(ArrayType, _super);
    function ArrayType(type, options) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this.schema = schema.s.Array(schema.s.any, options);
        return _this;
    }
    ArrayType.prototype.getSchema = function (ctx) {
        return tslib_1.__assign(tslib_1.__assign({}, this.schema), { type: this.type.getSchema(ctx) });
    };
    ArrayType.prototype.toJsonSchema = function () {
        var schema = this.getSchema();
        var jsonSchema = tslib_1.__assign({ type: 'array', items: this.type.toJsonSchema() }, _super.prototype.toJsonSchema.call(this));
        if (schema.min !== undefined)
            jsonSchema.minItems = schema.min;
        if (schema.max !== undefined)
            jsonSchema.maxItems = schema.max;
        return jsonSchema;
    };
    ArrayType.prototype.getOptions = function () {
        var _a = this.schema, __t = _a.__t, type = _a.type, options = tslib_1.__rest(_a, ["__t", "type"]);
        return options;
    };
    ArrayType.prototype.validateSchema = function () {
        var schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'arr');
        var min = schema.min, max = schema.max;
        (0, validate_1.validateMinMax)(min, max);
        this.type.validateSchema();
    };
    ArrayType.prototype.codegenValidator = function (ctx, path, r) {
        var rl = ctx.codegen.getRegister();
        var ri = ctx.codegen.getRegister();
        var rv = ctx.codegen.getRegister();
        var err = ctx.err(constants_1.ValidationError.ARR, path);
        var errLen = ctx.err(constants_1.ValidationError.ARR_LEN, path);
        var _a = this.schema, min = _a.min, max = _a.max;
        ctx.js("if (!Array.isArray(".concat(r, ")) return ").concat(err, ";"));
        ctx.js("var ".concat(rl, " = ").concat(r, ".length;"));
        if (min !== undefined)
            ctx.js("if (".concat(rl, " < ").concat(min, ") return ").concat(errLen, ";"));
        if (max !== undefined)
            ctx.js("if (".concat(rl, " > ").concat(max, ") return ").concat(errLen, ";"));
        ctx.js("for (var ".concat(rv, ", ").concat(ri, " = ").concat(r, ".length; ").concat(ri, "-- !== 0;) {"));
        ctx.js("".concat(rv, " = ").concat(r, "[").concat(ri, "];"));
        this.type.codegenValidator(ctx, tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(path), false), [{ r: ri }], false), rv);
        ctx.js("}");
        ctx.emitCustomValidators(this, path, r);
    };
    ArrayType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        ctx.writeText('[');
        var codegen = ctx.codegen;
        var r = codegen.getRegister();
        var rl = codegen.getRegister();
        var rll = codegen.getRegister();
        var ri = codegen.getRegister();
        ctx.js("var ".concat(r, " = ").concat(value.use(), ", ").concat(rl, " = ").concat(r, ".length, ").concat(rll, " = ").concat(rl, " - 1, ").concat(ri, " = 0;"));
        ctx.js("for(; ".concat(ri, " < ").concat(rll, "; ").concat(ri, "++) ") + '{');
        this.type.codegenJsonTextEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r, "[").concat(ri, "]"); }));
        ctx.js("s += ',';");
        ctx.js("}");
        ctx.js("if (".concat(rl, ") {"));
        this.type.codegenJsonTextEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r, "[").concat(rll, "]"); }));
        ctx.js("}");
        ctx.writeText(']');
    };
    ArrayType.prototype.codegenBinaryEncoder = function (ctx, value) {
        var type = this.type;
        var codegen = ctx.codegen;
        var r = codegen.getRegister();
        var rl = codegen.getRegister();
        var ri = codegen.getRegister();
        var rItem = codegen.getRegister();
        var expr = new JsExpression_1.JsExpression(function () { return "".concat(rItem); });
        ctx.js("var ".concat(r, " = ").concat(value.use(), ", ").concat(rl, " = ").concat(r, ".length, ").concat(ri, " = 0, ").concat(rItem, ";"));
        ctx.js("encoder.writeArrHdr(".concat(rl, ");"));
        ctx.js("for(; ".concat(ri, " < ").concat(rl, "; ").concat(ri, "++) ") + '{');
        ctx.js("".concat(rItem, " = ").concat(r, "[").concat(ri, "];"));
        if (ctx instanceof CborEncoderCodegenContext_1.CborEncoderCodegenContext)
            type.codegenCborEncoder(ctx, expr);
        else if (ctx instanceof MessagePackEncoderCodegenContext_1.MessagePackEncoderCodegenContext)
            type.codegenMessagePackEncoder(ctx, expr);
        else
            throw new Error('Unknown encoder');
        ctx.js("}");
    };
    ArrayType.prototype.codegenCborEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    ArrayType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    ArrayType.prototype.codegenJsonEncoder = function (ctx, value) {
        var type = this.type;
        var codegen = ctx.codegen;
        var expr = new JsExpression_1.JsExpression(function () { return "".concat(rItem); });
        var r = codegen.var(value.use());
        var rLen = codegen.var("".concat(r, ".length"));
        var rLast = codegen.var("".concat(rLen, " - 1"));
        var ri = codegen.var('0');
        var rItem = codegen.var();
        ctx.blob(ctx.gen(function (encoder) {
            encoder.writeStartArr();
        }));
        codegen.js("for(; ".concat(ri, " < ").concat(rLast, "; ").concat(ri, "++) {"));
        codegen.js("".concat(rItem, " = ").concat(r, "[").concat(ri, "];"));
        type.codegenJsonEncoder(ctx, expr);
        ctx.blob(ctx.gen(function (encoder) {
            encoder.writeArrSeparator();
        }));
        ctx.js("}");
        ctx.js("if (".concat(rLen, ") {"));
        codegen.js("".concat(rItem, " = ").concat(r, "[").concat(rLast, "];"));
        type.codegenJsonEncoder(ctx, expr);
        ctx.js("}");
        ctx.blob(ctx.gen(function (encoder) {
            encoder.writeEndArr();
        }));
    };
    ArrayType.prototype.codegenCapacityEstimator = function (ctx, value) {
        var codegen = ctx.codegen;
        ctx.inc(5);
        var rLen = codegen.var("".concat(value.use(), ".length"));
        var type = this.type;
        codegen.js("size += ".concat(1 === 1 ? "".concat(rLen) : "".concat(1, " * ").concat(rLen), ";"));
        var fn = type.compileCapacityEstimator({
            system: ctx.options.system,
            name: ctx.options.name,
        });
        var isConstantSizeType = type instanceof ConstType || type instanceof BooleanType || type instanceof NumberType;
        if (isConstantSizeType) {
            codegen.js("size += ".concat(rLen, " * ").concat(fn(null), ";"));
        }
        else {
            var r = codegen.var(value.use());
            var rFn = codegen.linkDependency(fn);
            var ri = codegen.getRegister();
            codegen.js("for(var ".concat(ri, " = ").concat(rLen, "; ").concat(ri, "-- !== 0;) size += ").concat(rFn, "(").concat(r, "[").concat(ri, "]);"));
        }
    };
    ArrayType.prototype.random = function () {
        var length = Math.round(Math.random() * 10);
        var _a = this.schema, min = _a.min, max = _a.max;
        if (min !== undefined && length < min)
            length = min + length;
        if (max !== undefined && length > max)
            length = max;
        var arr = [];
        for (var i = 0; i < length; i++)
            arr.push(this.type.random());
        return arr;
    };
    ArrayType.prototype.toTypeScriptAst = function () {
        return {
            node: 'ArrayType',
            elementType: this.type.toTypeScriptAst(),
        };
    };
    ArrayType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        var length = value.length;
        if (!length)
            return '[]';
        var last = length - 1;
        var type = this.type;
        var str = '[';
        for (var i = 0; i < last; i++)
            str += type.toJson(value[i], system) + ',';
        str += type.toJson(value[last], system);
        return (str + ']');
    };
    ArrayType.prototype.toString = function (tab) {
        var _this = this;
        if (tab === void 0) { tab = ''; }
        return _super.prototype.toString.call(this, tab) + (0, printTree_1.printTree)(tab, [function (tab) { return _this.type.toString(tab); }]);
    };
    return ArrayType;
}(AbstractType));
exports.ArrayType = ArrayType;
var TupleType = (function (_super) {
    tslib_1.__extends(TupleType, _super);
    function TupleType(types, options) {
        var _this = _super.call(this) || this;
        _this.types = types;
        _this.schema = tslib_1.__assign(tslib_1.__assign({}, schema.s.Tuple()), options);
        return _this;
    }
    TupleType.prototype.getSchema = function () {
        return tslib_1.__assign(tslib_1.__assign({}, this.schema), { types: this.types.map(function (type) { return type.getSchema(); }) });
    };
    TupleType.prototype.toJsonSchema = function (ctx) {
        var jsonSchema = tslib_1.__assign({ type: 'array', prefixItems: this.types.map(function (type) { return type.toJsonSchema(ctx); }), items: false }, _super.prototype.toJsonSchema.call(this, ctx));
        return jsonSchema;
    };
    TupleType.prototype.getOptions = function () {
        var _a = this.schema, __t = _a.__t, types = _a.types, options = tslib_1.__rest(_a, ["__t", "types"]);
        return options;
    };
    TupleType.prototype.validateSchema = function () {
        var e_1, _a;
        var schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'tup');
        var types = schema.types;
        if (!Array.isArray(types))
            throw new Error('TYPES_TYPE');
        if (!types.length)
            throw new Error('TYPES_LENGTH');
        try {
            for (var _b = tslib_1.__values(this.types), _c = _b.next(); !_c.done; _c = _b.next()) {
                var type = _c.value;
                type.validateSchema();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    TupleType.prototype.codegenValidator = function (ctx, path, r) {
        var err = ctx.err(constants_1.ValidationError.TUP, path);
        var types = this.types;
        ctx.js("if (!Array.isArray(".concat(r, ") || ").concat(r, ".length !== ").concat(types.length, ") return ").concat(err, ";"));
        for (var i = 0; i < this.types.length; i++) {
            var rv = ctx.codegen.getRegister();
            ctx.js("var ".concat(rv, " = ").concat(r, "[").concat(i, "];"));
            types[i].codegenValidator(ctx, tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(path), false), [i], false), rv);
        }
        ctx.emitCustomValidators(this, path, r);
    };
    TupleType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        ctx.writeText('[');
        var types = this.types;
        var length = types.length;
        var last = length - 1;
        var _loop_1 = function (i) {
            types[i].codegenJsonTextEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(value.use(), "[").concat(i, "]"); }));
            ctx.writeText(',');
        };
        for (var i = 0; i < last; i++) {
            _loop_1(i);
        }
        types[last].codegenJsonTextEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(value.use(), "[").concat(last, "]"); }));
        ctx.writeText(']');
    };
    TupleType.prototype.codegenBinaryEncoder = function (ctx, value) {
        var types = this.types;
        var length = types.length;
        ctx.blob(ctx.gen(function (encoder) {
            encoder.writeArrHdr(length);
        }));
        var r = ctx.codegen.r();
        ctx.js("var ".concat(r, " = ").concat(value.use(), ";"));
        var _loop_2 = function (i) {
            if (ctx instanceof CborEncoderCodegenContext_1.CborEncoderCodegenContext)
                types[i].codegenCborEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r, "[").concat(i, "]"); }));
            else
                types[i].codegenMessagePackEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r, "[").concat(i, "]"); }));
        };
        for (var i = 0; i < length; i++) {
            _loop_2(i);
        }
    };
    TupleType.prototype.codegenCborEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    TupleType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    TupleType.prototype.codegenJsonEncoder = function (ctx, value) {
        var codegen = ctx.codegen;
        var expr = new JsExpression_1.JsExpression(function () { return "".concat(rItem); });
        var r = codegen.var(value.use());
        var rItem = codegen.var();
        ctx.blob(ctx.gen(function (encoder) {
            encoder.writeStartArr();
        }));
        var types = this.types;
        var length = types.length;
        var arrSepBlob = ctx.gen(function (encoder) {
            encoder.writeArrSeparator();
        });
        for (var i = 0; i < length; i++) {
            var type = types[i];
            var isLast = i === length - 1;
            codegen.js("".concat(rItem, " = ").concat(r, "[").concat(i, "];"));
            type.codegenJsonEncoder(ctx, expr);
            if (!isLast)
                ctx.blob(arrSepBlob);
        }
        ctx.blob(ctx.gen(function (encoder) {
            encoder.writeEndArr();
        }));
    };
    TupleType.prototype.codegenCapacityEstimator = function (ctx, value) {
        var codegen = ctx.codegen;
        var r = codegen.var(value.use());
        var types = this.types;
        var overhead = 5 + 1 * types.length;
        ctx.inc(overhead);
        for (var i = 0; i < types.length; i++) {
            var type = types[i];
            var fn = type.compileCapacityEstimator({
                system: ctx.options.system,
                name: ctx.options.name,
            });
            var rFn = codegen.linkDependency(fn);
            codegen.js("size += ".concat(rFn, "(").concat(r, "[").concat(i, "]);"));
        }
    };
    TupleType.prototype.random = function () {
        return this.types.map(function (type) { return type.random(); });
    };
    TupleType.prototype.toTypeScriptAst = function () {
        return {
            node: 'TupleType',
            elements: this.types.map(function (type) { return type.toTypeScriptAst(); }),
        };
    };
    TupleType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        var types = this.types;
        var length = types.length;
        if (!length)
            return '[]';
        var last = length - 1;
        var str = '[';
        for (var i = 0; i < last; i++)
            str += types[i].toJson(value[i], system) + ',';
        str += types[last].toJson(value[last], system);
        return (str + ']');
    };
    TupleType.prototype.toString = function (tab) {
        if (tab === void 0) { tab = ''; }
        return _super.prototype.toString.call(this, tab) + (0, printTree_1.printTree)(tab, tslib_1.__spreadArray([], tslib_1.__read(this.types.map(function (type) { return function (tab) { return type.toString(tab); }; })), false));
    };
    return TupleType;
}(AbstractType));
exports.TupleType = TupleType;
var ObjectFieldType = (function (_super) {
    tslib_1.__extends(ObjectFieldType, _super);
    function ObjectFieldType(key, value) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.value = value;
        _this.schema = schema.s.prop(key, schema.s.any);
        return _this;
    }
    ObjectFieldType.prototype.getSchema = function () {
        return tslib_1.__assign(tslib_1.__assign({}, this.schema), { type: this.value.getSchema() });
    };
    ObjectFieldType.prototype.getOptions = function () {
        var _a = this.schema, __t = _a.__t, key = _a.key, type = _a.type, optional = _a.optional, options = tslib_1.__rest(_a, ["__t", "key", "type", "optional"]);
        return options;
    };
    ObjectFieldType.prototype.validateSchema = function () {
        var schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'field');
        var key = schema.key, optional = schema.optional;
        if (typeof key !== 'string')
            throw new Error('KEY_TYPE');
        if (optional !== undefined && typeof optional !== 'boolean')
            throw new Error('OPTIONAL_TYPE');
        this.value.validateSchema();
    };
    ObjectFieldType.prototype.toStringTitle = function () {
        return "\"".concat(this.key, "\":");
    };
    ObjectFieldType.prototype.toString = function (tab) {
        var _this = this;
        if (tab === void 0) { tab = ''; }
        return _super.prototype.toString.call(this, tab) + (0, printTree_1.printTree)(tab + ' ', [function (tab) { return _this.value.toString(tab); }]);
    };
    return ObjectFieldType;
}(AbstractType));
exports.ObjectFieldType = ObjectFieldType;
var ObjectOptionalFieldType = (function (_super) {
    tslib_1.__extends(ObjectOptionalFieldType, _super);
    function ObjectOptionalFieldType(key, value) {
        var _this = _super.call(this, key, value) || this;
        _this.key = key;
        _this.value = value;
        _this.optional = true;
        _this.schema = schema.s.propOpt(key, schema.s.any);
        return _this;
    }
    ObjectOptionalFieldType.prototype.toStringTitle = function () {
        return "\"".concat(this.key, "\"?:");
    };
    return ObjectOptionalFieldType;
}(ObjectFieldType));
exports.ObjectOptionalFieldType = ObjectOptionalFieldType;
var ObjectType = (function (_super) {
    tslib_1.__extends(ObjectType, _super);
    function ObjectType(fields) {
        var _this = _super.call(this) || this;
        _this.fields = fields;
        _this.schema = schema.s.obj;
        return _this;
    }
    ObjectType.prototype.getSchema = function () {
        return tslib_1.__assign(tslib_1.__assign({}, this.schema), { fields: this.fields.map(function (f) { return f.getSchema(); }) });
    };
    ObjectType.prototype.toJsonSchema = function (ctx) {
        var e_2, _a;
        var jsonSchema = tslib_1.__assign({ type: 'object', properties: {} }, _super.prototype.toJsonSchema.call(this, ctx));
        var required = [];
        try {
            for (var _b = tslib_1.__values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
                var field = _c.value;
                jsonSchema.properties[field.key] = field.value.toJsonSchema(ctx);
                if (!(field instanceof ObjectOptionalFieldType))
                    required.push(field.key);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (required.length)
            jsonSchema.required = required;
        if (this.schema.unknownFields === false)
            jsonSchema.additionalProperties = false;
        return jsonSchema;
    };
    ObjectType.prototype.getOptions = function () {
        var _a = this.schema, __t = _a.__t, fields = _a.fields, options = tslib_1.__rest(_a, ["__t", "fields"]);
        return options;
    };
    ObjectType.prototype.getField = function (key) {
        return this.fields.find(function (f) { return f.key === key; });
    };
    ObjectType.prototype.validateSchema = function () {
        var e_3, _a;
        var schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'obj');
        (0, validate_1.validateWithValidator)(schema);
        var fields = schema.fields, unknownFields = schema.unknownFields;
        if (!Array.isArray(fields))
            throw new Error('FIELDS_TYPE');
        if (unknownFields !== undefined && typeof unknownFields !== 'boolean')
            throw new Error('UNKNOWN_FIELDS_TYPE');
        try {
            for (var _b = tslib_1.__values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
                var field = _c.value;
                field.validateSchema();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    ObjectType.prototype.codegenValidator = function (ctx, path, r) {
        var fields = this.fields;
        var length = fields.length;
        var canSkipObjectTypeCheck = ctx.options.unsafeMode && length > 0;
        if (!canSkipObjectTypeCheck) {
            var err = ctx.err(constants_1.ValidationError.OBJ, path);
            ctx.js("if (typeof ".concat(r, " !== 'object' || !").concat(r, " || (").concat(r, " instanceof Array)) return ").concat(err, ";"));
        }
        var checkExtraKeys = length && !this.schema.unknownFields && !ctx.options.skipObjectExtraFieldsCheck;
        if (checkExtraKeys) {
            var rk = ctx.codegen.getRegister();
            ctx.js("for (var ".concat(rk, " in ").concat(r, ") {"));
            ctx.js("switch (".concat(rk, ") { case ").concat(fields
                .map(function (field) { return JSON.stringify(field.key); })
                .join(': case '), ": break; default: return ").concat(ctx.err(constants_1.ValidationError.KEYS, tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(path), false), [{ r: rk }], false)), ";}"));
            ctx.js("}");
        }
        for (var i = 0; i < length; i++) {
            var field = fields[i];
            var rv = ctx.codegen.getRegister();
            var accessor = (0, normalizeAccessor_1.normalizeAccessor)(field.key);
            var keyPath = tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(path), false), [field.key], false);
            if (field instanceof ObjectOptionalFieldType) {
                ctx.js("var ".concat(rv, " = ").concat(r).concat(accessor, ";"));
                ctx.js("if (".concat(rv, " !== undefined) {"));
                field.value.codegenValidator(ctx, keyPath, rv);
                ctx.js("}");
            }
            else {
                ctx.js("var ".concat(rv, " = ").concat(r).concat(accessor, ";"));
                if (!(0, util_2.canSkipObjectKeyUndefinedCheck)(field.value.getSchema().__t)) {
                    var err = ctx.err(constants_1.ValidationError.KEY, tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(path), false), [field.key], false));
                    ctx.js("if (".concat(rv, " === undefined) return ").concat(err, ";"));
                }
                field.value.codegenValidator(ctx, keyPath, "".concat(r).concat(accessor));
            }
        }
        ctx.emitCustomValidators(this, path, r);
    };
    ObjectType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        var _a = this, schema = _a.schema, fields = _a.fields;
        var codegen = ctx.codegen;
        var r = codegen.getRegister();
        ctx.js("var ".concat(r, " = ").concat(value.use(), ";"));
        var rKeys = ctx.codegen.getRegister();
        if (schema.encodeUnknownFields) {
            ctx.js("var ".concat(rKeys, " = new Set(Object.keys(").concat(r, "));"));
        }
        var requiredFields = fields.filter(function (field) { return !(field instanceof ObjectOptionalFieldType); });
        var optionalFields = fields.filter(function (field) { return field instanceof ObjectOptionalFieldType; });
        ctx.writeText('{');
        var _loop_3 = function (i) {
            var field = requiredFields[i];
            if (i)
                ctx.writeText(',');
            ctx.writeText(JSON.stringify(field.key) + ':');
            var accessor = (0, normalizeAccessor_1.normalizeAccessor)(field.key);
            var valueExpression = new JsExpression_1.JsExpression(function () { return "".concat(r).concat(accessor); });
            if (schema.encodeUnknownFields)
                ctx.js("".concat(rKeys, ".delete(").concat(JSON.stringify(field.key), ");"));
            field.value.codegenJsonTextEncoder(ctx, valueExpression);
        };
        for (var i = 0; i < requiredFields.length; i++) {
            _loop_3(i);
        }
        var rHasFields = codegen.getRegister();
        if (!requiredFields.length)
            ctx.js("var ".concat(rHasFields, " = false;"));
        var _loop_4 = function (i) {
            var field = optionalFields[i];
            var accessor = (0, normalizeAccessor_1.normalizeAccessor)(field.key);
            var rValue = codegen.getRegister();
            if (schema.encodeUnknownFields)
                ctx.js("".concat(rKeys, ".delete(").concat(JSON.stringify(field.key), ");"));
            ctx.js("var ".concat(rValue, " = ").concat(r).concat(accessor, ";"));
            ctx.js("if (".concat(rValue, " !== undefined) {"));
            if (requiredFields.length) {
                ctx.writeText(',');
            }
            else {
                ctx.js("if (".concat(rHasFields, ") s += ',';"));
                ctx.js("".concat(rHasFields, " = true;"));
            }
            ctx.writeText(JSON.stringify(field.key) + ':');
            var valueExpression = new JsExpression_1.JsExpression(function () { return "".concat(rValue); });
            field.value.codegenJsonTextEncoder(ctx, valueExpression);
            ctx.js("}");
        };
        for (var i = 0; i < optionalFields.length; i++) {
            _loop_4(i);
        }
        if (schema.encodeUnknownFields) {
            var _b = tslib_1.__read([codegen.r(), codegen.r(), codegen.r(), codegen.r()], 4), rList = _b[0], ri = _b[1], rLength = _b[2], rk = _b[3];
            ctx.js("var ".concat(rLength, " = ").concat(rKeys, ".size;\nif (").concat(rLength, ") {\n  var ").concat(rk, ", ").concat(rList, " = Array.from(").concat(rKeys, ".values());\n  for (var ").concat(ri, " = 0; ").concat(ri, " < ").concat(rLength, "; ").concat(ri, "++) {\n    ").concat(rk, " = ").concat(rList, "[").concat(ri, "];\n    s += ',' + asString(").concat(rk, ") + ':' + stringify(").concat(r, "[").concat(rk, "]);\n  }\n}"));
        }
        ctx.writeText('}');
    };
    ObjectType.prototype.codegenCborEncoder = function (ctx, value) {
        var codegen = ctx.codegen;
        var r = codegen.r();
        var fields = this.fields;
        var length = fields.length;
        var requiredFields = fields.filter(function (field) { return !(field instanceof ObjectOptionalFieldType); });
        var optionalFields = fields.filter(function (field) { return field instanceof ObjectOptionalFieldType; });
        var requiredLength = requiredFields.length;
        var optionalLength = optionalFields.length;
        var encodeUnknownFields = !!this.schema.encodeUnknownFields;
        var emitRequiredFields = function () {
            var _loop_5 = function (i) {
                var field = requiredFields[i];
                ctx.blob(ctx.gen(function (encoder) { return encoder.writeStr(field.key); }));
                var accessor = (0, normalizeAccessor_1.normalizeAccessor)(field.key);
                field.value.codegenCborEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r).concat(accessor); }));
            };
            for (var i = 0; i < requiredLength; i++) {
                _loop_5(i);
            }
        };
        var emitOptionalFields = function () {
            var _loop_6 = function (i) {
                var field = optionalFields[i];
                var accessor = (0, normalizeAccessor_1.normalizeAccessor)(field.key);
                codegen.js("if (".concat(r).concat(accessor, " !== undefined) {"));
                ctx.blob(ctx.gen(function (encoder) { return encoder.writeStr(field.key); }));
                field.value.codegenCborEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r).concat(accessor); }));
                codegen.js("}");
            };
            for (var i = 0; i < optionalLength; i++) {
                _loop_6(i);
            }
        };
        var emitUnknownFields = function () {
            var rKeys = codegen.r();
            var rKey = codegen.r();
            var ri = codegen.r();
            var rLength = codegen.r();
            var keys = fields.map(function (field) { return JSON.stringify(field.key); });
            var rKnownFields = codegen.addConstant("new Set([".concat(keys.join(','), "])"));
            codegen.js("var ".concat(rKeys, " = Object.keys(").concat(r, "), ").concat(rLength, " = ").concat(rKeys, ".length, ").concat(rKey, ";"));
            codegen.js("for (var ".concat(ri, " = 0; ").concat(ri, " < ").concat(rLength, "; ").concat(ri, "++) {"));
            codegen.js("".concat(rKey, " = ").concat(rKeys, "[").concat(ri, "];"));
            codegen.js("if (".concat(rKnownFields, ".has(").concat(rKey, ")) continue;"));
            codegen.js("encoder.writeStr(".concat(rKey, ");"));
            codegen.js("encoder.writeAny(".concat(r, "[").concat(rKey, "]);"));
            codegen.js("}");
        };
        ctx.js("var ".concat(r, " = ").concat(value.use(), ";"));
        if (!encodeUnknownFields && !optionalLength) {
            ctx.blob(ctx.gen(function (encoder) { return encoder.writeObjHdr(length); }));
            emitRequiredFields();
        }
        else if (!encodeUnknownFields) {
            ctx.blob(ctx.gen(function (encoder) { return encoder.writeStartObj(); }));
            emitRequiredFields();
            emitOptionalFields();
            ctx.blob(ctx.gen(function (encoder) { return encoder.writeEndObj(); }));
        }
        else {
            ctx.blob(ctx.gen(function (encoder) { return encoder.writeStartObj(); }));
            emitRequiredFields();
            emitOptionalFields();
            emitUnknownFields();
            ctx.blob(ctx.gen(function (encoder) { return encoder.writeEndObj(); }));
        }
    };
    ObjectType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        var codegen = ctx.codegen;
        var r = codegen.r();
        var fields = this.fields;
        var length = fields.length;
        var requiredFields = fields.filter(function (field) { return !(field instanceof ObjectOptionalFieldType); });
        var optionalFields = fields.filter(function (field) { return field instanceof ObjectOptionalFieldType; });
        var requiredLength = requiredFields.length;
        var optionalLength = optionalFields.length;
        var totalMaxKnownFields = requiredLength + optionalLength;
        if (totalMaxKnownFields > 0xffff)
            throw new Error('Too many fields');
        var encodeUnknownFields = !!this.schema.encodeUnknownFields;
        var rFieldCount = codegen.r();
        var emitRequiredFields = function () {
            var _loop_7 = function (i) {
                var field = requiredFields[i];
                ctx.blob(ctx.gen(function (encoder) { return encoder.writeStr(field.key); }));
                var accessor = (0, normalizeAccessor_1.normalizeAccessor)(field.key);
                field.value.codegenMessagePackEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r).concat(accessor); }));
            };
            for (var i = 0; i < requiredLength; i++) {
                _loop_7(i);
            }
        };
        var emitOptionalFields = function () {
            var _loop_8 = function (i) {
                var field = optionalFields[i];
                var accessor = (0, normalizeAccessor_1.normalizeAccessor)(field.key);
                codegen.if("".concat(r).concat(accessor, " !== undefined"), function () {
                    codegen.js("".concat(rFieldCount, "++;"));
                    ctx.blob(ctx.gen(function (encoder) { return encoder.writeStr(field.key); }));
                    field.value.codegenMessagePackEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r).concat(accessor); }));
                });
            };
            for (var i = 0; i < optionalLength; i++) {
                _loop_8(i);
            }
        };
        var emitUnknownFields = function () {
            var ri = codegen.r();
            var rKeys = codegen.r();
            var rKey = codegen.r();
            var rLength = codegen.r();
            var keys = fields.map(function (field) { return JSON.stringify(field.key); });
            var rKnownFields = codegen.addConstant("new Set([".concat(keys.join(','), "])"));
            codegen.js("var ".concat(rKeys, " = Object.keys(").concat(r, "), ").concat(rLength, " = ").concat(rKeys, ".length, ").concat(rKey, ";"));
            codegen.js("for (var ".concat(ri, " = 0; ").concat(ri, " < ").concat(rLength, "; ").concat(ri, "++) {"));
            codegen.js("".concat(rKey, " = ").concat(rKeys, "[").concat(ri, "];"));
            codegen.js("if (".concat(rKnownFields, ".has(").concat(rKey, ")) continue;"));
            codegen.js("".concat(rFieldCount, "++;"));
            codegen.js("encoder.writeStr(".concat(rKey, ");"));
            codegen.js("encoder.writeAny(".concat(r, "[").concat(rKey, "]);"));
            codegen.js("}");
        };
        ctx.js("var ".concat(r, " = ").concat(value.use(), ";"));
        if (!encodeUnknownFields && !optionalLength) {
            ctx.blob(ctx.gen(function (encoder) { return encoder.writeObjHdr(length); }));
            emitRequiredFields();
        }
        else if (!encodeUnknownFields) {
            codegen.js("var ".concat(rFieldCount, " = ").concat(requiredLength, ";"));
            var rHeaderPosition = codegen.var('writer.x');
            ctx.blob(ctx.gen(function (encoder) { return encoder.writeObjHdr(0xffff); }));
            emitRequiredFields();
            emitOptionalFields();
            codegen.js("view.setUint16(".concat(rHeaderPosition, " + 1, ").concat(rFieldCount, ");"));
        }
        else {
            codegen.js("var ".concat(rFieldCount, " = ").concat(requiredLength, ";"));
            var rHeaderPosition = codegen.var('writer.x');
            ctx.blob(ctx.gen(function (encoder) { return encoder.writeObjHdr(0xffffffff); }));
            emitRequiredFields();
            emitOptionalFields();
            emitUnknownFields();
            codegen.js("view.setUint32(".concat(rHeaderPosition, " + 1, ").concat(rFieldCount, ");"));
        }
    };
    ObjectType.prototype.codegenJsonEncoder = function (ctx, value) {
        var codegen = ctx.codegen;
        var r = codegen.var(value.use());
        var fields = this.fields;
        var requiredFields = fields.filter(function (field) { return !(field instanceof ObjectOptionalFieldType); });
        var optionalFields = fields.filter(function (field) { return field instanceof ObjectOptionalFieldType; });
        var requiredLength = requiredFields.length;
        var optionalLength = optionalFields.length;
        var encodeUnknownFields = !!this.schema.encodeUnknownFields;
        var separatorBlob = ctx.gen(function (encoder) { return encoder.writeObjSeparator(); });
        var keySeparatorBlob = ctx.gen(function (encoder) { return encoder.writeObjKeySeparator(); });
        var endBlob = ctx.gen(function (encoder) { return encoder.writeEndObj(); });
        var emitRequiredFields = function () {
            var _loop_9 = function (i) {
                var field = requiredFields[i];
                ctx.blob(ctx.gen(function (encoder) {
                    encoder.writeStr(field.key);
                    encoder.writeObjKeySeparator();
                }));
                var accessor = (0, normalizeAccessor_1.normalizeAccessor)(field.key);
                field.value.codegenJsonEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r).concat(accessor); }));
                ctx.blob(separatorBlob);
            };
            for (var i = 0; i < requiredLength; i++) {
                _loop_9(i);
            }
        };
        var emitOptionalFields = function () {
            var _loop_10 = function (i) {
                var field = optionalFields[i];
                var accessor = (0, normalizeAccessor_1.normalizeAccessor)(field.key);
                codegen.if("".concat(r).concat(accessor, " !== undefined"), function () {
                    ctx.blob(ctx.gen(function (encoder) {
                        encoder.writeStr(field.key);
                    }));
                    ctx.blob(keySeparatorBlob);
                    field.value.codegenJsonEncoder(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r).concat(accessor); }));
                    ctx.blob(separatorBlob);
                });
            };
            for (var i = 0; i < optionalLength; i++) {
                _loop_10(i);
            }
        };
        var emitUnknownFields = function () {
            var rKeys = codegen.r();
            var rKey = codegen.r();
            var ri = codegen.r();
            var rLength = codegen.r();
            var keys = fields.map(function (field) { return JSON.stringify(field.key); });
            var rKnownFields = codegen.addConstant("new Set([".concat(keys.join(','), "])"));
            codegen.js("var ".concat(rKeys, " = Object.keys(").concat(r, "), ").concat(rLength, " = ").concat(rKeys, ".length, ").concat(rKey, ";"));
            codegen.js("for (var ".concat(ri, " = 0; ").concat(ri, " < ").concat(rLength, "; ").concat(ri, "++) {"));
            codegen.js("".concat(rKey, " = ").concat(rKeys, "[").concat(ri, "];"));
            codegen.js("if (".concat(rKnownFields, ".has(").concat(rKey, ")) continue;"));
            codegen.js("encoder.writeStr(".concat(rKey, ");"));
            ctx.blob(keySeparatorBlob);
            codegen.js("encoder.writeAny(".concat(r, "[").concat(rKey, "]);"));
            ctx.blob(separatorBlob);
            codegen.js("}");
        };
        var emitEnding = function () {
            var rewriteLastSeparator = function () {
                for (var i = 0; i < endBlob.length; i++)
                    ctx.js("uint8[writer.x - ".concat(endBlob.length - i, "] = ").concat(endBlob[i], ";"));
            };
            if (requiredFields.length) {
                rewriteLastSeparator();
            }
            else {
                codegen.if("uint8[writer.x - 1] === ".concat(separatorBlob[separatorBlob.length - 1]), function () {
                    rewriteLastSeparator();
                }, function () {
                    ctx.blob(endBlob);
                });
            }
        };
        ctx.blob(ctx.gen(function (encoder) {
            encoder.writeStartObj();
        }));
        if (!encodeUnknownFields && !optionalLength) {
            emitRequiredFields();
            emitEnding();
        }
        else if (!encodeUnknownFields) {
            emitRequiredFields();
            emitOptionalFields();
            emitEnding();
        }
        else {
            emitRequiredFields();
            emitOptionalFields();
            emitUnknownFields();
            emitEnding();
        }
    };
    ObjectType.prototype.codegenCapacityEstimator = function (ctx, value) {
        var e_4, _a;
        var codegen = ctx.codegen;
        var r = codegen.var(value.use());
        var encodeUnknownFields = !!this.schema.encodeUnknownFields;
        if (encodeUnknownFields) {
            codegen.js("size += maxEncodingCapacity(".concat(r, ");"));
            return;
        }
        var fields = this.fields;
        var overhead = 5 + fields.length * 2;
        ctx.inc(overhead);
        var _loop_11 = function (field) {
            ctx.inc((0, json_size_1.maxEncodingCapacity)(field.key));
            var accessor = (0, normalizeAccessor_1.normalizeAccessor)(field.key);
            var isOptional = field instanceof ObjectOptionalFieldType;
            var block = function () { return field.value.codegenCapacityEstimator(ctx, new JsExpression_1.JsExpression(function () { return "".concat(r).concat(accessor); })); };
            if (isOptional) {
                codegen.if("".concat(r).concat(accessor, " !== undefined"), block);
            }
            else
                block();
        };
        try {
            for (var fields_1 = tslib_1.__values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
                var field = fields_1_1.value;
                _loop_11(field);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    ObjectType.prototype.random = function () {
        var e_5, _a;
        var schema = this.schema;
        var obj = schema.unknownFields ? json_random_1.RandomJson.genObject() : {};
        try {
            for (var _b = tslib_1.__values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
                var field = _c.value;
                if (field instanceof ObjectOptionalFieldType)
                    if (Math.random() > 0.5)
                        continue;
                obj[field.key] = field.value.random();
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return obj;
    };
    ObjectType.prototype.toTypeScriptAst = function () {
        var e_6, _a;
        var node = {
            node: 'TypeLiteral',
            members: [],
        };
        var fields = this.fields;
        try {
            for (var fields_2 = tslib_1.__values(fields), fields_2_1 = fields_2.next(); !fields_2_1.done; fields_2_1 = fields_2.next()) {
                var field = fields_2_1.value;
                var member = {
                    node: 'PropertySignature',
                    name: field.key,
                    type: field.value.toTypeScriptAst(),
                };
                if (field instanceof ObjectOptionalFieldType)
                    member.optional = true;
                augmentWithComment(field.getSchema(), member);
                node.members.push(member);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (fields_2_1 && !fields_2_1.done && (_a = fields_2.return)) _a.call(fields_2);
            }
            finally { if (e_6) throw e_6.error; }
        }
        if (this.schema.unknownFields || this.schema.encodeUnknownFields)
            node.members.push({
                node: 'IndexSignature',
                type: { node: 'UnknownKeyword' },
            });
        augmentWithComment(this.schema, node);
        return node;
    };
    ObjectType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        var fields = this.fields;
        var length = fields.length;
        if (!length)
            return '{}';
        var last = length - 1;
        var str = '{';
        for (var i = 0; i < last; i++) {
            var field = fields[i];
            var key_1 = field.key;
            var fieldType = field.value;
            var val_1 = value[key_1];
            if (val_1 === undefined)
                continue;
            str += (0, asString_1.asString)(key_1) + ':' + fieldType.toJson(val_1, system) + ',';
        }
        var key = fields[last].key;
        var val = value[key];
        if (val !== undefined) {
            str += (0, asString_1.asString)(key) + ':' + fields[last].value.toJson(val, system);
        }
        else if (str.length > 1)
            str = str.slice(0, -1);
        return (str + '}');
    };
    ObjectType.prototype.toString = function (tab) {
        if (tab === void 0) { tab = ''; }
        var _a = this.getSchema(), __t = _a.__t, fields = _a.fields, rest = tslib_1.__rest(_a, ["__t", "fields"]);
        return (_super.prototype.toString.call(this, tab) +
            (0, printTree_1.printTree)(tab, this.fields.map(function (field) { return function (tab) { return field.toString(tab); }; })));
    };
    return ObjectType;
}(AbstractType));
exports.ObjectType = ObjectType;
var RefType = (function (_super) {
    tslib_1.__extends(RefType, _super);
    function RefType(ref) {
        var _this = _super.call(this) || this;
        _this.schema = schema.s.Ref(ref);
        return _this;
    }
    RefType.prototype.getRef = function () {
        return this.schema.ref;
    };
    RefType.prototype.toJsonSchema = function (ctx) {
        var ref = this.schema.ref;
        if (ctx)
            ctx.mentionRef(ref);
        var jsonSchema = tslib_1.__assign({ $ref: "#/$defs/".concat(ref) }, _super.prototype.toJsonSchema.call(this, ctx));
        return jsonSchema;
    };
    RefType.prototype.getOptions = function () {
        var _a = this.schema, __t = _a.__t, ref = _a.ref, options = tslib_1.__rest(_a, ["__t", "ref"]);
        return options;
    };
    RefType.prototype.validateSchema = function () {
        var schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'ref');
        var ref = schema.ref;
        if (typeof ref !== 'string')
            throw new Error('REF_TYPE');
        if (!ref)
            throw new Error('REF_EMPTY');
    };
    RefType.prototype.codegenValidator = function (ctx, path, r) {
        var _this = this;
        var refErr = function (errorRegister) {
            switch (ctx.options.errors) {
                case 'boolean':
                    return errorRegister;
                case 'string': {
                    return ctx.err(constants_1.ValidationError.REF, tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(path), false), [{ r: errorRegister }], false));
                }
                case 'object':
                default: {
                    return ctx.err(constants_1.ValidationError.REF, tslib_1.__spreadArray([], tslib_1.__read(path), false), { refId: _this.schema.ref, refError: errorRegister });
                }
            }
        };
        var system = ctx.options.system || this.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        var validator = system.resolve(this.schema.ref).type.validator(ctx.options.errors);
        var d = ctx.codegen.linkDependency(validator);
        var rerr = ctx.codegen.getRegister();
        ctx.js("var ".concat(rerr, " = ").concat(d, "(").concat(r, ");"));
        ctx.js("if (".concat(rerr, ") return ").concat(refErr(rerr), ";"));
    };
    RefType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        var system = ctx.options.system || this.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        var encoder = system.resolve(this.schema.ref).type.jsonTextEncoder();
        var d = ctx.codegen.linkDependency(encoder);
        ctx.js("s += ".concat(d, "(").concat(value.use(), ");"));
    };
    RefType.prototype.codegenBinaryEncoder = function (ctx, value) {
        var system = ctx.options.system || this.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        var kind = ctx instanceof CborEncoderCodegenContext_1.CborEncoderCodegenContext
            ? 0
            : ctx instanceof MessagePackEncoderCodegenContext_1.MessagePackEncoderCodegenContext
                ? 1
                : 2;
        var targetType = system.resolve(this.schema.ref).type;
        switch (targetType.getTypeName()) {
            case 'str':
            case 'bool':
            case 'num':
            case 'any':
            case 'tup': {
                if (ctx instanceof CborEncoderCodegenContext_1.CborEncoderCodegenContext)
                    targetType.codegenCborEncoder(ctx, value);
                else if (ctx instanceof MessagePackEncoderCodegenContext_1.MessagePackEncoderCodegenContext)
                    targetType.codegenMessagePackEncoder(ctx, value);
                else if (ctx instanceof JsonEncoderCodegenContext_1.JsonEncoderCodegenContext)
                    targetType.codegenJsonEncoder(ctx, value);
                break;
            }
            default: {
                var encoder = targetType.encoder(kind);
                var d = ctx.codegen.linkDependency(encoder);
                ctx.js("".concat(d, "(").concat(value.use(), ", encoder);"));
            }
        }
    };
    RefType.prototype.codegenCborEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    RefType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    RefType.prototype.codegenJsonEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    RefType.prototype.codegenCapacityEstimator = function (ctx, value) {
        var system = ctx.options.system || this.system;
        if (!system)
            throw new Error('NO_SYSTEM');
        var estimator = system.resolve(this.schema.ref).type.capacityEstimator();
        var d = ctx.codegen.linkDependency(estimator);
        ctx.codegen.js("size += ".concat(d, "(").concat(value.use(), ");"));
    };
    RefType.prototype.random = function () {
        if (!this.system)
            throw new Error('NO_SYSTEM');
        var alias = this.system.resolve(this.schema.ref);
        return alias.type.random();
    };
    RefType.prototype.toTypeScriptAst = function () {
        return {
            node: 'GenericTypeAnnotation',
            id: {
                node: 'Identifier',
                name: this.schema.ref,
            },
        };
    };
    RefType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        if (!system)
            return 'null';
        var alias = system.resolve(this.schema.ref);
        return alias.type.toJson(value, system);
    };
    RefType.prototype.toStringTitle = function (tab) {
        if (tab === void 0) { tab = ''; }
        var options = this.toStringOptions();
        return "".concat(_super.prototype.toStringTitle.call(this), " \u2192 [").concat(this.schema.ref, "]") + (options ? " ".concat(options) : '');
    };
    return RefType;
}(AbstractType));
exports.RefType = RefType;
var OrType = (function (_super) {
    tslib_1.__extends(OrType, _super);
    function OrType(types, options) {
        var _this = _super.call(this) || this;
        _this.types = types;
        _this.__discriminator = undefined;
        _this.schema = tslib_1.__assign(tslib_1.__assign({}, schema.s.Or()), options);
        return _this;
    }
    OrType.prototype.getSchema = function () {
        return tslib_1.__assign(tslib_1.__assign({}, this.schema), { types: this.types.map(function (type) { return type.getSchema(); }) });
    };
    OrType.prototype.toJsonSchema = function (ctx) {
        return {
            anyOf: this.types.map(function (type) { return type.toJsonSchema(ctx); }),
        };
    };
    OrType.prototype.getOptions = function () {
        var _a = this.schema, __t = _a.__t, types = _a.types, options = tslib_1.__rest(_a, ["__t", "types"]);
        return options;
    };
    OrType.prototype.options = function (options) {
        Object.assign(this.schema, options);
        return this;
    };
    OrType.prototype.discriminator = function () {
        if (this.__discriminator)
            return this.__discriminator;
        var expr = this.schema.discriminator;
        if (!expr || (expr[0] === 'num' && expr[1] === 0))
            throw new Error('NO_DISCRIMINATOR');
        var codegen = new json_expression_1.JsonExpressionCodegen({
            expression: expr,
        });
        var fn = codegen.run().compile();
        return (this.__discriminator = function (data) { return +fn({ data: data }); });
    };
    OrType.prototype.validateSchema = function () {
        var e_7, _a;
        var schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'or');
        var types = schema.types, discriminator = schema.discriminator;
        if (!discriminator || (discriminator[0] === 'num' && discriminator[1] === -1))
            throw new Error('DISCRIMINATOR');
        if (!Array.isArray(types))
            throw new Error('TYPES_TYPE');
        if (!types.length)
            throw new Error('TYPES_LENGTH');
        try {
            for (var _b = tslib_1.__values(this.types), _c = _b.next(); !_c.done; _c = _b.next()) {
                var type = _c.value;
                type.validateSchema();
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    OrType.prototype.codegenValidator = function (ctx, path, r) {
        var types = this.types;
        var codegen = ctx.codegen;
        var length = types.length;
        if (length === 1) {
            types[0].codegenValidator(ctx, path, r);
            return;
        }
        var discriminator = this.discriminator();
        var d = codegen.linkDependency(discriminator);
        codegen.switch("".concat(d, "(").concat(r, ")"), types.map(function (type, index) { return [
            index,
            function () {
                type.codegenValidator(ctx, path, r);
            },
        ]; }), function () {
            var err = ctx.err(constants_1.ValidationError.OR, path);
            ctx.js("return ".concat(err));
        });
    };
    OrType.prototype.codegenJsonTextEncoder = function (ctx, value) {
        ctx.js("s += stringify(".concat(value.use(), ");"));
    };
    OrType.prototype.codegenBinaryEncoder = function (ctx, value) {
        var codegen = ctx.codegen;
        var discriminator = this.discriminator();
        var d = codegen.linkDependency(discriminator);
        var types = this.types;
        codegen.switch("".concat(d, "(").concat(value.use(), ")"), types.map(function (type, index) { return [
            index,
            function () {
                if (ctx instanceof CborEncoderCodegenContext_1.CborEncoderCodegenContext)
                    type.codegenCborEncoder(ctx, value);
                else if (ctx instanceof MessagePackEncoderCodegenContext_1.MessagePackEncoderCodegenContext)
                    type.codegenMessagePackEncoder(ctx, value);
                else if (ctx instanceof JsonEncoderCodegenContext_1.JsonEncoderCodegenContext)
                    type.codegenJsonEncoder(ctx, value);
            },
        ]; }));
    };
    OrType.prototype.codegenCborEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    OrType.prototype.codegenMessagePackEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    OrType.prototype.codegenJsonEncoder = function (ctx, value) {
        this.codegenBinaryEncoder(ctx, value);
    };
    OrType.prototype.codegenCapacityEstimator = function (ctx, value) {
        var codegen = ctx.codegen;
        var discriminator = this.discriminator();
        var d = codegen.linkDependency(discriminator);
        var types = this.types;
        codegen.switch("".concat(d, "(").concat(value.use(), ")"), types.map(function (type, index) { return [
            index,
            function () {
                type.codegenCapacityEstimator(ctx, value);
            },
        ]; }));
    };
    OrType.prototype.random = function () {
        var types = this.types;
        var index = Math.floor(Math.random() * types.length);
        return types[index].random();
    };
    OrType.prototype.toTypeScriptAst = function () {
        var node = {
            node: 'UnionType',
            types: this.types.map(function (t) { return t.toTypeScriptAst(); }),
        };
        return node;
    };
    OrType.prototype.toJson = function (value, system) {
        if (system === void 0) { system = this.system; }
        return JSON.stringify(value);
    };
    OrType.prototype.toString = function (tab) {
        if (tab === void 0) { tab = ''; }
        return _super.prototype.toString.call(this, tab) + (0, printTree_1.printTree)(tab, tslib_1.__spreadArray([], tslib_1.__read(this.types.map(function (type) { return function (tab) { return type.toString(tab); }; })), false));
    };
    return OrType;
}(AbstractType));
exports.OrType = OrType;
var FunctionType = (function (_super) {
    tslib_1.__extends(FunctionType, _super);
    function FunctionType(req, res, options) {
        var _this = _super.call(this) || this;
        _this.req = req;
        _this.res = res;
        _this.schema = tslib_1.__assign(tslib_1.__assign({}, options), schema.s.Function(schema.s.any, schema.s.any));
        return _this;
    }
    FunctionType.prototype.getSchema = function () {
        return tslib_1.__assign(tslib_1.__assign({}, this.schema), { req: this.req.getSchema(), res: this.res.getSchema() });
    };
    FunctionType.prototype.validateSchema = function () {
        var schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'fn');
        this.req.validateSchema();
        this.res.validateSchema();
    };
    FunctionType.prototype.random = function () {
        var _this = this;
        return function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
            return [2, this.res.random()];
        }); }); };
    };
    FunctionType.prototype.toTypeScriptAst = function () {
        throw new Error('Method not implemented.');
    };
    FunctionType.prototype.toString = function (tab) {
        var _this = this;
        if (tab === void 0) { tab = ''; }
        return (_super.prototype.toString.call(this, tab) +
            (0, printTree_1.printTree)(tab, [function (tab) { return 'req: ' + _this.req.toString(tab); }, function (tab) { return 'res: ' + _this.res.toString(tab); }]));
    };
    return FunctionType;
}(AbstractType));
exports.FunctionType = FunctionType;
var FunctionStreamingType = (function (_super) {
    tslib_1.__extends(FunctionStreamingType, _super);
    function FunctionStreamingType(req, res, options) {
        var _this = _super.call(this) || this;
        _this.req = req;
        _this.res = res;
        _this.isStreaming = true;
        _this.schema = tslib_1.__assign(tslib_1.__assign({}, options), schema.s.Function$(schema.s.any, schema.s.any));
        return _this;
    }
    FunctionStreamingType.prototype.getSchema = function () {
        return tslib_1.__assign(tslib_1.__assign({}, this.schema), { req: this.req.getSchema(), res: this.res.getSchema() });
    };
    FunctionStreamingType.prototype.validateSchema = function () {
        var schema = this.getSchema();
        (0, validate_1.validateTType)(schema, 'fn$');
        this.req.validateSchema();
        this.res.validateSchema();
    };
    FunctionStreamingType.prototype.random = function () {
        var _this = this;
        return function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
            return [2, this.res.random()];
        }); }); };
    };
    FunctionStreamingType.prototype.toTypeScriptAst = function () {
        throw new Error('Method not implemented.');
    };
    FunctionStreamingType.prototype.toString = function (tab) {
        var _this = this;
        if (tab === void 0) { tab = ''; }
        return (_super.prototype.toString.call(this, tab) +
            (0, printTree_1.printTree)(tab, [function (tab) { return 'req: ' + _this.req.toString(tab); }, function (tab) { return 'res: ' + _this.res.toString(tab); }]));
    };
    return FunctionStreamingType;
}(AbstractType));
exports.FunctionStreamingType = FunctionStreamingType;
