"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeBuilder = void 0;
var tslib_1 = require("tslib");
var schema = tslib_1.__importStar(require("../schema"));
var classes = tslib_1.__importStar(require("./classes"));
var s = schema.s;
var TypeBuilder = (function () {
    function TypeBuilder(system) {
        this.system = system;
    }
    Object.defineProperty(TypeBuilder.prototype, "any", {
        get: function () {
            return this.Any();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeBuilder.prototype, "undef", {
        get: function () {
            return this.Const(undefined);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeBuilder.prototype, "nil", {
        get: function () {
            return this.Const(null);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeBuilder.prototype, "bool", {
        get: function () {
            return this.Boolean();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeBuilder.prototype, "num", {
        get: function () {
            return this.Number();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeBuilder.prototype, "str", {
        get: function () {
            return this.String();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeBuilder.prototype, "bin", {
        get: function () {
            return this.Binary(this.any);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeBuilder.prototype, "arr", {
        get: function () {
            return this.Array(this.any);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeBuilder.prototype, "obj", {
        get: function () {
            return this.Object();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeBuilder.prototype, "fn", {
        get: function () {
            return this.Function(this.any, this.any);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeBuilder.prototype, "fn$", {
        get: function () {
            return this.Function$(this.any, this.any);
        },
        enumerable: false,
        configurable: true
    });
    TypeBuilder.prototype.Any = function (options) {
        var type = new classes.AnyType(s.Any(options));
        type.system = this.system;
        return type;
    };
    TypeBuilder.prototype.Const = function (value, options) {
        var type = new classes.ConstType(schema.s.Const(value, options));
        type.system = this.system;
        return type;
    };
    TypeBuilder.prototype.Boolean = function (options) {
        var type = new classes.BooleanType(s.Boolean(options));
        type.system = this.system;
        return type;
    };
    TypeBuilder.prototype.Number = function (options) {
        var type = new classes.NumberType(s.Number(options));
        type.system = this.system;
        return type;
    };
    TypeBuilder.prototype.String = function (options) {
        var type = new classes.StringType(s.String(options));
        type.system = this.system;
        return type;
    };
    TypeBuilder.prototype.Binary = function (type, options) {
        if (options === void 0) { options = {}; }
        var bin = new classes.BinaryType(type, options);
        bin.system = this.system;
        return bin;
    };
    TypeBuilder.prototype.Array = function (type, options) {
        var arr = new classes.ArrayType(type, options);
        arr.system = this.system;
        return arr;
    };
    TypeBuilder.prototype.Tuple = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        var tup = new classes.TupleType(types);
        tup.system = this.system;
        return tup;
    };
    TypeBuilder.prototype.Object = function () {
        var fields = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fields[_i] = arguments[_i];
        }
        var obj = new classes.ObjectType(fields);
        obj.system = this.system;
        return obj;
    };
    TypeBuilder.prototype.prop = function (key, value) {
        var field = new classes.ObjectFieldType(key, value);
        field.system = this.system;
        return field;
    };
    TypeBuilder.prototype.propOpt = function (key, value) {
        var field = new classes.ObjectOptionalFieldType(key, value);
        field.system = this.system;
        return field;
    };
    TypeBuilder.prototype.Or = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        var or = new classes.OrType(types);
        or.system = this.system;
        return or;
    };
    TypeBuilder.prototype.Ref = function (ref) {
        var type = new classes.RefType(ref);
        type.system = this.system;
        return type;
    };
    TypeBuilder.prototype.Function = function (req, res) {
        var fn = new classes.FunctionType(req, res);
        fn.system = this.system;
        return fn;
    };
    TypeBuilder.prototype.Function$ = function (req, res) {
        var fn = new classes.FunctionStreamingType(req, res);
        fn.system = this.system;
        return fn;
    };
    TypeBuilder.prototype.import = function (node) {
        var _this = this;
        switch (node.__t) {
            case 'any':
                return this.Any(node);
            case 'bool':
                return this.Boolean(node);
            case 'num':
                return this.Number(node);
            case 'str':
                return this.String(node);
            case 'bin':
                return this.Binary(this.import(node.type), node);
            case 'arr':
                return this.Array(this.import(node.type), node);
            case 'obj': {
                return this.Object.apply(this, tslib_1.__spreadArray([], tslib_1.__read(node.fields.map(function (f) {
                    return f.optional
                        ? _this.propOpt(f.key, _this.import(f.type)).options(f)
                        : _this.prop(f.key, _this.import(f.type)).options(f);
                })), false)).options(node);
            }
            case 'const':
                return this.Const(node.value).options(node);
            case 'or':
                return this.Or.apply(this, tslib_1.__spreadArray([], tslib_1.__read(node.types.map(function (t) { return _this.import(t); })), false)).options(node);
            case 'ref':
                return this.Ref(node.ref).options(node);
        }
        throw new Error("UNKNOWN_NODE [".concat(node.__t, "]"));
    };
    TypeBuilder.prototype.from = function (value) {
        var _this = this;
        switch (typeof value) {
            case 'undefined':
                return this.undef;
            case 'boolean':
                return this.bool;
            case 'number':
                return this.num;
            case 'string':
                return this.str;
            case 'object':
                if (value === null)
                    return this.nil;
                if (Array.isArray(value)) {
                    if (value.length === 0)
                        return this.arr;
                    var getType_1 = function (v) {
                        switch (typeof v) {
                            case 'object':
                                if (v === null)
                                    return 'nil';
                                if (Array.isArray(v))
                                    return 'arr';
                                return 'obj';
                            default:
                                return typeof v;
                        }
                    };
                    var allElementsOfTheSameType = value.every(function (v) { return getType_1(v) === getType_1(value[0]); });
                    return allElementsOfTheSameType
                        ? this.Array(this.from(value[0]))
                        : this.Tuple.apply(this, tslib_1.__spreadArray([], tslib_1.__read(value.map(function (v) { return _this.from(v); })), false));
                }
                return this.Object.apply(this, tslib_1.__spreadArray([], tslib_1.__read(Object.entries(value).map(function (_a) {
                    var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
                    return _this.prop(key, _this.from(value));
                })), false));
            default:
                return this.any;
        }
    };
    return TypeBuilder;
}());
exports.TypeBuilder = TypeBuilder;
