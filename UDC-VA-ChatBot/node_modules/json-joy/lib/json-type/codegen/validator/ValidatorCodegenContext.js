"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidatorCodegenContext = void 0;
var tslib_1 = require("tslib");
var codegen_1 = require("../../../util/codegen");
var constants_1 = require("../../constants");
var ValidatorCodegenContext = (function () {
    function ValidatorCodegenContext(options) {
        this.validatorCache = new Map();
        this.options = tslib_1.__assign({ skipObjectExtraFieldsCheck: false, unsafeMode: false }, options);
        var successResult = this.options.errors === 'boolean' ? 'false' : this.options.errors === 'string' ? "''" : 'null';
        this.codegen = new codegen_1.Codegen({
            epilogue: "return ".concat(successResult, ";"),
        });
    }
    ValidatorCodegenContext.prototype.js = function (js) {
        this.codegen.js(js);
    };
    ValidatorCodegenContext.prototype.err = function (code, path, opts) {
        var e_1, _a, e_2, _b;
        if (opts === void 0) { opts = {}; }
        switch (this.options.errors) {
            case 'boolean':
                return 'true';
            case 'string': {
                var out = "'[" + JSON.stringify(constants_1.ValidationError[code]);
                try {
                    for (var path_1 = tslib_1.__values(path), path_1_1 = path_1.next(); !path_1_1.done; path_1_1 = path_1.next()) {
                        var step = path_1_1.value;
                        if (typeof step === 'object') {
                            out += ",' + JSON.stringify(" + step.r + ") + '";
                        }
                        else {
                            out += ',' + JSON.stringify(step);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (path_1_1 && !path_1_1.done && (_a = path_1.return)) _a.call(path_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return out + "]'";
            }
            case 'object':
            default: {
                var out = '{code: ' +
                    JSON.stringify(constants_1.ValidationError[code]) +
                    ', errno: ' +
                    JSON.stringify(code) +
                    ', message: ' +
                    JSON.stringify(constants_1.ValidationErrorMessage[code]) +
                    ', path: [';
                var i = 0;
                try {
                    for (var path_2 = tslib_1.__values(path), path_2_1 = path_2.next(); !path_2_1.done; path_2_1 = path_2.next()) {
                        var step = path_2_1.value;
                        if (i)
                            out += ', ';
                        if (typeof step === 'object') {
                            out += step.r;
                        }
                        else {
                            out += JSON.stringify(step);
                        }
                        i++;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (path_2_1 && !path_2_1.done && (_b = path_2.return)) _b.call(path_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                out += ']';
                if (opts.refId) {
                    out += ', refId: ' + JSON.stringify(opts.refId);
                }
                if (opts.refError) {
                    out += ', ref: ' + opts.refError;
                }
                if (opts.validator) {
                    out += ', validator: ' + JSON.stringify(opts.validator);
                }
                return out + '}';
            }
        }
    };
    ValidatorCodegenContext.prototype.emitCustomValidators = function (node, path, r) {
        var e_3, _a;
        var validatorNames = node.getValidatorNames();
        try {
            for (var validatorNames_1 = tslib_1.__values(validatorNames), validatorNames_1_1 = validatorNames_1.next(); !validatorNames_1_1.done; validatorNames_1_1 = validatorNames_1.next()) {
                var validatorName = validatorNames_1_1.value;
                var codegen = this.codegen;
                var v = this.linkValidator(validatorName);
                var rerr = codegen.getRegister();
                var rc = codegen.getRegister();
                var err = this.err(constants_1.ValidationError.VALIDATION, path, { validator: validatorName, refError: rerr });
                var errInCatch = this.err(constants_1.ValidationError.VALIDATION, path, { validator: validatorName, refError: rc });
                var emitRc = this.options.errors === 'object';
                codegen.js("try {\n  var ".concat(rerr, " = ").concat(v, "(").concat(r, ");\n  if (").concat(rerr, ") return ").concat(err, ";\n} catch (e) {\n  ").concat(emitRc ? "var ".concat(rc, " = e ? e : new Error('Validator ").concat(JSON.stringify(validatorName), " failed.');") : '', "\n  return ").concat(errInCatch, ";\n}"));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (validatorNames_1_1 && !validatorNames_1_1.done && (_a = validatorNames_1.return)) _a.call(validatorNames_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    ValidatorCodegenContext.prototype.linkValidator = function (name) {
        var cached = this.validatorCache.get(name);
        if (cached)
            return cached;
        var system = this.options.system;
        if (!system)
            throw new Error('Type system not set.');
        var codegen = this.codegen;
        var validator = system.getCustomValidator(name);
        if (!validator)
            throw new Error("Custom validator \"".concat(name, "\" not found."));
        var result = codegen.linkDependency(validator.fn);
        this.validatorCache.set(name, result);
        return result;
    };
    ValidatorCodegenContext.prototype.compile = function () {
        return this.codegen.compile();
    };
    return ValidatorCodegenContext;
}());
exports.ValidatorCodegenContext = ValidatorCodegenContext;
