"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryEncoderCodegenContext = void 0;
var tslib_1 = require("tslib");
var codegen_1 = require("../../../util/codegen");
var WriteBlobStep_1 = require("../WriteBlobStep");
var concat_1 = require("../../../util/buffers/concat");
var Value_1 = require("../../../reactive-rpc/common/messages/Value");
var BinaryEncoderCodegenContext = (function () {
    function BinaryEncoderCodegenContext(options) {
        var _this = this;
        this.options = options;
        this.codegen = new codegen_1.Codegen({
            name: 'toBinary' + (options.name ? '_' + options.name : ''),
            args: ['r0', 'encoder'],
            prologue: "\nvar writer = encoder.writer;\nwriter.ensureCapacity(capacityEstimator(r0));\nvar uint8 = writer.uint8, view = writer.view;",
            epilogue: '',
            linkable: {
                Value: Value_1.Value,
            },
            processSteps: function (steps) {
                var e_1, _a;
                var stepsJoined = [];
                for (var i = 0; i < steps.length; i++) {
                    var step = steps[i];
                    if (step instanceof codegen_1.CodegenStepExecJs)
                        stepsJoined.push(step);
                    else if (step instanceof WriteBlobStep_1.WriteBlobStep) {
                        var last = stepsJoined[stepsJoined.length - 1];
                        if (last instanceof WriteBlobStep_1.WriteBlobStep)
                            last.arr = (0, concat_1.concat)(last.arr, step.arr);
                        else
                            stepsJoined.push(step);
                    }
                }
                var execSteps = [];
                try {
                    for (var stepsJoined_1 = tslib_1.__values(stepsJoined), stepsJoined_1_1 = stepsJoined_1.next(); !stepsJoined_1_1.done; stepsJoined_1_1 = stepsJoined_1.next()) {
                        var step = stepsJoined_1_1.value;
                        if (step instanceof codegen_1.CodegenStepExecJs) {
                            execSteps.push(step);
                        }
                        else if (step instanceof WriteBlobStep_1.WriteBlobStep) {
                            execSteps.push(_this.codegenBlob(step));
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (stepsJoined_1_1 && !stepsJoined_1_1.done && (_a = stepsJoined_1.return)) _a.call(stepsJoined_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return execSteps;
            },
        });
        this.codegen.linkDependency(options.type.capacityEstimator(), 'capacityEstimator');
    }
    BinaryEncoderCodegenContext.prototype.getBigIntStr = function (arr, offset) {
        var buf = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
            buf[i] = arr[offset + i];
        var view = new DataView(buf.buffer);
        var bigint = view.getBigUint64(0);
        return bigint.toString() + 'n';
    };
    BinaryEncoderCodegenContext.prototype.codegenBlob = function (step) {
        var lines = [];
        var ro = this.codegen.getRegister();
        var length = step.arr.length;
        if (length === 1) {
            lines.push("uint8[writer.x++] = ".concat(step.arr[0], ";"));
        }
        else {
            lines.push("var ".concat(ro, " = writer.x;"));
            lines.push("writer.x += ".concat(step.arr.length, ";"));
            var i = 0;
            while (i < length) {
                var remaining = length - i;
                if (remaining >= 8) {
                    var value = this.getBigIntStr(step.arr, i);
                    lines.push("view.setBigUint64(".concat(ro).concat(i ? " + ".concat(i) : '', ", ").concat(value, ");"));
                    i += 8;
                }
                else if (remaining >= 4) {
                    var value = (step.arr[i] << 24) | (step.arr[i + 1] << 16) | (step.arr[i + 2] << 8) | step.arr[i + 3];
                    lines.push("view.setInt32(".concat(ro).concat(i ? " + ".concat(i) : '', ", ").concat(value, ");"));
                    i += 4;
                }
                else if (remaining >= 2) {
                    var value = (step.arr[i] << 8) | step.arr[i + 1];
                    lines.push("view.setInt16(".concat(ro).concat(i ? " + ".concat(i) : '', ", ").concat(value, ");"));
                    i += 2;
                }
                else {
                    lines.push("uint8[".concat(ro).concat(i ? " + ".concat(i) : '', "] = ").concat(step.arr[i], ";"));
                    i++;
                }
            }
        }
        var js = lines.join('\n');
        return new codegen_1.CodegenStepExecJs(js);
    };
    BinaryEncoderCodegenContext.prototype.js = function (js) {
        this.codegen.js(js);
    };
    BinaryEncoderCodegenContext.prototype.gen = function (callback) {
        var encoder = this.options.encoder;
        encoder.writer.reset();
        callback(encoder);
        return encoder.writer.flush();
    };
    BinaryEncoderCodegenContext.prototype.blob = function (arr) {
        this.codegen.step(new WriteBlobStep_1.WriteBlobStep(arr));
    };
    BinaryEncoderCodegenContext.prototype.compile = function () {
        return this.codegen.compile();
    };
    return BinaryEncoderCodegenContext;
}());
exports.BinaryEncoderCodegenContext = BinaryEncoderCodegenContext;
