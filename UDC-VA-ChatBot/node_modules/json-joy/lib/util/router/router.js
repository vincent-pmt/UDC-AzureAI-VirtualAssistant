"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Match = exports.Route = exports.Destination = exports.Router = void 0;
var tslib_1 = require("tslib");
var JsExpression_1 = require("../codegen/util/JsExpression");
var printTree_1 = require("../print/printTree");
var codegen_1 = require("./codegen");
var steps_1 = require("./steps");
var tree_1 = require("./tree");
var Router = (function () {
    function Router(options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.destinations = [];
    }
    Router.prototype.add = function (route, data) {
        var destination = Destination.from(route, data, this.options.defaultUntil);
        this.destinations.push(destination);
    };
    Router.prototype.addDestination = function (destination) {
        this.destinations.push(destination);
    };
    Router.prototype.tree = function () {
        var e_1, _a, e_2, _b;
        var tree = new tree_1.RoutingTreeNode();
        try {
            for (var _c = tslib_1.__values(this.destinations), _d = _c.next(); !_d.done; _d = _c.next()) {
                var destination = _d.value;
                try {
                    for (var _e = (e_2 = void 0, tslib_1.__values(destination.routes)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var route = _f.value;
                        tree.add(route, 0, destination);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return tree;
    };
    Router.prototype.compile = function () {
        var ctx = new codegen_1.RouterCodegenCtx();
        var node = new codegen_1.RouterCodegenOpts(new JsExpression_1.JsExpression(function () { return 'str'; }), '0');
        var tree = this.tree();
        tree.codegen(ctx, node);
        return ctx.codegen.compile();
    };
    Router.prototype.toString = function (tab) {
        var _this = this;
        if (tab === void 0) { tab = ''; }
        return ("".concat(this.constructor.name) +
            (0, printTree_1.printTree)(tab, [
                function (tab) {
                    return 'Destinations' +
                        (0, printTree_1.printTree)(tab, _this.destinations.map(function (d, i) { return function (tab) { return "[".concat(i, "]: ") + d.toString(tab + ' '); }; }));
                },
                function () { return ''; },
                function (tab) { return 'RoutingTree' + (0, printTree_1.printTree)(tab, [function (tab) { return _this.tree().toString(tab); }]); },
            ]));
    };
    return Router;
}());
exports.Router = Router;
var Destination = (function () {
    function Destination(routes, data) {
        this.routes = routes;
        this.data = data;
        this.match = new Match(data, []);
    }
    Destination.from = function (def, data, defaultUntil) {
        var routes = typeof def === 'string' ? [Route.from(def, defaultUntil)] : def.map(function (r) { return Route.from(r); });
        return new Destination(routes, data);
    };
    Destination.prototype.toString = function (tab) {
        if (tab === void 0) { tab = ''; }
        return ("".concat(this.constructor.name, " ") +
            (this.routes.length === 1
                ? this.routes[0].toString(tab)
                : (0, printTree_1.printTree)(tab, this.routes.map(function (r) { return function (tab) { return r.toString(tab); }; }))));
    };
    return Destination;
}());
exports.Destination = Destination;
var Route = (function () {
    function Route(steps) {
        this.steps = steps;
    }
    Route.from = function (str, defaultUntil) {
        var e_3, _a;
        if (defaultUntil === void 0) { defaultUntil = '/'; }
        var tokens = [];
        var matches = str.match(/\{[^\}]*\}/g);
        var i = 0;
        try {
            for (var _b = tslib_1.__values(matches !== null && matches !== void 0 ? matches : []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var match = _c.value;
                var index = str.indexOf(match);
                if (index > i)
                    tokens.push(str.substring(i, index));
                tokens.push(match);
                i = index + match.length;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (i < str.length)
            tokens.push(str.substring(i));
        var steps = [];
        var length = tokens.length;
        for (var i_1 = 0; i_1 < length; i_1++) {
            var token = tokens[i_1];
            var isParameter = token.startsWith('{') && token.endsWith('}');
            if (isParameter) {
                var content = token.substring(1, token.length - 1);
                var _d = tslib_1.__read(content.split(':'), 3), _e = _d[0], name_1 = _e === void 0 ? '' : _e, _f = _d[1], regex = _f === void 0 ? '' : _f, _g = _d[2], until = _g === void 0 ? '' : _g;
                if (!regex || regex === '*') {
                    var next = tokens[i_1 + 1];
                    steps.push(new steps_1.UntilStep(name_1, until || (next ? next[0] : defaultUntil)));
                }
                else {
                    steps.push(new steps_1.RegexStep(name_1, regex, until));
                }
            }
            else {
                steps.push(new steps_1.ExactStep(token));
            }
        }
        return new Route(steps);
    };
    Route.prototype.toText = function () {
        var str = '';
        for (var step in this.steps)
            str += this.steps[step].toText();
        return str;
    };
    Route.prototype.toString = function (tab) {
        if (tab === void 0) { tab = ''; }
        return this.toText();
    };
    return Route;
}());
exports.Route = Route;
var Match = (function () {
    function Match(data, params) {
        this.data = data;
        this.params = params;
    }
    return Match;
}());
exports.Match = Match;
