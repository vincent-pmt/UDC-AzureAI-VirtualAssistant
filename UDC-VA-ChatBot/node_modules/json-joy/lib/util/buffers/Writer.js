"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Writer = void 0;
var Slice_1 = require("./Slice");
var EMPTY_UINT8 = new Uint8Array([]);
var EMPTY_VIEW = new DataView(EMPTY_UINT8.buffer);
var hasBuffer = typeof Buffer === 'function';
var utf8Write = hasBuffer
    ? Buffer.prototype.utf8Write
    : null;
var from = hasBuffer ? Buffer.from : null;
var textEncoder = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;
var Writer = (function () {
    function Writer(allocSize) {
        if (allocSize === void 0) { allocSize = 64 * 1024; }
        this.allocSize = allocSize;
        this.view = EMPTY_VIEW;
        this.x0 = 0;
        this.x = 0;
        this.uint8 = new Uint8Array(allocSize);
        this.size = allocSize;
        this.view = new DataView(this.uint8.buffer);
    }
    Writer.prototype.grow = function (size) {
        var x0 = this.x0;
        var x = this.x;
        var oldUint8 = this.uint8;
        var newUint8 = new Uint8Array(size);
        var view = new DataView(newUint8.buffer);
        var activeSlice = oldUint8.subarray(x0, x);
        newUint8.set(activeSlice, 0);
        this.x = x - x0;
        this.x0 = 0;
        this.uint8 = newUint8;
        this.size = size;
        this.view = view;
    };
    Writer.prototype.ensureCapacity = function (capacity) {
        var byteLength = this.size;
        var remaining = byteLength - this.x;
        if (remaining < capacity) {
            var total = byteLength - this.x0;
            var required = capacity - remaining;
            var totalRequired = total + required;
            this.grow(totalRequired <= this.allocSize ? this.allocSize : totalRequired * 2);
        }
    };
    Writer.prototype.move = function (capacity) {
        this.ensureCapacity(capacity);
        this.x += capacity;
    };
    Writer.prototype.reset = function () {
        this.x0 = this.x;
    };
    Writer.prototype.newBuffer = function (size) {
        var uint8 = (this.uint8 = new Uint8Array(size));
        this.size = size;
        this.view = new DataView(uint8);
        this.x = this.x0 = 0;
    };
    Writer.prototype.flush = function () {
        var result = this.uint8.subarray(this.x0, this.x);
        this.x0 = this.x;
        return result;
    };
    Writer.prototype.flushSlice = function () {
        var slice = new Slice_1.Slice(this.uint8, this.view, this.x0, this.x);
        this.x0 = this.x;
        return slice;
    };
    Writer.prototype.u8 = function (char) {
        this.ensureCapacity(1);
        this.uint8[this.x++] = char;
    };
    Writer.prototype.u16 = function (word) {
        this.ensureCapacity(2);
        this.view.setUint16(this.x, word);
        this.x += 2;
    };
    Writer.prototype.u32 = function (dword) {
        this.ensureCapacity(4);
        this.view.setUint32(this.x, dword);
        this.x += 4;
    };
    Writer.prototype.i32 = function (dword) {
        this.ensureCapacity(4);
        this.view.setInt32(this.x, dword);
        this.x += 4;
    };
    Writer.prototype.u64 = function (qword) {
        this.ensureCapacity(8);
        this.view.setBigUint64(this.x, BigInt(qword));
        this.x += 8;
    };
    Writer.prototype.f64 = function (float) {
        this.ensureCapacity(8);
        this.view.setFloat64(this.x, float);
        this.x += 8;
    };
    Writer.prototype.u8u16 = function (u8, u16) {
        this.ensureCapacity(3);
        var x = this.x;
        this.uint8[x++] = u8;
        this.uint8[x++] = u16 >>> 8;
        this.uint8[x++] = u16 & 0xff;
        this.x = x;
    };
    Writer.prototype.u8u32 = function (u8, u32) {
        this.ensureCapacity(5);
        var x = this.x;
        this.uint8[x++] = u8;
        this.view.setUint32(x, u32);
        this.x = x + 4;
    };
    Writer.prototype.u8u64 = function (u8, u64) {
        this.ensureCapacity(9);
        var x = this.x;
        this.uint8[x++] = u8;
        this.view.setBigUint64(x, BigInt(u64));
        this.x = x + 8;
    };
    Writer.prototype.u8f32 = function (u8, f32) {
        this.ensureCapacity(5);
        var x = this.x;
        this.uint8[x++] = u8;
        this.view.setFloat32(x, f32);
        this.x = x + 4;
    };
    Writer.prototype.u8f64 = function (u8, f64) {
        this.ensureCapacity(9);
        var x = this.x;
        this.uint8[x++] = u8;
        this.view.setFloat64(x, f64);
        this.x = x + 8;
    };
    Writer.prototype.buf = function (buf, length) {
        this.ensureCapacity(length);
        var x = this.x;
        this.uint8.set(buf, x);
        this.x = x + length;
    };
    Writer.prototype.utf8 = function (str) {
        var maxLength = str.length * 4;
        if (maxLength < 168)
            return this.utf8Native(str);
        if (utf8Write) {
            var writeLength = utf8Write.call(this.uint8, str, this.x, maxLength);
            this.x += writeLength;
            return writeLength;
        }
        else if (from) {
            var uint8 = this.uint8;
            var offset = uint8.byteOffset + this.x;
            var buf = from(uint8.buffer).subarray(offset, offset + maxLength);
            var writeLength = buf.write(str, 0, maxLength, 'utf8');
            this.x += writeLength;
            return writeLength;
        }
        else if (maxLength > 1024 && textEncoder) {
            var writeLength = textEncoder.encodeInto(str, this.uint8.subarray(this.x, this.x + maxLength)).written;
            this.x += writeLength;
            return writeLength;
        }
        return this.utf8Native(str);
    };
    Writer.prototype.utf8Native = function (str) {
        var length = str.length;
        var uint8 = this.uint8;
        var offset = this.x;
        var pos = 0;
        while (pos < length) {
            var value = str.charCodeAt(pos++);
            if ((value & 0xffffff80) === 0) {
                uint8[offset++] = value;
                continue;
            }
            else if ((value & 0xfffff800) === 0) {
                uint8[offset++] = ((value >> 6) & 0x1f) | 0xc0;
            }
            else {
                if (value >= 0xd800 && value <= 0xdbff) {
                    if (pos < length) {
                        var extra = str.charCodeAt(pos);
                        if ((extra & 0xfc00) === 0xdc00) {
                            pos++;
                            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                        }
                    }
                }
                if ((value & 0xffff0000) === 0) {
                    uint8[offset++] = ((value >> 12) & 0x0f) | 0xe0;
                    uint8[offset++] = ((value >> 6) & 0x3f) | 0x80;
                }
                else {
                    uint8[offset++] = ((value >> 18) & 0x07) | 0xf0;
                    uint8[offset++] = ((value >> 12) & 0x3f) | 0x80;
                    uint8[offset++] = ((value >> 6) & 0x3f) | 0x80;
                }
            }
            uint8[offset++] = (value & 0x3f) | 0x80;
        }
        var writeLength = offset - this.x;
        this.x = offset;
        return writeLength;
    };
    Writer.prototype.ascii = function (str) {
        var length = str.length;
        this.ensureCapacity(length);
        var uint8 = this.uint8;
        var offset = this.x;
        var pos = 0;
        while (pos < length)
            uint8[offset++] = str.charCodeAt(pos++);
        this.x = offset;
    };
    return Writer;
}());
exports.Writer = Writer;
