"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.print = exports.toRecord = exports.remove = exports.findWithParents = exports.find = exports.insert = void 0;
var tslib_1 = require("tslib");
var stringify_1 = require("../../../json-text/stringify");
var printTree_1 = require("../../print/printTree");
var TrieNode_1 = require("../trie/TrieNode");
var util_1 = require("../util");
var getCommonPrefixLength = function (a, b) {
    var len = Math.min(a.length, b.length);
    var i = 0;
    for (; i < len && a[i] === b[i]; i++)
        ;
    return i;
};
var insert = function (root, path, value) {
    var curr = root;
    var k = path;
    main: while (curr) {
        var child = curr.children;
        if (!child) {
            curr.children = new TrieNode_1.TrieNode(k, value);
            return 1;
        }
        var char = k[0];
        var prevChild = undefined;
        var cmp = false;
        child: while (child) {
            prevChild = child;
            var childChar = child.k[0];
            if (childChar === char) {
                var commonPrefixLength = getCommonPrefixLength(child.k, k);
                var isChildKContained = commonPrefixLength === child.k.length;
                var isKContained = commonPrefixLength === k.length;
                var areKeysEqual = isChildKContained && isKContained;
                if (areKeysEqual) {
                    child.v = value;
                    return 0;
                }
                if (isChildKContained) {
                    k = k.substring(commonPrefixLength);
                    curr = child;
                    continue main;
                }
                if (isKContained) {
                    var newChild = new TrieNode_1.TrieNode(child.k.substring(commonPrefixLength), child.v);
                    newChild.children = child.children;
                    child.k = k.substring(0, commonPrefixLength);
                    child.v = value;
                    child.children = newChild;
                    return 1;
                }
                if (commonPrefixLength) {
                    var newChild = new TrieNode_1.TrieNode(child.k.substring(commonPrefixLength), child.v);
                    newChild.children = child.children;
                    child.k = child.k.substring(0, commonPrefixLength);
                    child.v = undefined;
                    child.children = newChild;
                    curr = child;
                    k = k.substring(commonPrefixLength);
                    continue main;
                }
            }
            cmp = childChar > char;
            if (cmp)
                child = child.l;
            else
                child = child.r;
        }
        if (prevChild) {
            var node = new TrieNode_1.TrieNode(k, value);
            if (cmp)
                (0, util_1.insertLeft)(node, prevChild);
            else
                (0, util_1.insertRight)(node, prevChild);
            return 1;
        }
        break;
    }
    return 0;
};
exports.insert = insert;
var find = function (node, key) {
    if (!key)
        return node;
    var len = key.length;
    var offset = 0;
    while (node) {
        var child = (0, util_1.findOrNextLower)(node.children, key[offset], function (cmp1, cmp2) {
            return cmp1[0] > cmp2[0] ? 1 : -1;
        });
        if (!child)
            return undefined;
        var childKey = child.k;
        var childKeyLength = childKey.length;
        var commonPrefixLength = 0;
        var limit = Math.min(childKeyLength, len - offset);
        for (; commonPrefixLength < limit && childKey[commonPrefixLength] === key[offset + commonPrefixLength]; commonPrefixLength++)
            ;
        if (!commonPrefixLength)
            return undefined;
        offset += commonPrefixLength;
        if (offset === len)
            return child;
        if (commonPrefixLength < childKeyLength)
            return undefined;
        node = child;
    }
    return undefined;
};
exports.find = find;
var findWithParents = function (node, key) {
    if (!key)
        return undefined;
    var list = [node];
    var len = key.length;
    var offset = 0;
    while (node) {
        var child = (0, util_1.findOrNextLower)(node.children, key[offset], function (cmp1, cmp2) {
            return cmp1[0] > cmp2[0] ? 1 : -1;
        });
        if (!child)
            return undefined;
        var childKey = child.k;
        var childKeyLength = childKey.length;
        var commonPrefixLength = 0;
        var limit = Math.min(childKeyLength, len - offset);
        for (; commonPrefixLength < limit && childKey[commonPrefixLength] === key[offset + commonPrefixLength]; commonPrefixLength++)
            ;
        if (!commonPrefixLength)
            return undefined;
        offset += commonPrefixLength;
        if (commonPrefixLength < childKeyLength)
            return undefined;
        list.push(child);
        if (offset === len)
            return list;
        node = child;
    }
    return undefined;
};
exports.findWithParents = findWithParents;
var remove = function (root, key) {
    if (!key) {
        var deleted_1 = root.v !== undefined;
        root.v = undefined;
        return deleted_1;
    }
    var list = (0, exports.findWithParents)(root, key);
    if (!list)
        return false;
    var length = list.length;
    var lastIndex = length - 1;
    var last = list[lastIndex];
    var deleted = last.v !== undefined;
    last.v = undefined;
    for (var i = lastIndex; i >= 1; i--) {
        var child = list[i];
        var parent_1 = list[i - 1];
        if (child.v || child.children)
            break;
        parent_1.children = (0, util_1.remove)(parent_1.children, child);
    }
    return deleted;
};
exports.remove = remove;
var toRecord = function (node, prefix, record) {
    if (prefix === void 0) { prefix = ''; }
    if (record === void 0) { record = {}; }
    if (!node)
        return record;
    prefix += node.k;
    if (node.v !== undefined)
        record[prefix] = node.v;
    var child = (0, util_1.first)(node.children);
    if (!child)
        return record;
    do
        (0, exports.toRecord)(child, prefix, record);
    while ((child = (0, util_1.next)(child)));
    return record;
};
exports.toRecord = toRecord;
var print = function (node, tab) {
    if (tab === void 0) { tab = ''; }
    var detailedPrint = node.v && typeof node.v === 'object' && node.v.constructor !== Object;
    var value = node.v && typeof node.v === 'object'
        ? Array.isArray(node.v)
            ? (0, stringify_1.stringify)(node.v)
            : node.v.constructor === Object
                ? (0, stringify_1.stringify)(node.v)
                : ''
        : node.v === undefined
            ? ''
            : (0, stringify_1.stringify)(node.v);
    var childrenNodes = [];
    node.forChildren(function (child) { return childrenNodes.push(child); });
    return ("".concat(node.constructor.name, " ").concat(JSON.stringify(node.k)).concat(value ? ' = ' + value : '') +
        (0, printTree_1.printTree)(tab, tslib_1.__spreadArray([
            !detailedPrint ? null : function (tab) { return node.v.toString(tab); }
        ], tslib_1.__read(childrenNodes.map(function (child) { return function (tab) { return (0, exports.print)(child, tab); }; })), false)));
};
exports.print = print;
