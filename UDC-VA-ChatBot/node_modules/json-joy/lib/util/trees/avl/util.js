"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.print = exports.remove = exports.insert = exports.insertLeft = exports.insertRight = void 0;
var stringify_1 = require("../../../json-text/stringify");
var printBinary_1 = require("../../print/printBinary");
var rebalanceAfterInsert = function (root, node, child) {
    var p = node.p;
    if (!p)
        return root;
    var isLeft = node === p.l;
    var bf = p.bf | 0;
    if (isLeft)
        p.bf = ++bf;
    else
        p.bf = --bf;
    switch (bf) {
        case 0:
            return root;
        case 1:
        case -1:
            return rebalanceAfterInsert(root, p, node);
        default: {
            var isChildLeft = child === node.l;
            if (isLeft) {
                if (isChildLeft)
                    return llRotate(p, node), node.p ? root : node;
                else
                    return lrRotate(p, node, child), child.p ? root : child;
            }
            else {
                if (isChildLeft)
                    return rlRotate(p, node, child), child.p ? root : child;
                else
                    return rrRotate(p, node), node.p ? root : node;
            }
        }
    }
};
var llRotate = function (n, nl) {
    var p = n.p;
    var nlr = nl.r;
    nl.p = p;
    nl.r = n;
    n.p = nl;
    n.l = nlr;
    nlr && (nlr.p = n);
    p && (p.l === n ? (p.l = nl) : (p.r = nl));
    var nbf = n.bf;
    var nlbf = nl.bf;
    nbf += -1 - (nlbf > 0 ? nlbf : 0);
    nlbf += -1 + (nbf < 0 ? nbf : 0);
    n.bf = nbf;
    nl.bf = nlbf;
};
var rrRotate = function (n, nr) {
    var p = n.p;
    var nrl = nr.l;
    nr.p = p;
    nr.l = n;
    n.p = nr;
    n.r = nrl;
    nrl && (nrl.p = n);
    p && (p.l === n ? (p.l = nr) : (p.r = nr));
    var nbf = n.bf;
    var nrbf = nr.bf;
    nbf += 1 - (nrbf < 0 ? nrbf : 0);
    nrbf += 1 + (nbf > 0 ? nbf : 0);
    n.bf = nbf;
    nr.bf = nrbf;
};
var lrRotate = function (n, nl, nlr) {
    rrRotate(nl, nlr);
    llRotate(n, nlr);
};
var rlRotate = function (n, nr, nrl) {
    llRotate(nr, nrl);
    rrRotate(n, nrl);
};
var insertRight = function (root, n, p) {
    p.r = n;
    n.p = p;
    p.bf--;
    return p.l ? root : rebalanceAfterInsert(root, p, n);
};
exports.insertRight = insertRight;
var insertLeft = function (root, n, p) {
    p.l = n;
    n.p = p;
    p.bf++;
    return p.r ? root : rebalanceAfterInsert(root, p, n);
};
exports.insertLeft = insertLeft;
var insert = function (root, node, comparator) {
    if (!root)
        return node;
    var key = node.k;
    var curr = root;
    var next = undefined;
    var cmp = 0;
    while ((next = ((cmp = comparator(key, curr.k)) < 0 ? curr.l : curr.r)))
        curr = next;
    return (cmp < 0 ? (0, exports.insertLeft)(root, node, curr) : (0, exports.insertRight)(root, node, curr));
};
exports.insert = insert;
var remove = function (root, n) {
    if (!root)
        return n;
    var p = n.p;
    var l = n.l;
    var r = n.r;
    n.p = n.l = n.r = undefined;
    if (l && r) {
        var lr = l.r;
        if (!lr) {
            p && (p.l === n ? (p.l = l) : (p.r = l));
            l.p = p;
            l.r = r;
            r.p = l;
            var nbf = n.bf;
            if (p)
                return (l.bf = nbf), lRebalance(root, l, 1);
            var lbf = nbf - 1;
            l.bf = lbf;
            if (lbf >= -1)
                return l;
            var rl = r.l;
            return r.bf > 0 ? (rlRotate(l, r, rl), rl) : (rrRotate(l, r), r);
        }
        else {
            var v = l;
            var tmp = v;
            while ((tmp = v.r))
                v = tmp;
            var vl = v.l;
            var vp = v.p;
            var vc = vl;
            p && (p.l === n ? (p.l = v) : (p.r = v));
            v.p = p;
            v.r = r;
            v.bf = n.bf;
            l !== v && ((v.l = l), (l.p = v));
            r.p = v;
            vp && (vp.l === v ? (vp.l = vc) : (vp.r = vc));
            vc && (vc.p = vp);
            return rRebalance(p ? root : v, vp, 1);
        }
    }
    var c = (l || r);
    c && (c.p = p);
    if (!p)
        return c;
    return p.l === n ? ((p.l = c), lRebalance(root, p, 1)) : ((p.r = c), rRebalance(root, p, 1));
};
exports.remove = remove;
var lRebalance = function (root, n, d) {
    var bf = n.bf | 0;
    bf -= d;
    n.bf = bf;
    var nextD = d;
    if (bf === -1)
        return root;
    if (bf < -1) {
        var u = n.r;
        if (u.bf <= 0) {
            if (u.l && u.bf === 0)
                nextD = 0;
            rrRotate(n, u);
            n = u;
        }
        else {
            var ul = u.l;
            rlRotate(n, u, ul);
            n = ul;
        }
    }
    var p = n.p;
    if (!p)
        return n;
    return p.l === n ? lRebalance(root, p, nextD) : rRebalance(root, p, nextD);
};
var rRebalance = function (root, n, d) {
    var bf = n.bf | 0;
    bf += d;
    n.bf = bf;
    var nextD = d;
    if (bf === 1)
        return root;
    if (bf > 1) {
        var u = n.l;
        if (u.bf >= 0) {
            if (u.r && u.bf === 0)
                nextD = 0;
            llRotate(n, u);
            n = u;
        }
        else {
            var ur = u.r;
            lrRotate(n, u, ur);
            n = ur;
        }
    }
    var p = n.p;
    if (!p)
        return n;
    return p.l === n ? lRebalance(root, p, nextD) : rRebalance(root, p, nextD);
};
var print = function (node, tab) {
    if (tab === void 0) { tab = ''; }
    if (!node)
        return 'âˆ…';
    var _a = node, bf = _a.bf, l = _a.l, r = _a.r, k = _a.k, v = _a.v;
    var content = k !== undefined ? " { ".concat((0, stringify_1.stringify)(k), " = ").concat((0, stringify_1.stringify)(v), " }") : '';
    var bfFormatted = bf ? " [".concat(bf, "]") : '';
    return (node.constructor.name +
        "".concat(bfFormatted) +
        content +
        (0, printBinary_1.printBinary)(tab, [l ? function (tab) { return (0, exports.print)(l, tab); } : null, r ? function (tab) { return (0, exports.print)(r, tab); } : null]));
};
exports.print = print;
