"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Patch = void 0;
var tslib_1 = require("tslib");
var ArrInsOp_1 = require("./operations/ArrInsOp");
var ArrOp_1 = require("./operations/ArrOp");
var BinInsOp_1 = require("./operations/BinInsOp");
var BinOp_1 = require("./operations/BinOp");
var ConstOp_1 = require("./operations/ConstOp");
var DelOp_1 = require("./operations/DelOp");
var clock_1 = require("./clock");
var NoopOp_1 = require("./operations/NoopOp");
var ObjOp_1 = require("./operations/ObjOp");
var ObjSetOp_1 = require("./operations/ObjSetOp");
var StrInsOp_1 = require("./operations/StrInsOp");
var StrOp_1 = require("./operations/StrOp");
var ValOp_1 = require("./operations/ValOp");
var ValSetOp_1 = require("./operations/ValSetOp");
var encode_1 = require("./codec/binary/encode");
var decode_1 = require("./codec/binary/decode");
var TupOp_1 = require("./operations/TupOp");
var Patch = (function () {
    function Patch() {
        this.ops = [];
    }
    Patch.fromBinary = function (data) {
        return (0, decode_1.decode)(data);
    };
    Patch.prototype.getId = function () {
        var op = this.ops[0];
        if (!op)
            return undefined;
        return op.id;
    };
    Patch.prototype.span = function () {
        var e_1, _a;
        var span = 0;
        try {
            for (var _b = tslib_1.__values(this.ops), _c = _b.next(); !_c.done; _c = _b.next()) {
                var op = _c.value;
                span += op.span();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return span;
    };
    Patch.prototype.nextTime = function () {
        var ops = this.ops;
        var length = ops.length;
        if (!length)
            return 0;
        var lastOp = ops[length - 1];
        return lastOp.id.time + lastOp.span();
    };
    Patch.prototype.rewriteTime = function (ts) {
        var patch = new Patch();
        var ops = this.ops;
        var length = ops.length;
        for (var i = 0; i < length; i++) {
            var op = ops[i];
            if (op instanceof DelOp_1.DelOp)
                patch.ops.push(new DelOp_1.DelOp(ts(op.id), ts(op.obj), op.what));
            else if (op instanceof ArrInsOp_1.ArrInsOp)
                patch.ops.push(new ArrInsOp_1.ArrInsOp(ts(op.id), ts(op.obj), ts(op.ref), op.data.map(ts)));
            else if (op instanceof StrInsOp_1.StrInsOp)
                patch.ops.push(new StrInsOp_1.StrInsOp(ts(op.id), ts(op.obj), ts(op.ref), op.data));
            else if (op instanceof BinInsOp_1.BinInsOp)
                patch.ops.push(new BinInsOp_1.BinInsOp(ts(op.id), ts(op.obj), ts(op.ref), op.data));
            else if (op instanceof ArrOp_1.ArrOp)
                patch.ops.push(new ArrOp_1.ArrOp(ts(op.id)));
            else if (op instanceof TupOp_1.TupOp)
                patch.ops.push(new TupOp_1.TupOp(ts(op.id)));
            else if (op instanceof ConstOp_1.ConstOp)
                patch.ops.push(new ConstOp_1.ConstOp(ts(op.id), op.val));
            else if (op instanceof ValOp_1.ValOp)
                patch.ops.push(new ValOp_1.ValOp(ts(op.id), ts(op.val)));
            else if (op instanceof ObjOp_1.ObjOp)
                patch.ops.push(new ObjOp_1.ObjOp(ts(op.id)));
            else if (op instanceof StrOp_1.StrOp)
                patch.ops.push(new StrOp_1.StrOp(ts(op.id)));
            else if (op instanceof BinOp_1.BinOp)
                patch.ops.push(new BinOp_1.BinOp(ts(op.id)));
            else if (op instanceof ValSetOp_1.ValSetOp)
                patch.ops.push(new ValSetOp_1.ValSetOp(ts(op.id), ts(op.obj), ts(op.val)));
            else if (op instanceof ObjSetOp_1.ObjSetOp)
                patch.ops.push(new ObjSetOp_1.ObjSetOp(ts(op.id), ts(op.obj), op.data.map(function (_a) {
                    var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
                    return [key, ts(value)];
                })));
            else if (op instanceof NoopOp_1.NoopOp)
                patch.ops.push(new NoopOp_1.NoopOp(ts(op.id), op.len));
        }
        return patch;
    };
    Patch.prototype.rebase = function (serverTime, transformHorizon) {
        var id = this.getId();
        if (!id)
            throw new Error('EMPTY_PATCH');
        var patchStartTime = id.time;
        if (patchStartTime === serverTime)
            return this;
        var delta = serverTime - patchStartTime;
        return this.rewriteTime(function (id) {
            var sessionId = id.sid;
            var isServerTimestamp = sessionId === 1;
            if (!isServerTimestamp)
                return id;
            var time = id.time;
            if (time < transformHorizon)
                return id;
            return (0, clock_1.ts)(1, time + delta);
        });
    };
    Patch.prototype.clone = function () {
        return this.rewriteTime(function (id) { return id; });
    };
    Patch.prototype.toString = function (tab) {
        if (tab === void 0) { tab = ''; }
        var id = this.getId();
        var out = "".concat(this.constructor.name, " ").concat(id ? (0, clock_1.toDisplayString)(id) : '(nil)', "!").concat(this.span());
        for (var i = 0; i < this.ops.length; i++) {
            var isLast = i === this.ops.length - 1;
            out += "\n".concat(tab).concat(isLast ? '└─' : '├─', " ").concat(this.ops[i].toString(tab + (isLast ? '  ' : '│ ')));
        }
        return out;
    };
    Patch.prototype.toBinary = function () {
        return (0, encode_1.encode)(this);
    };
    return Patch;
}());
exports.Patch = Patch;
