"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerVectorClock = exports.VectorClock = exports.LogicalClock = exports.interval = exports.toDisplayString = exports.containsId = exports.contains = exports.compare = exports.equal = exports.tick = exports.tss = exports.ts = exports.Timespan = exports.Timestamp = void 0;
var tslib_1 = require("tslib");
var Timestamp = (function () {
    function Timestamp(sid, time) {
        this.sid = sid;
        this.time = time;
    }
    return Timestamp;
}());
exports.Timestamp = Timestamp;
var Timespan = (function () {
    function Timespan(sid, time, span) {
        this.sid = sid;
        this.time = time;
        this.span = span;
    }
    return Timespan;
}());
exports.Timespan = Timespan;
var ts = function (sid, time) { return new Timestamp(sid, time); };
exports.ts = ts;
var tss = function (sid, time, span) { return new Timespan(sid, time, span); };
exports.tss = tss;
var tick = function (stamp, cycles) { return (0, exports.ts)(stamp.sid, stamp.time + cycles); };
exports.tick = tick;
var equal = function (ts1, ts2) {
    return ts1.time === ts2.time && ts1.sid === ts2.sid;
};
exports.equal = equal;
var compare = function (ts1, ts2) {
    var t1 = ts1.time;
    var t2 = ts2.time;
    if (t1 > t2)
        return 1;
    if (t1 < t2)
        return -1;
    var s1 = ts1.sid;
    var s2 = ts2.sid;
    if (s1 > s2)
        return 1;
    if (s1 < s2)
        return -1;
    return 0;
};
exports.compare = compare;
var contains = function (ts1, span1, ts2, span2) {
    if (ts1.sid !== ts2.sid)
        return false;
    var t1 = ts1.time;
    var t2 = ts2.time;
    if (t1 > t2)
        return false;
    if (t1 + span1 < t2 + span2)
        return false;
    return true;
};
exports.contains = contains;
var containsId = function (ts1, span1, ts2) {
    if (ts1.sid !== ts2.sid)
        return false;
    var t1 = ts1.time;
    var t2 = ts2.time;
    if (t1 > t2)
        return false;
    if (t1 + span1 < t2 + 1)
        return false;
    return true;
};
exports.containsId = containsId;
var toDisplayString = function (id) {
    if (id.sid === 1)
        return '.' + id.time;
    var session = '' + id.sid;
    if (session.length > 4)
        session = '..' + session.slice(session.length - 4);
    return session + '.' + id.time;
};
exports.toDisplayString = toDisplayString;
var interval = function (ts, tick, span) {
    return new Timespan(ts.sid, ts.time + tick, span);
};
exports.interval = interval;
var LogicalClock = (function (_super) {
    tslib_1.__extends(LogicalClock, _super);
    function LogicalClock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LogicalClock.prototype.tick = function (cycles) {
        var timestamp = new Timestamp(this.sid, this.time);
        this.time += cycles;
        return timestamp;
    };
    return LogicalClock;
}(Timestamp));
exports.LogicalClock = LogicalClock;
var VectorClock = (function (_super) {
    tslib_1.__extends(VectorClock, _super);
    function VectorClock() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.peers = new Map();
        return _this;
    }
    VectorClock.prototype.observe = function (id, span) {
        var edge = id.time + span - 1;
        var sid = id.sid;
        if (sid !== this.sid) {
            var clock = this.peers.get(id.sid);
            if (!clock)
                this.peers.set(id.sid, (0, exports.ts)(sid, edge));
            else if (edge > clock.time)
                clock.time = edge;
        }
        if (edge >= this.time)
            this.time = edge + 1;
    };
    VectorClock.prototype.clone = function () {
        return this.fork(this.sid);
    };
    VectorClock.prototype.fork = function (sessionId) {
        var clock = new VectorClock(sessionId, this.time);
        if (sessionId !== this.sid)
            clock.observe((0, exports.tick)(this, -1), 1);
        this.peers.forEach(function (peer) {
            clock.observe(peer, 1);
        });
        return clock;
    };
    VectorClock.prototype.toString = function (tab) {
        if (tab === void 0) { tab = ''; }
        var last = this.peers.size;
        var i = 1;
        var lines = '';
        this.peers.forEach(function (clock) {
            var isLast = i === last;
            lines += "\n".concat(tab).concat(isLast ? '└─' : '├─', " ").concat(clock.sid, ".").concat(clock.time);
            i++;
        });
        return "".concat(this.constructor.name, " ").concat(this.sid, ".").concat(this.time).concat(lines);
    };
    return VectorClock;
}(LogicalClock));
exports.VectorClock = VectorClock;
var ServerVectorClock = (function (_super) {
    tslib_1.__extends(ServerVectorClock, _super);
    function ServerVectorClock() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.peers = new Map();
        return _this;
    }
    ServerVectorClock.prototype.observe = function (ts, span) {
        if (ts.sid !== 1)
            throw new Error('INVALID_SERVER_SESSION');
        if (this.time < ts.time)
            throw new Error('TIME_TRAVEL');
        var time = ts.time + span;
        if (time > this.time)
            this.time = time;
    };
    ServerVectorClock.prototype.clone = function () {
        return this.fork();
    };
    ServerVectorClock.prototype.fork = function () {
        return new ServerVectorClock(1, this.time);
    };
    return ServerVectorClock;
}(LogicalClock));
exports.ServerVectorClock = ServerVectorClock;
