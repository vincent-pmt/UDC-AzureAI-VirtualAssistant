"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CborEncoderStable = void 0;
var tslib_1 = require("tslib");
var CborEncoder_1 = require("./CborEncoder");
var insertion2_1 = require("../../util/sort/insertion2");
var objectKeyComparator = function (a, b) {
    var len1 = a.length;
    var len2 = b.length;
    return len1 === len2 ? (a > b ? 1 : -1) : len1 - len2;
};
var strHeaderLength = function (strSize) {
    if (strSize <= 23)
        return 1;
    else if (strSize <= 0xff)
        return 2;
    else if (strSize <= 0xffff)
        return 3;
    else
        return 5;
};
var CborEncoderStable = (function (_super) {
    tslib_1.__extends(CborEncoderStable, _super);
    function CborEncoderStable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CborEncoderStable.prototype.writeObj = function (obj) {
        var keys = Object.keys(obj);
        (0, insertion2_1.sort)(keys, objectKeyComparator);
        var length = keys.length;
        this.writeObjHdr(length);
        for (var i = 0; i < length; i++) {
            var key = keys[i];
            this.writeStr(key);
            this.writeAny(obj[key]);
        }
    };
    CborEncoderStable.prototype.writeStr = function (str) {
        var writer = this.writer;
        var length = str.length;
        var maxSize = length * 4;
        writer.ensureCapacity(5 + maxSize);
        var headerLengthGuess = strHeaderLength(length);
        var x0 = writer.x;
        var x1 = x0 + headerLengthGuess;
        writer.x = x1;
        var bytesWritten = writer.utf8(str);
        var uint8 = writer.uint8;
        var headerLength = strHeaderLength(bytesWritten);
        if (headerLength !== headerLengthGuess) {
            var shift = headerLength - headerLengthGuess;
            uint8.copyWithin(x1 + shift, x1, x1 + bytesWritten);
        }
        switch (headerLength) {
            case 1:
                uint8[x0] = 96 + bytesWritten;
                break;
            case 2:
                uint8[x0] = 0x78;
                uint8[x0 + 1] = bytesWritten;
                break;
            case 3: {
                uint8[x0] = 0x79;
                writer.view.setUint16(x0 + 1, bytesWritten);
                break;
            }
            case 5: {
                uint8[x0] = 0x7a;
                writer.view.setUint32(x0 + 1, bytesWritten);
                break;
            }
        }
        writer.x = x0 + headerLength + bytesWritten;
    };
    CborEncoderStable.prototype.writeUndef = function () {
        this.writeNull();
    };
    return CborEncoderStable;
}(CborEncoder_1.CborEncoder));
exports.CborEncoderStable = CborEncoderStable;
