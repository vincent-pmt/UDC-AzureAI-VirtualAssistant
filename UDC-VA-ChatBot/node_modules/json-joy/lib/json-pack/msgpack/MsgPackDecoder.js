"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgPackDecoder = void 0;
var tslib_1 = require("tslib");
var _1 = require(".");
var MsgPackDecoderFast_1 = require("./MsgPackDecoderFast");
var MsgPackDecoder = (function (_super) {
    tslib_1.__extends(MsgPackDecoder, _super);
    function MsgPackDecoder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MsgPackDecoder.prototype.skipAny = function () {
        var byte = this.reader.u8();
        if (byte >= 0xe0)
            return 1;
        if (byte <= 0xbf) {
            if (byte < 0x90) {
                if (byte <= 127)
                    return 1;
                return 1 + this.skipObj(byte & 15);
            }
            else {
                if (byte < 0xa0)
                    return 1 + this.skipArr(byte & 15);
                else
                    return 1 + this.skip(byte & 31);
            }
        }
        if (byte <= 0xd0) {
            if (byte <= 0xc8) {
                if (byte <= 0xc4) {
                    if (byte <= 0xc2)
                        return byte === 0xc2 ? 1 : 1;
                    else
                        return byte === 0xc4 ? 2 + this.skip(this.reader.u8()) : 1;
                }
                else {
                    if (byte <= 0xc6)
                        return byte === 0xc6 ? 5 + this.skip(this.reader.u32()) : 3 + this.skip(this.reader.u16());
                    else
                        return byte === 0xc8 ? 4 + this.skip(this.reader.u16()) : 3 + this.skip(this.reader.u8());
                }
            }
            else {
                return byte <= 0xcc
                    ? byte <= 0xca
                        ? byte === 0xca
                            ? 1 + this.skip(4)
                            : 1 + 1 + 4 + this.skip(this.reader.u32())
                        : byte === 0xcc
                            ? 1 + this.skip(1)
                            : 1 + this.skip(8)
                    : byte <= 0xce
                        ? byte === 0xce
                            ? 1 + this.skip(4)
                            : 1 + this.skip(2)
                        : byte === 0xd0
                            ? 1 + this.skip(1)
                            : 1 + this.skip(8);
            }
        }
        else if (byte <= 0xd8) {
            return byte <= 0xd4
                ? byte <= 0xd2
                    ? byte === 0xd2
                        ? 1 + this.skip(4)
                        : 1 + this.skip(2)
                    : byte === 0xd4
                        ? 1 + this.skip(2)
                        : 1 + this.skip(8)
                : byte <= 0xd6
                    ? byte === 0xd6
                        ? 1 + this.skip(5)
                        : 1 + this.skip(3)
                    : byte === 0xd8
                        ? 1 + this.skip(17)
                        : 1 + this.skip(9);
        }
        else {
            switch (byte) {
                case 0xd9:
                    return 2 + this.skip(this.reader.u8());
                case 0xda:
                    return 3 + this.skip(this.reader.u16());
                case 0xdb:
                    return 5 + this.skip(this.reader.u32());
                case 0xdc:
                    return 3 + this.skipArr(this.reader.u16());
                case 0xdd:
                    return 5 + this.skipArr(this.reader.u32());
                case 0xde:
                    return 3 + this.skipObj(this.reader.u16());
                case 0xdf:
                    return 5 + this.skipObj(this.reader.u32());
            }
        }
        return 1;
    };
    MsgPackDecoder.prototype.skipArr = function (size) {
        var length = 0;
        for (var i = 0; i < size; i++)
            length += this.skipAny();
        return length;
    };
    MsgPackDecoder.prototype.skipObj = function (size) {
        var length = 0;
        for (var i = 0; i < size; i++) {
            length += this.skipAny() + this.skipAny();
        }
        return length;
    };
    MsgPackDecoder.prototype.readLevel = function (uint8) {
        this.reader.reset(uint8);
        return this.valOneLevel();
    };
    MsgPackDecoder.prototype.valOneLevel = function () {
        var byte = this.reader.view.getUint8(this.reader.x);
        var isMap = byte === 0xde || byte === 0xdf || byte >> 4 === 8;
        if (isMap) {
            this.reader.x++;
            var size = byte === 0xde ? this.reader.u16() : byte === 0xdf ? this.reader.u32() : byte & 15;
            var obj = {};
            for (var i = 0; i < size; i++) {
                var key = this.key();
                obj[key] = this.primitive();
            }
            return obj;
        }
        var isArray = byte === 0xdc || byte === 0xdd || byte >> 4 === 9;
        if (isArray) {
            this.reader.x++;
            var size = byte === 0xdc ? this.reader.u16() : byte === 0xdd ? this.reader.u32() : byte & 15;
            var arr = [];
            for (var i = 0; i < size; i++)
                arr.push(this.primitive());
            return arr;
        }
        return this.val();
    };
    MsgPackDecoder.prototype.primitive = function () {
        var reader = this.reader;
        var byte = reader.view.getUint8(reader.x);
        var isMapOrArray = byte === 0xde || byte === 0xdf || byte === 0xdc || byte === 0xdd || byte >> 5 === 4;
        if (isMapOrArray) {
            var length_1 = this.skipAny();
            reader.x -= length_1;
            var buf = reader.buf(length_1);
            return new _1.JsonPackValue(buf);
        }
        return this.val();
    };
    MsgPackDecoder.prototype.skip = function (length) {
        this.reader.x += length;
        return length;
    };
    MsgPackDecoder.prototype.validate = function (value, offset, size) {
        if (offset === void 0) { offset = 0; }
        if (size === void 0) { size = value.length; }
        this.reader.reset(value);
        this.reader.x = offset;
        var start = offset;
        this.skipAny();
        var end = this.reader.x;
        if (end - start !== size)
            throw new Error('INVALID_SIZE');
    };
    MsgPackDecoder.prototype.readObjHdr = function () {
        var reader = this.reader;
        var byte = reader.u8();
        var isFixMap = byte >> 4 === 8;
        if (isFixMap)
            return byte & 15;
        switch (byte) {
            case 0xde:
                return reader.u16();
            case 0xdf:
                return reader.u32();
        }
        throw new Error('NOT_OBJ');
    };
    MsgPackDecoder.prototype.readStrHdr = function () {
        var reader = this.reader;
        var byte = reader.u8();
        if (byte >> 5 === 5)
            return byte & 31;
        switch (byte) {
            case 0xd9:
                return reader.u8();
            case 0xda:
                return reader.u16();
            case 0xdb:
                return reader.u32();
        }
        throw new Error('NOT_STR');
    };
    MsgPackDecoder.prototype.findKey = function (key) {
        var size = this.readObjHdr();
        for (var i = 0; i < size; i++) {
            var k = this.key();
            if (k === key)
                return this;
            this.skipAny();
        }
        throw new Error('KEY_NOT_FOUND');
    };
    MsgPackDecoder.prototype.readArrHdr = function () {
        var reader = this.reader;
        var byte = reader.u8();
        var isFixArr = byte >> 4 === 9;
        if (isFixArr)
            return byte & 15;
        switch (byte) {
            case 0xdc:
                return this.reader.u16();
            case 0xdd:
                return this.reader.u32();
        }
        throw new Error('NOT_ARR');
    };
    MsgPackDecoder.prototype.findIndex = function (index) {
        var size = this.readArrHdr();
        if (index >= size)
            throw new Error('INDEX_OUT_OF_BOUNDS');
        for (var i = 0; i < index; i++)
            this.skipAny();
        return this;
    };
    MsgPackDecoder.prototype.find = function (path) {
        for (var i = 0; i < path.length; i++) {
            var segment = path[i];
            if (typeof segment === 'string')
                this.findKey(segment);
            else
                this.findIndex(segment);
        }
        return this;
    };
    return MsgPackDecoder;
}(MsgPackDecoderFast_1.MsgPackDecoderFast));
exports.MsgPackDecoder = MsgPackDecoder;
