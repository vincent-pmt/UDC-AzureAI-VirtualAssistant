"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.genShallowReader = void 0;
var tslib_1 = require("tslib");
var Codegen_1 = require("../../util/codegen/Codegen");
var toUtf8 = function (str) {
    var arr = [];
    var length = str.length;
    var curr = 0;
    while (curr < length) {
        var value = str.charCodeAt(curr++);
        if ((value & 0xffffff80) === 0) {
            arr.push(value);
            continue;
        }
        else if ((value & 0xfffff800) === 0) {
            arr.push(((value >> 6) & 0x1f) | 0xc0);
        }
        else {
            if (value >= 0xd800 && value <= 0xdbff) {
                if (curr < length) {
                    var extra = str.charCodeAt(curr);
                    if ((extra & 0xfc00) === 0xdc00) {
                        curr++;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) {
                arr.push(((value >> 12) & 0x0f) | 0xe0);
                arr.push(((value >> 6) & 0x3f) | 0x80);
            }
            else {
                arr.push(((value >> 18) & 0x07) | 0xf0);
                arr.push(((value >> 12) & 0x3f) | 0x80);
                arr.push(((value >> 6) & 0x3f) | 0x80);
            }
        }
        arr.push((value & 0x3f) | 0x80);
    }
    return arr;
};
var genShallowReader = function (path) {
    var codegen = new Codegen_1.Codegen({
        args: ['dec'],
        name: 'readShallow',
        prologue: 'var r = dec.reader;',
        epilogue: 'return r.x;',
    });
    for (var i = 0; i < path.length; i++) {
        var step = path[i];
        switch (typeof step) {
            case 'string': {
                var rObj = codegen.getRegister();
                var rIter = codegen.getRegister();
                var rFound = codegen.getRegister();
                codegen.js("var ".concat(rObj, " = dec.readObjHdr();"));
                codegen.js("var ".concat(rFound, " = false;"));
                codegen.js("for(var ".concat(rIter, " = 0; ").concat(rIter, " < ").concat(rObj, "; ").concat(rIter, "++) {"));
                var utf8Arr = toUtf8(step);
                var length_1 = utf8Arr.length;
                var rKey = codegen.getRegister();
                codegen.js("var ".concat(rKey, " = dec.readStrHdr();"));
                codegen.js("if (".concat(rKey, " !== ").concat(length_1, ") { r.x += ").concat(rKey, "; dec.skipAny(); continue; };"));
                while (utf8Arr.length > 0) {
                    if (utf8Arr.length >= 4) {
                        var word = utf8Arr.splice(0, 4);
                        var utf8Chunk = '0x' + word.map(function (x) { return x.toString(16); }).join('');
                        codegen.js("if (r.u32() !== ".concat(utf8Chunk, ") { ").concat(utf8Arr.length ? "r.x += ".concat(utf8Arr.length, "; ") : '', "dec.skipAny(); continue; }"));
                    }
                    else if (utf8Arr.length >= 2) {
                        var word = utf8Arr.splice(0, 2);
                        var utf8Chunk = '0x' + word.map(function (x) { return x.toString(16); }).join('');
                        codegen.js("if (r.u16() !== ".concat(utf8Chunk, ") { ").concat(utf8Arr.length ? "r.x += ".concat(utf8Arr.length, "; ") : '', "dec.skipAny(); continue; }"));
                    }
                    else {
                        var _a = tslib_1.__read(utf8Arr.splice(0, 1), 1), octet = _a[0];
                        codegen.js("if (r.u8() !== ".concat(octet, ") { ").concat(utf8Arr.length ? "r.x += ".concat(utf8Arr.length, "; ") : '', "dec.skipAny(); continue; }"));
                    }
                }
                codegen.js("".concat(rFound, " = true;"));
                codegen.js("break;");
                codegen.js("}");
                codegen.js("if (!".concat(rFound, ") throw new Error('KEY_NOT_FOUND');"));
                break;
            }
            case 'number': {
                var rObj = codegen.getRegister();
                codegen.js("var ".concat(rObj, " = dec.readArrHdr();"));
                codegen.js("if(".concat(rObj, " <= ").concat(step, ") throw new Error('INDEX_OUT_OF_BOUNDS');"));
                for (var i_1 = 0; i_1 < step; i_1++)
                    codegen.js("dec.skipAny();");
                break;
            }
            default: {
                throw new Error('INVALID_PATH_STEP');
            }
        }
    }
    return codegen.compile();
};
exports.genShallowReader = genShallowReader;
