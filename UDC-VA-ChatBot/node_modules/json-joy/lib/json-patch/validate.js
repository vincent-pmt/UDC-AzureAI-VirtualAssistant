"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePredicateOperation = exports.validateOperation = exports.validateOperations = void 0;
var tslib_1 = require("tslib");
var validate_1 = require("../json-pointer/validate");
var hasOwnProperty_1 = require("../util/hasOwnProperty");
var validateOperations = function (ops, allowMatchesOp) {
    if (allowMatchesOp === void 0) { allowMatchesOp = false; }
    if (!Array.isArray(ops))
        throw new Error('Not a array.');
    if (!ops.length)
        throw new Error('Empty operation patch.');
    for (var i = 0; i < ops.length; i++) {
        var op = ops[i];
        try {
            (0, exports.validateOperation)(op, allowMatchesOp);
        }
        catch (error) {
            var message = error instanceof Error ? error.message : String(error);
            throw new Error("Error in operation [index = ".concat(i, "] (").concat(message, ")."));
        }
    }
};
exports.validateOperations = validateOperations;
var validateOperation = function (op, allowMatchesOp) {
    if (!op || typeof op !== 'object')
        throw new Error('OP_INVALID');
    var path = op.path;
    if (typeof path !== 'string')
        throw new Error('OP_PATH_INVALID');
    (0, validate_1.validateJsonPointer)(path);
    switch (op.op) {
        case 'add':
            validateOperationAdd(op);
            break;
        case 'remove':
            validateOperationRemove(op);
            break;
        case 'replace':
            validateOperationReplace(op);
            break;
        case 'copy':
            validateOperationCopy(op);
            break;
        case 'move':
            validateOperationMove(op);
            break;
        case 'flip':
            break;
        case 'inc':
            validateOperationInc(op);
            break;
        case 'str_ins':
            validateOperationInsertText(op);
            break;
        case 'str_del':
            validateOperationRemoveText(op);
            break;
        case 'extend':
            validateOperationExtend(op);
            break;
        case 'merge':
            validateOperationMerge(op);
            break;
        case 'split':
            validateOperationSplit(op);
            break;
        default:
            (0, exports.validatePredicateOperation)(op, allowMatchesOp);
    }
};
exports.validateOperation = validateOperation;
var validatePredicateOperation = function (op, allowMatchesOp) {
    var e_1, _a;
    if (!op || typeof op !== 'object')
        throw new Error('OP_INVALID');
    (0, validate_1.validateJsonPointer)(op.path);
    switch (op.op) {
        case 'test':
            validateOperationTest(op);
            break;
        case 'test_type':
            validateOperationTestType(op);
            break;
        case 'test_string':
            validateOperationTestString(op);
            break;
        case 'test_string_len':
            validateOperationTestStringLen(op);
            break;
        case 'matches':
            if (!allowMatchesOp)
                throw new Error('"matches" operation not allowed.');
            validateOperationPredicateWithValueAndCase(op);
            break;
        case 'contains':
        case 'ends':
        case 'starts':
            validateOperationPredicateWithValueAndCase(op);
            break;
        case 'in':
            if (!Array.isArray(op.value))
                throw new Error('"in" operation "value" must be an array.');
            break;
        case 'more':
        case 'less':
            if (typeof op.value !== 'number')
                throw new Error('Value must be a number.');
            break;
        case 'type':
            validateValueString(op.value);
            validateTestType(op.value);
            break;
        case 'defined':
        case 'undefined':
            break;
        case 'and':
        case 'or':
        case 'not':
            if (!Array.isArray(op.apply))
                throw new Error("\"".concat(op.op, "\" predicate operators must be an array."));
            if (!op.apply.length)
                throw new Error('Predicate list is empty.');
            try {
                for (var _b = tslib_1.__values(op.apply), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var predicate = _c.value;
                    (0, exports.validatePredicateOperation)(predicate, allowMatchesOp);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            break;
        default:
            throw new Error('OP_UNKNOWN');
    }
};
exports.validatePredicateOperation = validatePredicateOperation;
var validateOperationAdd = function (op) {
    validateValue(op.value);
};
var validateOperationRemove = function (op) {
    if ((0, hasOwnProperty_1.hasOwnProperty)(op, 'oldValue') && op.oldValue === undefined)
        throw new Error('Invalid oldValue.');
};
var validateOperationReplace = function (op) {
    if ((0, hasOwnProperty_1.hasOwnProperty)(op, 'oldValue') && op.oldValue === undefined)
        throw new Error('Invalid oldValue.');
};
var validateOperationCopy = function (op) {
    var from = op.from;
    if (typeof from !== 'string')
        throw new Error('OP_FROM_INVALID');
    (0, validate_1.validateJsonPointer)(from);
};
var validateOperationMove = function (op) {
    var from = op.from;
    if (typeof from !== 'string')
        throw new Error('OP_FROM_INVALID');
    (0, validate_1.validateJsonPointer)(from);
    var path = op.path;
    if (path.indexOf(from + '/') === 0)
        throw new Error('Cannot move into own children.');
};
var validateOperationTest = function (op) {
    validateValue(op.value);
    validateNot(op.not);
};
var validateOperationTestType = function (op) {
    var e_2, _a;
    if (!Array.isArray(op.type))
        throw new Error('Invalid "type" field.');
    if (op.type.length < 1)
        throw new Error('Empty type list.');
    try {
        for (var _b = tslib_1.__values(op.type), _c = _b.next(); !_c.done; _c = _b.next()) {
            var type = _c.value;
            validateTestType(type);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
};
var validTypes = new Set(['string', 'number', 'boolean', 'object', 'integer', 'array', 'null']);
var validateTestType = function (type) {
    if (!validTypes.has(type))
        throw new Error('Invalid type.');
};
var validateOperationTestString = function (op) {
    validateNot(op.not);
    validateNonNegativeInteger(op.pos);
    if (typeof op.str !== 'string')
        throw new Error('Value must be a string.');
};
var validateOperationTestStringLen = function (op) {
    validateNot(op.not);
    validateNonNegativeInteger(op.len);
};
var validateOperationInc = function (op) {
    if (typeof op.inc !== 'number')
        throw new Error('Invalid "inc" value.');
};
var validateOperationInsertText = function (op) {
    validateNonNegativeInteger(op.pos);
    if (typeof op.str !== 'string')
        throw new Error('Expected a string "text" field.');
};
var validateOperationRemoveText = function (op) {
    validateNonNegativeInteger(op.pos);
    if (op.str === undefined && op.len === undefined)
        throw new Error('Either "text" or "pos" need to be set.');
    if (op.str !== undefined) {
        if (typeof op.str !== 'string')
            throw new Error('Expected a string "text" field.');
    }
    else {
        validateNonNegativeInteger(op.len);
    }
};
var validateOperationExtend = function (op) {
    if (!op.props || typeof op.props !== 'object')
        throw new Error('Invalid "props" field.');
    if (op.deleteNull !== undefined)
        if (typeof op.deleteNull !== 'boolean')
            throw new Error('Expected "deleteNull" field to be boolean.');
};
var validateOperationMerge = function (op) {
    validateInteger(op.pos);
    if (op.pos < 1)
        throw new Error('Expected "pos" field to be greater than 0.');
    if (op.props)
        if (typeof op.props !== 'object')
            throw new Error('Invalid "props" field.');
};
var validateOperationSplit = function (op) {
    validateInteger(op.pos);
    if (op.props)
        if (typeof op.props !== 'object')
            throw new Error('Invalid "props" field.');
};
var validateOperationPredicateWithValueAndCase = function (op) {
    validateValueString(op.value);
    validateIgnoreCase(op.ignore_case);
};
var validateValue = function (value) {
    if (value === undefined)
        throw new Error('OP_VALUE_MISSING');
};
var validateValueString = function (value) {
    if (typeof value !== 'string')
        throw new Error('Expected "value" to be string.');
    if (value.length > 20000)
        throw new Error('Value too long.');
};
var validateIgnoreCase = function (ignore) {
    if (ignore === undefined)
        return;
    if (typeof ignore !== 'boolean')
        throw new Error('Expected "ignore_case" to be a boolean.');
};
var validateNot = function (not) {
    if (not !== undefined)
        if (typeof not !== 'boolean')
            throw new Error('Invalid "not" modifier.');
};
var validateInteger = function (num) {
    if (typeof num !== 'number' || num !== Math.round(num))
        throw new Error('Not an integer.');
};
var validateNonNegativeInteger = function (num) {
    validateInteger(num);
    if (num < 0)
        throw new Error('Number is negative.');
};
