"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decoder = void 0;
var tslib_1 = require("tslib");
var op_1 = require("../../op");
var MsgPackDecoderFast_1 = require("../../../json-pack/msgpack/MsgPackDecoderFast");
var util_1 = require("../../util");
var Decoder = (function (_super) {
    tslib_1.__extends(Decoder, _super);
    function Decoder(options) {
        var _this = _super.call(this) || this;
        _this.options = options;
        return _this;
    }
    Decoder.prototype.decode = function (uint8) {
        this.reader.reset(uint8);
        return this.decodePatch();
    };
    Decoder.prototype.decodePatch = function () {
        var len = this.decodeArrayHeader();
        var ops = [];
        for (var i = 0; i < len; i++)
            ops.push(this.decodeOp(undefined));
        return ops;
    };
    Decoder.prototype.decodeOp = function (parent) {
        var length = this.decodeArrayHeader();
        var opcode = this.reader.u8();
        switch (opcode) {
            case 0: {
                var path = this.decodeArray();
                var value = this.val();
                return new op_1.OpAdd(path, value);
            }
            case 43: {
                var path = this.decodePath(parent);
                var length_1 = this.decodeArrayHeader();
                var ops = [];
                var op = new op_1.OpAnd(path, ops);
                for (var i = 0; i < length_1; i++)
                    ops.push(this.decodeOp(op));
                return op;
            }
            case 30: {
                var path = this.decodePath(parent);
                var value = this.decodeString();
                var ignoreCase = length > 3;
                return new op_1.OpContains(path, value, ignoreCase);
            }
            case 3: {
                var path = this.decodeArray();
                var from = this.decodeArray();
                return new op_1.OpCopy(path, from);
            }
            case 31: {
                var path = this.decodePath(parent);
                return new op_1.OpDefined(path);
            }
            case 32: {
                var path = this.decodePath(parent);
                var value = this.decodeString();
                var ignoreCase = length > 3;
                return new op_1.OpEnds(path, value, ignoreCase);
            }
            case 12: {
                var path = this.decodeArray();
                var props = this.decodeObject();
                var deleteNull = length > 3;
                return new op_1.OpExtend(path, props, deleteNull);
            }
            case 8: {
                var path = this.decodeArray();
                return new op_1.OpFlip(path);
            }
            case 33: {
                var path = this.decodePath(parent);
                var value = this.decodeArray();
                return new op_1.OpIn(path, value);
            }
            case 9: {
                var path = this.decodePath(parent);
                var inc = this.val();
                return new op_1.OpInc(path, inc);
            }
            case 34: {
                var path = this.decodePath(parent);
                var value = this.val();
                return new op_1.OpLess(path, value);
            }
            case 35: {
                var path = this.decodePath(parent);
                var value = this.decodeString();
                var ignoreCase = length > 3;
                return new op_1.OpMatches(path, value, ignoreCase, this.options.createMatcher || util_1.createMatcherDefault);
            }
            case 11: {
                var hasProps = length > 3;
                var path = this.decodeArray();
                var pos = this.val();
                var props = hasProps ? this.decodeObject() : null;
                return new op_1.OpMerge(path, pos, props);
            }
            case 36: {
                var path = this.decodePath(parent);
                var value = this.val();
                return new op_1.OpMore(path, value);
            }
            case 4: {
                var path = this.decodeArray();
                var from = this.decodeArray();
                return new op_1.OpMove(path, from);
            }
            case 44: {
                var path = this.decodePath(parent);
                var length_2 = this.decodeArrayHeader();
                var ops = [];
                var op = new op_1.OpNot(path, ops);
                for (var i = 0; i < length_2; i++)
                    ops.push(this.decodeOp(op));
                return op;
            }
            case 45: {
                var path = this.decodePath(parent);
                var length_3 = this.decodeArrayHeader();
                var ops = [];
                var op = new op_1.OpOr(path, ops);
                for (var i = 0; i < length_3; i++)
                    ops.push(this.decodeOp(op));
                return op;
            }
            case 1: {
                var path = this.decodeArray();
                var hasOldValue = length > 2;
                var oldValue = hasOldValue ? this.val() : undefined;
                return new op_1.OpRemove(path, oldValue);
            }
            case 2: {
                var path = this.decodeArray();
                var value = this.val();
                var hasOldValue = length > 3;
                var oldValue = hasOldValue ? this.val() : undefined;
                return new op_1.OpReplace(path, value, oldValue);
            }
            case 10: {
                var path = this.decodeArray();
                var pos = this.val();
                var hasProps = length > 3;
                var props = hasProps ? this.decodeObject() : null;
                return new op_1.OpSplit(path, pos, props);
            }
            case 37: {
                var ignoreCase = length > 3;
                var path = this.decodePath(parent);
                var value = this.decodeString();
                return new op_1.OpStarts(path, value, ignoreCase);
            }
            case 7: {
                var hasStr = length < 5;
                var path = this.decodeArray();
                var pos = this.val();
                if (hasStr) {
                    var str = this.decodeString();
                    return new op_1.OpStrDel(path, pos, str, undefined);
                }
                else {
                    this.reader.u8();
                    var len = this.val();
                    return new op_1.OpStrDel(path, pos, undefined, len);
                }
            }
            case 6: {
                var path = this.decodeArray();
                var pos = this.val();
                var str = this.decodeString();
                return new op_1.OpStrIns(path, pos, str);
            }
            case 5: {
                var not = length > 3;
                var path = this.decodePath(parent);
                var value = this.val();
                return new op_1.OpTest(path, value, not);
            }
            case 40: {
                var not = length > 4;
                var path = this.decodePath(parent);
                var pos = this.val();
                var str = this.decodeString();
                return new op_1.OpTestString(path, pos, str, not);
            }
            case 41: {
                var not = length > 3;
                var path = this.decodePath(parent);
                var len = this.val();
                return new op_1.OpTestStringLen(path, len, not);
            }
            case 39: {
                var path = this.decodePath(parent);
                var type = this.decodeArray();
                return new op_1.OpTestType(path, type);
            }
            case 42: {
                var path = this.decodePath(parent);
                var value = this.decodeString();
                return new op_1.OpType(path, value);
            }
            case 38: {
                var path = this.decodePath(parent);
                return new op_1.OpUndefined(path);
            }
        }
        throw new Error('OP_UNKNOWN');
    };
    Decoder.prototype.decodePath = function (parent) {
        var path = this.decodeArray();
        if (!parent)
            return path;
        return tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(parent.path), false), tslib_1.__read(path), false);
    };
    Decoder.prototype.decodeObject = function () {
        var reader = this.reader;
        var byte = reader.u8();
        if (byte <= 0xbf)
            return this.obj(byte & 15);
        else if (byte === 0xde)
            return this.obj(reader.u16());
        else
            return this.obj(reader.u32());
    };
    Decoder.prototype.decodeArray = function () {
        var reader = this.reader;
        var byte = reader.u8();
        if (byte < 159)
            return this.arr(byte & 15);
        else if (byte === 0xdc)
            return this.arr(reader.u16());
        else
            return this.arr(reader.u32());
    };
    Decoder.prototype.decodeArrayHeader = function () {
        var reader = this.reader;
        var byte = reader.u8();
        if (byte < 159)
            return byte & 15;
        else if (byte === 0xdc)
            return reader.u16();
        else
            return reader.u32();
    };
    Decoder.prototype.decodeString = function () {
        var reader = this.reader;
        var byte = reader.u8();
        if (byte <= 0xbf)
            return reader.utf8(byte & 31);
        else if (byte === 0xd9)
            return reader.utf8(reader.u8());
        else if (byte === 0xda)
            return reader.utf8(reader.u16());
        else
            return reader.utf8(reader.u32());
    };
    return Decoder;
}(MsgPackDecoderFast_1.MsgPackDecoderFast));
exports.Decoder = Decoder;
