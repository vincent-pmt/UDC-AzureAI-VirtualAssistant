"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.operationToPredicateOp = exports.operationToOp = void 0;
var tslib_1 = require("tslib");
var OpAdd_1 = require("../../op/OpAdd");
var OpRemove_1 = require("../../op/OpRemove");
var OpReplace_1 = require("../../op/OpReplace");
var OpMove_1 = require("../../op/OpMove");
var OpCopy_1 = require("../../op/OpCopy");
var OpTest_1 = require("../../op/OpTest");
var OpFlip_1 = require("../../op/OpFlip");
var OpInc_1 = require("../../op/OpInc");
var OpStrIns_1 = require("../../op/OpStrIns");
var OpStrDel_1 = require("../../op/OpStrDel");
var OpSplit_1 = require("../../op/OpSplit");
var OpMerge_1 = require("../../op/OpMerge");
var OpExtend_1 = require("../../op/OpExtend");
var OpDefined_1 = require("../../op/OpDefined");
var OpUndefined_1 = require("../../op/OpUndefined");
var OpTestType_1 = require("../../op/OpTestType");
var OpTestString_1 = require("../../op/OpTestString");
var OpTestStringLen_1 = require("../../op/OpTestStringLen");
var OpContains_1 = require("../../op/OpContains");
var OpEnds_1 = require("../../op/OpEnds");
var OpStarts_1 = require("../../op/OpStarts");
var OpIn_1 = require("../../op/OpIn");
var OpLess_1 = require("../../op/OpLess");
var OpMore_1 = require("../../op/OpMore");
var OpAnd_1 = require("../../op/OpAnd");
var OpOr_1 = require("../../op/OpOr");
var OpNot_1 = require("../../op/OpNot");
var OpMatches_1 = require("../../op/OpMatches");
var OpType_1 = require("../../op/OpType");
var json_pointer_1 = require("../../../json-pointer");
var util_1 = require("../../util");
var operationToOp = function (op, options) {
    switch (op.op) {
        case 'add':
            return new OpAdd_1.OpAdd((0, json_pointer_1.toPath)(op.path), op.value);
        case 'remove':
            return new OpRemove_1.OpRemove((0, json_pointer_1.toPath)(op.path), op.oldValue);
        case 'replace':
            return new OpReplace_1.OpReplace((0, json_pointer_1.toPath)(op.path), op.value, op.oldValue);
        case 'move':
            return new OpMove_1.OpMove((0, json_pointer_1.toPath)(op.path), (0, json_pointer_1.toPath)(op.from));
        case 'copy':
            return new OpCopy_1.OpCopy((0, json_pointer_1.toPath)(op.path), (0, json_pointer_1.toPath)(op.from));
        case 'flip':
            return new OpFlip_1.OpFlip((0, json_pointer_1.toPath)(op.path));
        case 'inc':
            return new OpInc_1.OpInc((0, json_pointer_1.toPath)(op.path), op.inc);
        case 'str_ins':
            return new OpStrIns_1.OpStrIns((0, json_pointer_1.toPath)(op.path), op.pos, op.str);
        case 'str_del':
            return new OpStrDel_1.OpStrDel((0, json_pointer_1.toPath)(op.path), op.pos, op.str, op.len);
        case 'split':
            return new OpSplit_1.OpSplit((0, json_pointer_1.toPath)(op.path), op.pos, op.props || null);
        case 'merge':
            return new OpMerge_1.OpMerge((0, json_pointer_1.toPath)(op.path), op.pos, op.props || null);
        case 'extend':
            return new OpExtend_1.OpExtend((0, json_pointer_1.toPath)(op.path), op.props, !!op.deleteNull);
        default:
            return (0, exports.operationToPredicateOp)(op, options);
    }
};
exports.operationToOp = operationToOp;
var operationToPredicateOp = function (op, options) {
    switch (op.op) {
        case 'test':
            return new OpTest_1.OpTest((0, json_pointer_1.toPath)(op.path), op.value, !!op.not);
        case 'defined':
            return new OpDefined_1.OpDefined((0, json_pointer_1.toPath)(op.path));
        case 'undefined':
            return new OpUndefined_1.OpUndefined((0, json_pointer_1.toPath)(op.path));
        case 'type':
            return new OpType_1.OpType((0, json_pointer_1.toPath)(op.path), op.value);
        case 'test_type':
            return new OpTestType_1.OpTestType((0, json_pointer_1.toPath)(op.path), op.type);
        case 'test_string':
            return new OpTestString_1.OpTestString((0, json_pointer_1.toPath)(op.path), op.pos, op.str, !!op.not);
        case 'test_string_len':
            return new OpTestStringLen_1.OpTestStringLen((0, json_pointer_1.toPath)(op.path), op.len, !!op.not);
        case 'contains':
            return new OpContains_1.OpContains((0, json_pointer_1.toPath)(op.path), op.value, !!op.ignore_case);
        case 'ends':
            return new OpEnds_1.OpEnds((0, json_pointer_1.toPath)(op.path), op.value, !!op.ignore_case);
        case 'starts':
            return new OpStarts_1.OpStarts((0, json_pointer_1.toPath)(op.path), op.value, !!op.ignore_case);
        case 'matches':
            return new OpMatches_1.OpMatches((0, json_pointer_1.toPath)(op.path), op.value, !!op.ignore_case, options.createMatcher || util_1.createMatcherDefault);
        case 'in':
            return new OpIn_1.OpIn((0, json_pointer_1.toPath)(op.path), op.value);
        case 'less':
            return new OpLess_1.OpLess((0, json_pointer_1.toPath)(op.path), op.value);
        case 'more':
            return new OpMore_1.OpMore((0, json_pointer_1.toPath)(op.path), op.value);
        case 'and': {
            var path_1 = (0, json_pointer_1.toPath)(op.path);
            return new OpAnd_1.OpAnd(path_1, op.apply.map(function (x) { return (0, exports.operationToPredicateOp)(tslib_1.__assign(tslib_1.__assign({}, x), { path: tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(path_1), false), tslib_1.__read((0, json_pointer_1.toPath)(x.path)), false) }), options); }));
        }
        case 'or': {
            var path_2 = (0, json_pointer_1.toPath)(op.path);
            return new OpOr_1.OpOr(path_2, op.apply.map(function (x) { return (0, exports.operationToPredicateOp)(tslib_1.__assign(tslib_1.__assign({}, x), { path: tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(path_2), false), tslib_1.__read((0, json_pointer_1.toPath)(x.path)), false) }), options); }));
        }
        case 'not': {
            var path_3 = (0, json_pointer_1.toPath)(op.path);
            return new OpNot_1.OpNot(path_3, op.apply.map(function (x) { return (0, exports.operationToPredicateOp)(tslib_1.__assign(tslib_1.__assign({}, x), { path: tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(path_3), false), tslib_1.__read((0, json_pointer_1.toPath)(x.path)), false) }), options); }));
        }
        default:
            throw new Error('OP_UNKNOWN');
    }
};
exports.operationToPredicateOp = operationToPredicateOp;
function decode(patch, options) {
    var ops = [];
    var length = patch.length;
    for (var i = 0; i < length; i++) {
        var op = (0, exports.operationToOp)(patch[i], options);
        ops.push(op);
    }
    return ops;
}
exports.decode = decode;
