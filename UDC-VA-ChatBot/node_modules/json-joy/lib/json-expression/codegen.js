"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonExpressionCodegen = void 0;
var tslib_1 = require("tslib");
var Codegen_1 = require("../util/codegen/Codegen");
var deepEqual_1 = require("../json-equal/deepEqual");
var __deepEqual_1 = require("../json-equal/$$deepEqual");
var find_1 = require("../json-pointer/codegen/find");
var json_pointer_1 = require("../json-pointer");
var util_1 = require("./util");
var isExpression = function (expr) { return expr instanceof Array && typeof expr[0] === 'string'; };
var toBoxed = function (value) { return (value instanceof Array ? [value] : value); };
var linkable = {
    get: util_1.get,
    throwOnUndef: util_1.throwOnUndef,
    deepEqual: deepEqual_1.deepEqual,
    type: util_1.type,
    str: util_1.str,
    starts: util_1.starts,
    contains: util_1.contains,
    ends: util_1.ends,
    isInContainer: util_1.isInContainer,
    substr: util_1.substr,
    slash: util_1.slash,
    betweenNeNe: util_1.betweenNeNe,
    betweenEqNe: util_1.betweenEqNe,
    betweenNeEq: util_1.betweenNeEq,
    betweenEqEq: util_1.betweenEqEq,
};
var Literal = (function () {
    function Literal(val) {
        this.val = val;
    }
    Literal.prototype.toString = function () {
        return JSON.stringify(this.val);
    };
    return Literal;
}());
var Expression = (function () {
    function Expression(val) {
        this.val = val;
    }
    Expression.prototype.toString = function () {
        return this.val;
    };
    return Expression;
}());
var JsonExpressionCodegen = (function () {
    function JsonExpressionCodegen(options) {
        this.options = options;
        this.codegen = new Codegen_1.Codegen({
            args: ['ctx'],
            prologue: 'var data = ctx.data;',
            epilogue: '',
            linkable: linkable,
        });
    }
    JsonExpressionCodegen.prototype.onGet = function (expr) {
        if (expr.length < 2 || expr.length > 3)
            throw new Error('"get" operator expects two or three operands.');
        var path = this.onExpression(expr[1]);
        var def = expr[2] === undefined ? undefined : this.onExpression(expr[2]);
        if (def !== undefined && !(0, util_1.isLiteral)(expr[2]))
            throw new Error('"get" operator expects a default value to be a literal.');
        this.codegen.link('throwOnUndef');
        if (path instanceof Literal) {
            if (typeof path.val !== 'string')
                throw new Error('Invalid JSON pointer.');
            (0, json_pointer_1.validateJsonPointer)(path.val);
            var fn = (0, find_1.$$find)((0, json_pointer_1.toPath)(path.val));
            var d = this.codegen.addConstant(fn);
            return new Expression("throwOnUndef(".concat(d, "(data), ").concat(def, ")"));
        }
        else {
            this.codegen.link('get');
            return new Expression("throwOnUndef(get(".concat(path, ", data), ").concat(def, ")"));
        }
    };
    JsonExpressionCodegen.prototype.onEqualsLiteralLiteral = function (a, b) {
        return new Literal((0, deepEqual_1.deepEqual)(a.val, b.val));
    };
    JsonExpressionCodegen.prototype.onEqualsLiteralExpression = function (literal, expression) {
        var fn = (0, __deepEqual_1.$$deepEqual)(literal.val);
        var d = this.codegen.addConstant(fn);
        return new Expression("".concat(d, "(").concat(expression, ")"));
    };
    JsonExpressionCodegen.prototype.onEquals = function (expr) {
        if (expr.length !== 3)
            throw new Error('"==" operator expects two operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return this.onEqualsLiteralLiteral(a, b);
        if (a instanceof Literal && b instanceof Expression)
            return this.onEqualsLiteralExpression(a, b);
        if (b instanceof Literal && a instanceof Expression)
            return this.onEqualsLiteralExpression(b, a);
        this.codegen.link('deepEqual');
        return new Expression("deepEqual(".concat(a, ", ").concat(b, ")"));
    };
    JsonExpressionCodegen.prototype.onNotEquals = function (expr) {
        if (expr.length !== 3)
            throw new Error('"!=" operator expects two operands.');
        var _a = tslib_1.__read(expr, 3), a = _a[1], b = _a[2];
        var res = this.onEquals(['eq', a, b]);
        if (res instanceof Literal)
            return new Literal(!res.val);
        return new Expression("!(".concat(res, ")"));
    };
    JsonExpressionCodegen.prototype.onNot = function (expr) {
        if (expr.length > 2)
            throw new Error('"not" operator expects one operand.');
        var _a = tslib_1.__read(expr, 2), a = _a[1];
        var res = this.onExpression(a);
        if (res instanceof Literal)
            return new Literal(!res.val);
        return new Expression("!(".concat(res, ")"));
    };
    JsonExpressionCodegen.prototype.onIf = function (expr) {
        if (expr.length !== 4)
            throw new Error('"if" operator expects three operands.');
        var _a = tslib_1.__read(expr, 4), a = _a[1], b = _a[2], c = _a[3];
        var condition = this.onExpression(a);
        if (condition instanceof Literal)
            return condition.val ? this.onExpression(b) : this.onExpression(c);
        return new Expression("".concat(condition, " ? ").concat(this.onExpression(b), " : ").concat(this.onExpression(c)));
    };
    JsonExpressionCodegen.prototype.onAnd = function (expr) {
        if (expr.length <= 2)
            throw new Error('"and" operator expects at least two operands.');
        var _a = tslib_1.__read(expr), operands = _a.slice(1);
        var expressions = [];
        var allLiteral = true;
        for (var i = 0; i < operands.length; i++) {
            var expression = this.onExpression(operands[i]);
            if (!(expression instanceof Literal))
                allLiteral = false;
            expressions.push(expression);
        }
        if (allLiteral) {
            for (var i = 0; i < expressions.length; i++) {
                var expression = expressions[i];
                if (!expression.val)
                    return new Literal(false);
            }
            return new Literal(true);
        }
        return new Expression(expressions.map(function (expr) { return "!!(".concat(expr, ")"); }).join(' && '));
    };
    JsonExpressionCodegen.prototype.onOr = function (expr) {
        if (expr.length <= 2)
            throw new Error('"or" operator expects at least two operands.');
        var _a = tslib_1.__read(expr), operands = _a.slice(1);
        var expressions = [];
        var allLiteral = true;
        for (var i = 0; i < operands.length; i++) {
            var expression = this.onExpression(operands[i]);
            if (!(expression instanceof Literal))
                allLiteral = false;
            expressions.push(expression);
        }
        if (allLiteral) {
            for (var i = 0; i < expressions.length; i++) {
                var expression = expressions[i];
                if (expression.val)
                    return new Literal(true);
            }
            return new Literal(false);
        }
        return new Expression(expressions.map(function (expr) { return "!!(".concat(expr, ")"); }).join(' || '));
    };
    JsonExpressionCodegen.prototype.onType = function (expr) {
        if (expr.length !== 2)
            throw new Error('"type" operator expects one operand.');
        var _a = tslib_1.__read(expr, 2), operand = _a[1];
        var expression = this.onExpression(operand);
        if (expression instanceof Literal)
            return new Literal((0, util_1.type)(expression.val));
        this.codegen.link('type');
        return new Expression("type(".concat(expression, ")"));
    };
    JsonExpressionCodegen.prototype.onBool = function (expr) {
        if (expr.length !== 2)
            throw new Error('"bool" operator expects one operand.');
        var _a = tslib_1.__read(expr, 2), operand = _a[1];
        var expression = this.onExpression(operand);
        if (expression instanceof Literal)
            return new Literal(!!expression.val);
        return new Expression("!!(".concat(expression, ")"));
    };
    JsonExpressionCodegen.prototype.onNum = function (expr) {
        if (expr.length !== 2)
            throw new Error('"num" operator expects one operand.');
        var _a = tslib_1.__read(expr, 2), operand = _a[1];
        var expression = this.onExpression(operand);
        if (expression instanceof Literal)
            return new Literal(+expression.val || 0);
        return new Expression("+(".concat(expression, ") || 0"));
    };
    JsonExpressionCodegen.prototype.onInt = function (expr) {
        if (expr.length !== 2)
            throw new Error('"int" operator expects one operand.');
        var _a = tslib_1.__read(expr, 2), operand = _a[1];
        var expression = this.onExpression(operand);
        if (expression instanceof Literal)
            return new Literal(~~expression.val);
        return new Expression("+(".concat(expression, ")"));
    };
    JsonExpressionCodegen.prototype.onStr = function (expr) {
        if (expr.length !== 2)
            throw new Error('"str" operator expects one operand.');
        var _a = tslib_1.__read(expr, 2), operand = _a[1];
        var expression = this.onExpression(operand);
        if (expression instanceof Literal)
            return new Literal((0, util_1.str)(expression.val));
        this.codegen.link('str');
        return new Expression("str(".concat(expression, ")"));
    };
    JsonExpressionCodegen.prototype.onStarts = function (expr) {
        if (expr.length !== 3)
            throw new Error('"starts" operator expects two operands.');
        var _a = tslib_1.__read(expr, 3), a = _a[1], b = _a[2];
        var outer = this.onExpression(a);
        var inner = this.onExpression(b);
        if (outer instanceof Literal && inner instanceof Literal)
            return new Literal((0, util_1.starts)(outer.val, inner.val));
        this.codegen.link('starts');
        return new Expression("starts(".concat(outer, ", ").concat(inner, ")"));
    };
    JsonExpressionCodegen.prototype.onContains = function (expr) {
        if (expr.length !== 3)
            throw new Error('"contains" operator expects two operands.');
        var _a = tslib_1.__read(expr, 3), a = _a[1], b = _a[2];
        var outer = this.onExpression(a);
        var inner = this.onExpression(b);
        if (outer instanceof Literal && inner instanceof Literal)
            return new Literal((0, util_1.contains)(outer.val, inner.val));
        this.codegen.link('contains');
        return new Expression("contains(".concat(outer, ", ").concat(inner, ")"));
    };
    JsonExpressionCodegen.prototype.onEnds = function (expr) {
        if (expr.length !== 3)
            throw new Error('"ends" operator expects two operands.');
        var _a = tslib_1.__read(expr, 3), a = _a[1], b = _a[2];
        var outer = this.onExpression(a);
        var inner = this.onExpression(b);
        if (outer instanceof Literal && inner instanceof Literal)
            return new Literal((0, util_1.ends)(outer.val, inner.val));
        this.codegen.link('ends');
        return new Expression("ends(".concat(outer, ", ").concat(inner, ")"));
    };
    JsonExpressionCodegen.prototype.onMatches = function (expr) {
        if (expr.length !== 3)
            throw new Error('"matches" operator expects two operands.');
        var _a = tslib_1.__read(expr, 3), a = _a[1], pattern = _a[2];
        if (typeof pattern !== 'string')
            throw new Error('"matches" second argument should be a regular expression string.');
        var subject = this.onExpression(a);
        if (!this.options.createPattern)
            throw new Error('"matches" operator requires ".createPattern()" option to be implemented.');
        var fn = this.options.createPattern(pattern);
        if (subject instanceof Literal)
            return new Literal(fn((0, util_1.str)(subject.val)));
        var d = this.codegen.linkDependency(fn);
        this.codegen.link('str');
        return new Expression("".concat(d, "(str(").concat(subject, "))"));
    };
    JsonExpressionCodegen.prototype.onDefined = function (expr) {
        if (expr.length > 2)
            throw new Error('"defined" operator expects one operand.');
        var _a = tslib_1.__read(expr, 2), pointer = _a[1];
        if (typeof pointer !== 'string')
            throw new Error('Invalid JSON pointer.');
        (0, json_pointer_1.validateJsonPointer)(pointer);
        var fn = (0, find_1.$$find)((0, json_pointer_1.toPath)(pointer));
        var d = this.codegen.addConstant(fn);
        return new Expression("".concat(d, "(data) !== undefined"));
    };
    JsonExpressionCodegen.prototype.onIn = function (expr) {
        if (expr.length > 3)
            throw new Error('"in" operator expects two operands.');
        var _a = tslib_1.__read(expr, 3), a = _a[1], b = _a[2];
        var container = this.onExpression(b);
        var what = this.onExpression(a);
        if (container instanceof Literal) {
            if (!(container.val instanceof Array))
                throw new Error('"in" operator expects second operand to be an array.');
            if (what instanceof Literal)
                return new Literal((0, util_1.isInContainer)(what.val, container.val));
            if (container.val.length === 0)
                return new Literal(false);
            if (container.val.length === 1)
                return this.onExpression(['==', a, toBoxed(container.val[0])]);
        }
        this.codegen.link('isInContainer');
        return new Expression("isInContainer(".concat(what, ", ").concat(container, ")"));
    };
    JsonExpressionCodegen.prototype.onCat = function (expr) {
        var _this = this;
        if (expr.length <= 2)
            throw new Error('"cat" operator expects at least two operands.');
        var _a = tslib_1.__read(expr), operands = _a.slice(1);
        var expressions = operands.map(function (operand) { return _this.onExpression(operand); });
        var areAllLiteral = true;
        for (var i = 0; i < expressions.length; i++) {
            var expression = expressions[i];
            if (!(expression instanceof Literal)) {
                areAllLiteral = false;
                break;
            }
        }
        if (areAllLiteral)
            return new Literal(expressions.map(function (expr) { return (0, util_1.str)(expr.val); }).join(''));
        this.codegen.link('str');
        var params = expressions.map(function (expr) { return "str(".concat(expr, ")"); });
        return new Expression(params.join(' + '));
    };
    JsonExpressionCodegen.prototype.onSubstr = function (expr) {
        if (expr.length < 3 || expr.length > 4)
            throw new Error('"substr" operator expects two or three operands.');
        var str = this.onExpression(expr[1]);
        var from = this.onExpression(expr[2]);
        var length = expr[3] ? this.onExpression(expr[3]) : new Literal(0);
        if (str instanceof Literal && from instanceof Literal && length instanceof Literal)
            return new Literal((0, util_1.substr)(str.val, from.val, length.val));
        this.codegen.link('substr');
        return new Expression("substr(".concat(str, ", ").concat(from, ", ").concat(length, ")"));
    };
    JsonExpressionCodegen.prototype.onLessThan = function (expr) {
        if (expr.length !== 3)
            throw new Error('"<" operator expects two operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal((0, util_1.num)(a.val) < (0, util_1.num)(b.val));
        return new Expression("(+(".concat(a, ")||0) < (+(").concat(b, ")||0)"));
    };
    JsonExpressionCodegen.prototype.onLessThanOrEqual = function (expr) {
        if (expr.length !== 3)
            throw new Error('"<=" operator expects two operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal((0, util_1.num)(a.val) <= (0, util_1.num)(b.val));
        return new Expression("(+(".concat(a, ")||0) <= (+(").concat(b, ")||0)"));
    };
    JsonExpressionCodegen.prototype.onGreaterThan = function (expr) {
        if (expr.length !== 3)
            throw new Error('">" operator expects two operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal((0, util_1.num)(a.val) > (0, util_1.num)(b.val));
        return new Expression("(+(".concat(a, ")||0) > (+(").concat(b, ")||0)"));
    };
    JsonExpressionCodegen.prototype.onGreaterThanOrEqual = function (expr) {
        if (expr.length !== 3)
            throw new Error('">=" operator expects two operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal((0, util_1.num)(a.val) >= (0, util_1.num)(b.val));
        return new Expression("(+(".concat(a, ")||0) >= (+(").concat(b, ")||0)"));
    };
    JsonExpressionCodegen.prototype.onBetweenNeNe = function (expr) {
        if (expr.length !== 4)
            throw new Error('"><" operator expects three operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        var c = this.onExpression(expr[3]);
        if (a instanceof Literal && b instanceof Literal && c instanceof Literal)
            return new Literal((0, util_1.betweenNeNe)((0, util_1.num)(a.val), (0, util_1.num)(b.val), (0, util_1.num)(c.val)));
        this.codegen.link('betweenNeNe');
        return new Expression("betweenNeNe((+(".concat(a, ")||0), (+(").concat(b, ")||0), (+(").concat(c, ")||0))"));
    };
    JsonExpressionCodegen.prototype.onBetweenEqNe = function (expr) {
        if (expr.length !== 4)
            throw new Error('"=><" operator expects three operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        var c = this.onExpression(expr[3]);
        if (a instanceof Literal && b instanceof Literal && c instanceof Literal)
            return new Literal((0, util_1.betweenEqNe)((0, util_1.num)(a.val), (0, util_1.num)(b.val), (0, util_1.num)(c.val)));
        this.codegen.link('betweenEqNe');
        return new Expression("betweenEqNe((+(".concat(a, ")||0), (+(").concat(b, ")||0), (+(").concat(c, ")||0))"));
    };
    JsonExpressionCodegen.prototype.onBetweenNeEq = function (expr) {
        if (expr.length !== 4)
            throw new Error('"><=" operator expects three operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        var c = this.onExpression(expr[3]);
        if (a instanceof Literal && b instanceof Literal && c instanceof Literal)
            return new Literal((0, util_1.betweenNeEq)((0, util_1.num)(a.val), (0, util_1.num)(b.val), (0, util_1.num)(c.val)));
        this.codegen.link('betweenNeEq');
        return new Expression("betweenNeEq((+(".concat(a, ")||0), (+(").concat(b, ")||0), (+(").concat(c, ")||0))"));
    };
    JsonExpressionCodegen.prototype.onBetweenEqEq = function (expr) {
        if (expr.length !== 4)
            throw new Error('"=><=" operator expects three operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        var c = this.onExpression(expr[3]);
        if (a instanceof Literal && b instanceof Literal && c instanceof Literal)
            return new Literal((0, util_1.betweenEqEq)((0, util_1.num)(a.val), (0, util_1.num)(b.val), (0, util_1.num)(c.val)));
        this.codegen.link('betweenEqEq');
        return new Expression("betweenEqEq((+(".concat(a, ")||0), (+(").concat(b, ")||0), (+(").concat(c, ")||0))"));
    };
    JsonExpressionCodegen.prototype.onMin = function (expr) {
        var _this = this;
        if (expr.length < 3)
            throw new Error('"min" operator expects at least two operands.');
        var expressions = expr.slice(1).map(function (operand) { return _this.onExpression(operand); });
        var allLiterals = expressions.every(function (expr) { return expr instanceof Literal; });
        if (allLiterals)
            return new Literal((0, util_1.num)(Math.min.apply(Math, tslib_1.__spreadArray([], tslib_1.__read(expressions.map(function (expr) { return expr.val; })), false))));
        var params = expressions.map(function (expr) { return "".concat(expr); });
        return new Expression("+Math.min(".concat(params.join(', '), ") || 0"));
    };
    JsonExpressionCodegen.prototype.onMax = function (expr) {
        var _this = this;
        if (expr.length < 3)
            throw new Error('"max" operator expects at least two operands.');
        var expressions = expr.slice(1).map(function (operand) { return _this.onExpression(operand); });
        var allLiterals = expressions.every(function (expr) { return expr instanceof Literal; });
        if (allLiterals)
            return new Literal((0, util_1.num)(Math.max.apply(Math, tslib_1.__spreadArray([], tslib_1.__read(expressions.map(function (expr) { return expr.val; })), false))));
        var params = expressions.map(function (expr) { return "".concat(expr); });
        return new Expression("+Math.max(".concat(params.join(', '), ") || 0"));
    };
    JsonExpressionCodegen.prototype.onPlus = function (expr) {
        var _this = this;
        if (expr.length < 3)
            throw new Error('"+" operator expects at least two operands.');
        var expressions = expr.slice(1).map(function (operand) { return _this.onExpression(operand); });
        var allLiterals = expressions.every(function (expr) { return expr instanceof Literal; });
        if (allLiterals)
            return new Literal(expressions.reduce(function (a, b) { return a + (0, util_1.num)(b.val); }, 0));
        var params = expressions.map(function (expr) { return "(+(".concat(expr, ")||0)"); });
        return new Expression("".concat(params.join(' + ')));
    };
    JsonExpressionCodegen.prototype.onMinus = function (expr) {
        var _this = this;
        if (expr.length < 3)
            throw new Error('"-" operator expects at least two operands.');
        var expressions = expr.slice(1).map(function (operand) { return _this.onExpression(operand); });
        var allLiterals = expressions.every(function (expr) { return expr instanceof Literal; });
        if (allLiterals)
            return new Literal(expressions.slice(1).reduce(function (a, b) { return a - (0, util_1.num)(b.val); }, (0, util_1.num)(expressions[0].val)));
        var params = expressions.map(function (expr) { return "(+(".concat(expr, ")||0)"); });
        return new Expression("".concat(params.join(' - ')));
    };
    JsonExpressionCodegen.prototype.onAsterisk = function (expr) {
        var _this = this;
        if (expr.length < 3)
            throw new Error('"*" operator expects at least two operands.');
        var expressions = expr.slice(1).map(function (operand) { return _this.onExpression(operand); });
        var allLiterals = expressions.every(function (expr) { return expr instanceof Literal; });
        if (allLiterals)
            return new Literal(expressions.reduce(function (a, b) { return a * (0, util_1.num)(b.val); }, 1));
        var params = expressions.map(function (expr) { return "(+(".concat(expr, ")||0)"); });
        return new Expression("".concat(params.join(' * ')));
    };
    JsonExpressionCodegen.prototype.onSlash = function (expr) {
        if (expr.length !== 3)
            throw new Error('"/" operator expects two operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal((0, util_1.slash)(a.val, b.val));
        this.codegen.link('slash');
        return new Expression("slash(".concat(a, ", ").concat(b, ")"));
    };
    JsonExpressionCodegen.prototype.onMod = function (expr) {
        if (expr.length !== 3)
            throw new Error('"%" operator expects two operands.');
        var a = this.onExpression(expr[1]);
        var b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal((0, util_1.num)(a.val % b.val));
        return new Expression("+(".concat(a, " % ").concat(b, ") || 0"));
    };
    JsonExpressionCodegen.prototype.onRound = function (expr) {
        if (expr.length !== 2)
            throw new Error('"round" operator expects one operand.');
        var a = this.onExpression(expr[1]);
        if (a instanceof Literal)
            return new Literal(Math.round((0, util_1.num)(a.val)));
        return new Expression("Math.round(+(".concat(a, ") || 0)"));
    };
    JsonExpressionCodegen.prototype.onCeil = function (expr) {
        if (expr.length !== 2)
            throw new Error('"ceil" operator expects one operand.');
        var a = this.onExpression(expr[1]);
        if (a instanceof Literal)
            return new Literal(Math.ceil((0, util_1.num)(a.val)));
        return new Expression("Math.ceil(+(".concat(a, ") || 0)"));
    };
    JsonExpressionCodegen.prototype.onFloor = function (expr) {
        if (expr.length !== 2)
            throw new Error('"floor" operator expects one operand.');
        var a = this.onExpression(expr[1]);
        if (a instanceof Literal)
            return new Literal(Math.floor((0, util_1.num)(a.val)));
        return new Expression("Math.floor(+(".concat(a, ") || 0)"));
    };
    JsonExpressionCodegen.prototype.onExpression = function (expr) {
        if (!isExpression(expr)) {
            if (expr instanceof Array) {
                if (expr.length !== 1 || !(expr[0] instanceof Array))
                    throw new Error('Expected array literal to be boxed as single array element.');
                return new Literal(expr[0]);
            }
            else
                return new Literal(expr);
        }
        switch (expr[0]) {
            case '=':
            case 'get':
                return this.onGet(expr);
            case '==':
            case 'eq':
                return this.onEquals(expr);
            case '!=':
            case 'ne':
                return this.onNotEquals(expr);
            case '?':
            case 'if':
                return this.onIf(expr);
            case '&&':
            case 'and':
                return this.onAnd(expr);
            case '||':
            case 'or':
                return this.onOr(expr);
            case '!':
            case 'not':
                return this.onNot(expr);
            case 'type':
                return this.onType(expr);
            case 'bool':
                return this.onBool(expr);
            case 'num':
                return this.onNum(expr);
            case 'int':
                return this.onInt(expr);
            case 'str':
                return this.onStr(expr);
            case 'starts':
                return this.onStarts(expr);
            case 'contains':
                return this.onContains(expr);
            case 'ends':
                return this.onEnds(expr);
            case 'matches':
                return this.onMatches(expr);
            case 'defined':
                return this.onDefined(expr);
            case 'in':
                return this.onIn(expr);
            case '.':
            case 'cat':
                return this.onCat(expr);
            case 'substr':
                return this.onSubstr(expr);
            case '<':
                return this.onLessThan(expr);
            case '<=':
                return this.onLessThanOrEqual(expr);
            case '>':
                return this.onGreaterThan(expr);
            case '>=':
                return this.onGreaterThanOrEqual(expr);
            case '><':
                return this.onBetweenNeNe(expr);
            case '=><':
                return this.onBetweenEqNe(expr);
            case '><=':
                return this.onBetweenNeEq(expr);
            case '=><=':
                return this.onBetweenEqEq(expr);
            case 'min':
                return this.onMin(expr);
            case 'max':
                return this.onMax(expr);
            case '+':
                return this.onPlus(expr);
            case '-':
                return this.onMinus(expr);
            case '*':
                return this.onAsterisk(expr);
            case '/':
                return this.onSlash(expr);
            case '%':
            case 'mod':
                return this.onMod(expr);
            case 'round':
                return this.onRound(expr);
            case 'ceil':
                return this.onCeil(expr);
            case 'floor':
                return this.onFloor(expr);
        }
        return new Literal(false);
    };
    JsonExpressionCodegen.prototype.run = function () {
        var expr = this.onExpression(this.options.expression);
        this.codegen.js("return ".concat(expr, ";"));
        return this;
    };
    JsonExpressionCodegen.prototype.generate = function () {
        return this.codegen.generate();
    };
    JsonExpressionCodegen.prototype.compile = function () {
        return this.codegen.compile();
    };
    return JsonExpressionCodegen;
}());
exports.JsonExpressionCodegen = JsonExpressionCodegen;
