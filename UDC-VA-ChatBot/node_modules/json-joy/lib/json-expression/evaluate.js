"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluate = void 0;
var tslib_1 = require("tslib");
var deepEqual_1 = require("../json-equal/deepEqual");
var json_pointer_1 = require("../json-pointer");
var util_1 = require("./util");
var toNumber = util_1.num;
var evaluate = function (expr, ctx) {
    if (!(expr instanceof Array))
        return expr;
    if (expr.length === 1 && expr[0] instanceof Array)
        return expr[0];
    var fn = expr[0];
    switch (fn) {
        case '=':
        case 'get': {
            var pointer = (0, exports.evaluate)(expr[1], ctx);
            if (expr[2] !== undefined && !(0, util_1.isLiteral)(expr[2]))
                throw new Error('"get" operator expects a default value to be a literal.');
            var def = (0, exports.evaluate)(expr[2], ctx);
            if (typeof pointer !== 'string')
                throw new Error('Invalid JSON pointer.');
            (0, json_pointer_1.validateJsonPointer)(pointer);
            return (0, util_1.throwOnUndef)((0, json_pointer_1.get)(ctx.data, (0, json_pointer_1.toPath)(pointer)), def);
        }
        case '==':
        case 'eq': {
            var left = (0, exports.evaluate)(expr[1], ctx);
            var right = (0, exports.evaluate)(expr[2], ctx);
            return (0, deepEqual_1.deepEqual)(left, right);
        }
        case 'in': {
            var v2 = (0, exports.evaluate)(expr[2], ctx);
            if (!(v2 instanceof Array) || !v2.length)
                return false;
            var v1_1 = (0, exports.evaluate)(expr[1], ctx);
            return v2.some(function (item) { return (0, deepEqual_1.deepEqual)(item, v1_1); });
        }
        case '!=':
        case 'ne': {
            var left = (0, exports.evaluate)(expr[1], ctx);
            var right = (0, exports.evaluate)(expr[2], ctx);
            return !(0, deepEqual_1.deepEqual)(left, right);
        }
        case '?':
        case 'if': {
            return (0, exports.evaluate)(expr[1], ctx) ? (0, exports.evaluate)(expr[2], ctx) : (0, exports.evaluate)(expr[3], ctx);
        }
        case '&&':
        case 'and':
            return expr.slice(1).every(function (e) { return (0, exports.evaluate)(e, ctx); });
        case '||':
        case 'or':
            return expr.slice(1).some(function (e) { return (0, exports.evaluate)(e, ctx); });
        case '!':
        case 'not':
            return !(0, exports.evaluate)(expr[1], ctx);
        case 'type':
            return (0, util_1.type)((0, exports.evaluate)(expr[1], ctx));
        case 'defined': {
            var pointer = (0, exports.evaluate)(expr[1], ctx);
            if (typeof pointer !== 'string')
                throw new Error('Invalid JSON pointer.');
            (0, json_pointer_1.validateJsonPointer)(pointer);
            var value = (0, json_pointer_1.get)(ctx.data, (0, json_pointer_1.toPath)(pointer));
            return value !== undefined;
        }
        case 'bool':
            return !!(0, exports.evaluate)(expr[1], ctx);
        case 'num':
            return toNumber((0, exports.evaluate)(expr[1], ctx));
        case 'int':
            return ~~(0, exports.evaluate)(expr[1], ctx);
        case 'str':
            return (0, util_1.str)((0, exports.evaluate)(expr[1], ctx));
        case 'starts': {
            var subject = (0, exports.evaluate)(expr[1], ctx);
            var test_1 = (0, exports.evaluate)(expr[2], ctx);
            return (0, util_1.starts)(subject, test_1);
        }
        case 'contains': {
            var subject = (0, exports.evaluate)(expr[1], ctx);
            var test_2 = (0, exports.evaluate)(expr[2], ctx);
            return (0, util_1.contains)(subject, test_2);
        }
        case 'ends': {
            var subject = (0, exports.evaluate)(expr[1], ctx);
            var test_3 = (0, exports.evaluate)(expr[2], ctx);
            return (0, util_1.ends)(subject, test_3);
        }
        case 'cat':
        case '.': {
            return expr
                .slice(1)
                .map(function (e) { return (0, exports.evaluate)(e, ctx); })
                .join('');
        }
        case 'substr': {
            var str2 = (0, util_1.str)((0, exports.evaluate)(expr[1], ctx));
            var from = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            var length_1 = expr.length > 3 ? (0, util_1.num)((0, exports.evaluate)(expr[3], ctx)) : undefined;
            return str2.substr(from, length_1);
        }
        case 'matches': {
            var _a = tslib_1.__read(expr, 3), a = _a[1], pattern = _a[2];
            if (typeof pattern !== 'string')
                throw new Error('"matches" second argument should be a regular expression string.');
            if (!ctx.createPattern)
                throw new Error('"matches" operator requires ".createPattern()" option to be implemented.');
            var subject = (0, exports.evaluate)(a, ctx);
            var fn_1 = ctx.createPattern(pattern);
            return fn_1((0, util_1.str)(subject));
        }
        case '<': {
            var left = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            var right = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            return left < right;
        }
        case '<=': {
            var left = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            var right = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            return left <= right;
        }
        case '>': {
            var left = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            var right = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            return left > right;
        }
        case '>=': {
            var left = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            var right = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            return left >= right;
        }
        case '><': {
            var val = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            var min = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            var max = (0, util_1.num)((0, exports.evaluate)(expr[3], ctx));
            return (0, util_1.betweenNeNe)(val, min, max);
        }
        case '=><': {
            var val = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            var min = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            var max = (0, util_1.num)((0, exports.evaluate)(expr[3], ctx));
            return (0, util_1.betweenEqNe)(val, min, max);
        }
        case '><=': {
            var val = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            var min = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            var max = (0, util_1.num)((0, exports.evaluate)(expr[3], ctx));
            return (0, util_1.betweenNeEq)(val, min, max);
        }
        case '=><=': {
            var val = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            var min = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            var max = (0, util_1.num)((0, exports.evaluate)(expr[3], ctx));
            return (0, util_1.betweenEqEq)(val, min, max);
        }
        case 'min': {
            return Math.min.apply(Math, tslib_1.__spreadArray([], tslib_1.__read(expr.slice(1).map(function (e) { return (0, util_1.num)((0, exports.evaluate)(e, ctx)); })), false));
        }
        case 'max': {
            return Math.max.apply(Math, tslib_1.__spreadArray([], tslib_1.__read(expr.slice(1).map(function (e) { return (0, util_1.num)((0, exports.evaluate)(e, ctx)); })), false));
        }
        case '+': {
            return expr.slice(1).reduce(function (acc, e) { return (0, util_1.num)((0, exports.evaluate)(e, ctx)) + acc; }, 0);
        }
        case '-': {
            return expr.slice(2).reduce(function (acc, e) { return acc - (0, util_1.num)((0, exports.evaluate)(e, ctx)); }, (0, util_1.num)((0, exports.evaluate)(expr[1], ctx)));
        }
        case '*': {
            return expr.slice(1).reduce(function (acc, e) { return (0, util_1.num)((0, exports.evaluate)(e, ctx)) * acc; }, 1);
        }
        case '/': {
            return (0, util_1.slash)((0, exports.evaluate)(expr[1], ctx), (0, exports.evaluate)(expr[2], ctx));
        }
        case '%': {
            return (0, util_1.num)((0, exports.evaluate)(expr[1], ctx) % (0, exports.evaluate)(expr[2], ctx));
        }
        case 'round': {
            return Math.round((0, util_1.num)((0, exports.evaluate)(expr[1], ctx)));
        }
        case 'ceil': {
            return Math.ceil((0, util_1.num)((0, exports.evaluate)(expr[1], ctx)));
        }
        case 'floor': {
            return Math.floor((0, util_1.num)((0, exports.evaluate)(expr[1], ctx)));
        }
    }
    throw new Error('Unknown expression.');
};
exports.evaluate = evaluate;
