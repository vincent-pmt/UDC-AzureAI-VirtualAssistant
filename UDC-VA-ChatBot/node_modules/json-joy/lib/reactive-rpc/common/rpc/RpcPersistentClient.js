"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcPersistentClient = void 0;
var tslib_1 = require("tslib");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var StreamingRpcClient_1 = require("./client/StreamingRpcClient");
var ApiRpcCaller_1 = require("./caller/ApiRpcCaller");
var RpcDuplex_1 = require("../rpc/RpcDuplex");
var RpcMessageStreamProcessor_1 = require("./RpcMessageStreamProcessor");
var channel_1 = require("../channel");
var RpcPersistentClient = (function () {
    function RpcPersistentClient(params) {
        var _this = this;
        var _a;
        this.rpc$ = new rxjs_1.ReplaySubject(1);
        var ping = (_a = params.ping) !== null && _a !== void 0 ? _a : 15000;
        var codec = params.codec;
        var textEncoder = new TextEncoder();
        this.channel = new channel_1.PersistentChannel(params.channel);
        this.channel.open$.pipe((0, operators_1.filter)(function (open) { return open; })).subscribe(function () {
            var close$ = _this.channel.open$.pipe((0, operators_1.filter)(function (open) { return !open; }));
            var duplex = new RpcDuplex_1.RpcDuplex({
                client: new StreamingRpcClient_1.StreamingRpcClient(tslib_1.__assign(tslib_1.__assign({}, (params.client || {})), { send: function (messages) {
                        var encoded = codec.encode(messages);
                        _this.channel.send$(encoded).subscribe();
                    } })),
                server: new RpcMessageStreamProcessor_1.RpcMessageStreamProcessor(tslib_1.__assign(tslib_1.__assign({}, (params.server || {
                    caller: new ApiRpcCaller_1.ApiRpcCaller({
                        api: {},
                    }),
                    onNotification: function () { },
                })), { send: function (messages) {
                        var encoded = codec.encode(messages);
                        _this.channel.send$(encoded).subscribe();
                    } })),
            });
            _this.channel.message$.pipe((0, operators_1.takeUntil)(close$)).subscribe(function (data) {
                var encoded = typeof data === 'string' ? textEncoder.encode(data) : new Uint8Array(data);
                var messages = codec.decode(encoded);
                duplex.onMessages((messages instanceof Array ? messages : [messages]), {});
            });
            if (ping) {
                (0, rxjs_1.timer)(ping, ping)
                    .pipe((0, operators_1.takeUntil)(close$))
                    .subscribe(function () {
                    duplex.notify('.ping', undefined);
                });
            }
            if (_this.rpc)
                _this.rpc.disconnect();
            _this.rpc = duplex;
            _this.rpc$.next(duplex);
        });
    }
    RpcPersistentClient.prototype.call$ = function (method, data) {
        return this.rpc$.pipe((0, operators_1.first)(), (0, operators_1.switchMap)(function (rpc) { return rpc.call$(method, data); }), (0, operators_1.share)());
    };
    RpcPersistentClient.prototype.call = function (method, data) {
        return (0, rxjs_1.firstValueFrom)(this.call$(method, data));
    };
    RpcPersistentClient.prototype.notify = function (method, data) {
        this.rpc$.subscribe(function (rpc) { return rpc.notify(method, data); });
    };
    RpcPersistentClient.prototype.start = function () {
        this.channel.start();
    };
    RpcPersistentClient.prototype.stop = function () {
        this.channel.stop();
        if (this.rpc)
            this.rpc.stop();
    };
    return RpcPersistentClient;
}());
exports.RpcPersistentClient = RpcPersistentClient;
