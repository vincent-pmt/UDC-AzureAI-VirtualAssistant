"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcMessageStreamProcessor = void 0;
var tslib_1 = require("tslib");
var msg = tslib_1.__importStar(require("../messages"));
var subscribeCompleteObserver_1 = require("../util/subscribeCompleteObserver");
var TimedQueue_1 = require("../util/TimedQueue");
var error_1 = require("./caller/error");
var RpcMessageStreamProcessor = (function () {
    function RpcMessageStreamProcessor(_a) {
        var caller = _a.caller, send = _a.send, _b = _a.bufferSize, bufferSize = _b === void 0 ? 10 : _b, _c = _a.bufferTime, bufferTime = _c === void 0 ? 1 : _c;
        var _this = this;
        this.activeStreamCalls = new Map();
        this.onStreamError = function (id, error) {
            _this.sendErrorMessage(id, error);
            _this.activeStreamCalls.delete(id);
        };
        this.caller = caller;
        this.onSend = send;
        if (bufferTime) {
            var buffer_1 = new TimedQueue_1.TimedQueue();
            buffer_1.itemLimit = bufferSize;
            buffer_1.timeLimit = bufferTime;
            buffer_1.onFlush = function (messages) { return _this.onSend(messages); };
            this.send = function (message) {
                buffer_1.push(message);
            };
        }
        else {
            this.send = function (message) {
                _this.onSend([message]);
            };
        }
    }
    RpcMessageStreamProcessor.prototype.onMessage = function (message, ctx) {
        try {
            if (message instanceof msg.RequestDataMessage)
                this.onRequestDataMessage(message, ctx);
            else if (message instanceof msg.RequestCompleteMessage)
                this.onRequestCompleteMessage(message, ctx);
            else if (message instanceof msg.RequestErrorMessage)
                this.onRequestErrorMessage(message, ctx);
            else if (message instanceof msg.NotificationMessage)
                this.onNotificationMessage(message, ctx);
            else if (message instanceof msg.ResponseUnsubscribeMessage)
                this.onUnsubscribeMessage(message);
        }
        catch (error) {
            this.sendNotification('.err', error_1.RpcError.valueFrom(error));
        }
    };
    RpcMessageStreamProcessor.prototype.onMessages = function (messages, ctx) {
        var length = messages.length;
        for (var i = 0; i < length; i++)
            this.onMessage(messages[i], ctx);
    };
    RpcMessageStreamProcessor.prototype.sendNotification = function (method, value) {
        var message = new msg.NotificationMessage(method, value);
        this.send(message);
    };
    RpcMessageStreamProcessor.prototype.sendCompleteMessage = function (id, value) {
        var message = new msg.ResponseCompleteMessage(id, value);
        this.send(message);
    };
    RpcMessageStreamProcessor.prototype.sendDataMessage = function (id, value) {
        var message = new msg.ResponseDataMessage(id, value);
        this.send(message);
    };
    RpcMessageStreamProcessor.prototype.sendErrorMessage = function (id, value) {
        var message = new msg.ResponseErrorMessage(id, value);
        this.send(message);
    };
    RpcMessageStreamProcessor.prototype.sendUnsubscribeMessage = function (id) {
        var message = new msg.RequestUnsubscribeMessage(id);
        this.send(message);
    };
    RpcMessageStreamProcessor.prototype.execStaticCall = function (id, name, request, ctx) {
        var _this = this;
        this.caller
            .call(name, request, ctx)
            .then(function (value) { return _this.sendCompleteMessage(id, value); })
            .catch(function (value) { return _this.sendErrorMessage(id, value); });
    };
    RpcMessageStreamProcessor.prototype.stop = function (reason) {
        var e_1, _a;
        if (reason === void 0) { reason = error_1.RpcErrorCodes.STOP; }
        this.send = (function () { });
        try {
            for (var _b = tslib_1.__values(this.activeStreamCalls.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var call = _c.value;
                call.req$.error(error_1.RpcError.valueFromCode(reason));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.activeStreamCalls.clear();
    };
    RpcMessageStreamProcessor.prototype.disconnect = function () {
        this.stop(error_1.RpcErrorCodes.DISCONNECT);
    };
    RpcMessageStreamProcessor.prototype.sendError = function (id, code) {
        var data = error_1.RpcError.valueFromCode(code);
        this.sendErrorMessage(id, data);
    };
    RpcMessageStreamProcessor.prototype.createStreamCall = function (id, name, ctx) {
        var _this = this;
        var call = this.caller.createCall(name, ctx);
        this.activeStreamCalls.set(id, call);
        (0, subscribeCompleteObserver_1.subscribeCompleteObserver)(call.res$, {
            next: function (value) { return _this.sendDataMessage(id, value); },
            error: function (error) { return _this.onStreamError(id, error); },
            complete: function (value) {
                _this.activeStreamCalls.delete(id);
                _this.sendCompleteMessage(id, value);
            },
        });
        call.reqUnsubscribe$.subscribe(function () {
            if (_this.activeStreamCalls.has(id))
                _this.sendUnsubscribeMessage(id);
        });
        return call;
    };
    RpcMessageStreamProcessor.prototype.onRequestDataMessage = function (message, ctx) {
        var id = message.id, method = message.method, value = message.value;
        var call = this.activeStreamCalls.get(id);
        if (!call) {
            if (!method) {
                this.sendError(id, error_1.RpcErrorCodes.NO_METHOD_SPECIFIED);
                return;
            }
            var info = this.caller.info(method);
            if (!info) {
                this.sendError(id, error_1.RpcErrorCodes.METHOD_NOT_FOUND);
                return;
            }
            if (info.isStreaming) {
                call = this.createStreamCall(id, method, ctx);
            }
            else {
                this.execStaticCall(id, method, value ? value.data : undefined, ctx);
                return;
            }
        }
        if (call) {
            var data = value ? value.data : undefined;
            if (data !== undefined) {
                call.req$.next(data);
            }
        }
    };
    RpcMessageStreamProcessor.prototype.onRequestCompleteMessage = function (message, ctx) {
        var id = message.id, method = message.method, value = message.value;
        var call = this.activeStreamCalls.get(id);
        if (call) {
            var req$ = call.req$;
            var data_1 = value ? value.data : undefined;
            if (data_1 !== undefined)
                req$.next(data_1);
            req$.complete();
            return;
        }
        if (!method) {
            this.sendError(id, error_1.RpcErrorCodes.NO_METHOD_SPECIFIED);
            return;
        }
        var caller = this.caller;
        if (!caller.exists(method)) {
            this.sendError(id, error_1.RpcErrorCodes.METHOD_NOT_FOUND);
            return;
        }
        var isStreaming = caller.info(method).isStreaming;
        var data = value ? value.data : undefined;
        if (isStreaming) {
            var newCall = this.createStreamCall(id, method, ctx);
            if (newCall) {
                if (data !== undefined) {
                    newCall.req$.next(data);
                    newCall.req$.complete();
                }
            }
        }
        else
            this.execStaticCall(id, method, data, ctx);
    };
    RpcMessageStreamProcessor.prototype.onRequestErrorMessage = function (message, ctx) {
        var id = message.id, method = message.method, value = message.value;
        var call = this.activeStreamCalls.get(id);
        if (call)
            return call.req$.error(value.data);
        if (!method)
            return this.sendError(id, error_1.RpcErrorCodes.NO_METHOD_SPECIFIED);
        if (!this.caller.exists(method))
            return this.sendError(id, error_1.RpcErrorCodes.METHOD_NOT_FOUND);
        var isStreaming = this.caller.info(method).isStreaming;
        if (!isStreaming)
            return this.sendError(id, error_1.RpcErrorCodes.INVALID_METHOD);
        var streamCall = this.createStreamCall(id, method, ctx);
        if (!streamCall)
            return;
        streamCall.req$.error(value.data);
    };
    RpcMessageStreamProcessor.prototype.onUnsubscribeMessage = function (message) {
        var id = message.id;
        var call = this.activeStreamCalls.get(id);
        if (!call)
            return;
        this.activeStreamCalls.delete(id);
        call.req$.complete();
    };
    RpcMessageStreamProcessor.prototype.onNotificationMessage = function (message, ctx) {
        var method = message.method, value = message.value;
        if (!method || method.length > 128)
            throw error_1.RpcError.fromCode(error_1.RpcErrorCodes.INVALID_METHOD);
        this.caller.notification(method, value.data, ctx).catch(function (error) { });
    };
    return RpcMessageStreamProcessor;
}());
exports.RpcMessageStreamProcessor = RpcMessageStreamProcessor;
