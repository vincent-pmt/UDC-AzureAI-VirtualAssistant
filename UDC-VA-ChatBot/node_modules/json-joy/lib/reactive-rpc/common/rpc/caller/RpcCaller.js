"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcCaller = void 0;
var tslib_1 = require("tslib");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var BufferSubject_1 = require("../../../../util/rx/BufferSubject");
var error_1 = require("./error");
var Value_1 = require("../../messages/Value");
var StaticRpcMethod_1 = require("../methods/StaticRpcMethod");
var INVALID_REQUEST_ERROR_VALUE = error_1.RpcError.value(error_1.RpcError.invalidRequest());
var RpcCaller = (function () {
    function RpcCaller(_a) {
        var getMethod = _a.getMethod, _b = _a.preCallBufferSize, preCallBufferSize = _b === void 0 ? 10 : _b;
        this.getMethod = getMethod;
        this.preCallBufferSize = preCallBufferSize;
    }
    RpcCaller.prototype.exists = function (name) {
        return !!this.getMethod(name);
    };
    RpcCaller.prototype.getMethodStrict = function (name) {
        var method = this.getMethod(name);
        if (!method)
            throw error_1.RpcError.valueFromCode(error_1.RpcErrorCodes.METHOD_NOT_FOUND);
        return method;
    };
    RpcCaller.prototype.info = function (name) {
        return this.getMethodStrict(name);
    };
    RpcCaller.prototype.validate = function (method, request) {
        try {
            if (method.validate) {
                var errors = method.validate(request);
                if (errors)
                    throw errors;
            }
        }
        catch (error) {
            throw this.wrapValidationError(error);
        }
    };
    RpcCaller.prototype.wrapValidationError = function (error) {
        return error_1.RpcError.valueFrom(error, INVALID_REQUEST_ERROR_VALUE);
    };
    RpcCaller.prototype.call = function (name, request, ctx) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var method, data, error_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = this.getMethodStrict(name);
                        this.validate(method, request);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        if (!method.onPreCall) return [3, 3];
                        return [4, method.onPreCall(ctx, request)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4, method.call(request, ctx)];
                    case 4:
                        data = _a.sent();
                        return [2, new Value_1.Value(data, method.res)];
                    case 5:
                        error_2 = _a.sent();
                        throw error_1.RpcError.valueFrom(error_2);
                    case 6: return [2];
                }
            });
        });
    };
    RpcCaller.prototype.notification = function (name, request, ctx) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var method, error_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = this.getMethodStrict(name);
                        if (!(method instanceof StaticRpcMethod_1.StaticRpcMethod))
                            return [2];
                        if (!method.acceptsNotifications)
                            return [2];
                        this.validate(method, request);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        if (!method.onPreCall) return [3, 3];
                        return [4, method.onPreCall(ctx, request)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4, method.call(request, ctx)];
                    case 4:
                        _a.sent();
                        return [3, 6];
                    case 5:
                        error_3 = _a.sent();
                        throw error_1.RpcError.valueFrom(error_3);
                    case 6: return [2];
                }
            });
        });
    };
    RpcCaller.prototype.createCall = function (name, ctx) {
        var _this = this;
        var req$ = new rxjs_1.Subject();
        var reqUnsubscribe$ = new rxjs_1.Subject();
        try {
            var method_1 = this.getMethodStrict(name);
            if (!method_1.isStreaming) {
                var response$ = (0, rxjs_1.from)((function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    var request;
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, (0, rxjs_1.firstValueFrom)(req$.pipe((0, operators_1.first)()))];
                            case 1:
                                request = _a.sent();
                                return [4, this.call(name, request, ctx)];
                            case 2: return [2, _a.sent()];
                        }
                    });
                }); })());
                var res$ = new rxjs_1.Subject();
                response$.subscribe(res$);
                var $resWithErrorsFormatted_1 = res$.pipe((0, operators_1.catchError)(function (error) {
                    throw error_1.RpcError.valueFrom(error);
                }));
                return { req$: req$, reqUnsubscribe$: reqUnsubscribe$, res$: $resWithErrorsFormatted_1 };
            }
            var methodStreaming_1 = method_1;
            var requestValidated$ = req$.pipe((0, operators_1.tap)(function (request) {
                _this.validate(methodStreaming_1, request);
            }));
            var bufferSize = methodStreaming_1.preCallBufferSize || this.preCallBufferSize;
            var requestBuffered$_1 = new BufferSubject_1.BufferSubject(bufferSize);
            var error$_1 = new rxjs_1.Subject();
            requestBuffered$_1.subscribe({
                error: function (error) {
                    error$_1.error(error);
                },
            });
            requestValidated$.subscribe(requestBuffered$_1);
            var methodResponseType_1 = method_1.res;
            var result$ = requestBuffered$_1.pipe((0, operators_1.take)(1), (0, operators_1.switchMap)(function (request) {
                return methodStreaming_1.onPreCall ? (0, rxjs_1.from)(methodStreaming_1.onPreCall(ctx, request)) : (0, rxjs_1.from)([0]);
            }), (0, operators_1.switchMap)(function () {
                Promise.resolve().then(function () {
                    requestBuffered$_1.flush();
                });
                return method_1.call$(requestBuffered$_1, ctx).pipe((0, operators_1.map)(function (response) { return new Value_1.Value(response, methodResponseType_1); }), (0, operators_1.finalize)(function () {
                    error$_1.complete();
                }));
            }), (0, operators_1.share)(), (0, operators_1.mergeWith)(error$_1));
            var $resWithErrorsFormatted = result$.pipe((0, operators_1.finalize)(function () {
                error$_1.complete();
            }), (0, operators_1.catchError)(function (error) {
                throw error_1.RpcError.valueFrom(error);
            }));
            return { req$: req$, reqUnsubscribe$: reqUnsubscribe$, res$: $resWithErrorsFormatted };
        }
        catch (error) {
            var errorFormatted = error_1.RpcError.valueFrom(error);
            req$.error(errorFormatted);
            var res$ = new rxjs_1.Subject();
            res$.error(errorFormatted);
            return { req$: req$, reqUnsubscribe$: reqUnsubscribe$, res$: res$ };
        }
    };
    RpcCaller.prototype.call$ = function (name, request$, ctx) {
        var call = this.createCall(name, ctx);
        request$.subscribe(call.req$);
        return call.res$;
    };
    return RpcCaller;
}());
exports.RpcCaller = RpcCaller;
