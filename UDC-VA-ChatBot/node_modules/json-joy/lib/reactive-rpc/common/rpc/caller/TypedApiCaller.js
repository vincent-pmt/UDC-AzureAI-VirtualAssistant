"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedApiCaller = void 0;
var tslib_1 = require("tslib");
var error_1 = require("./error");
var RpcCaller_1 = require("./RpcCaller");
var classes_1 = require("../../../../json-type/type/classes");
var StaticRpcMethod_1 = require("../methods/StaticRpcMethod");
var StreamingRpcMethod_1 = require("../methods/StreamingRpcMethod");
var TypedApiCaller = (function (_super) {
    tslib_1.__extends(TypedApiCaller, _super);
    function TypedApiCaller(_a) {
        var _this = this;
        var system = _a.system, rest = tslib_1.__rest(_a, ["system"]);
        _this = _super.call(this, tslib_1.__assign(tslib_1.__assign({}, rest), { getMethod: function (name) { return _this.get(name); } })) || this;
        _this.methods = new Map();
        _this.req = null;
        _this.res = null;
        _this.system = system;
        return _this;
    }
    TypedApiCaller.prototype.implement = function (id, definition_) {
        var definition = definition_;
        if (this.methods.has(id))
            throw new Error("Method [id = ".concat(id, "] is already implemented."));
        var alias = this.system.resolve(id);
        var type = alias.type;
        if (!(type instanceof classes_1.FunctionType || type instanceof classes_1.FunctionStreamingType))
            throw new Error("Type [alias = ".concat(alias.id, "] is not a function."));
        var validator = type.validator('boolean');
        var customValidator = definition.validate;
        var validate = customValidator
            ? function (req) {
                var error = validator(req);
                if (error)
                    throw error_1.RpcError.valueFromCode(error_1.RpcErrorCodes.BAD_REQUEST);
                customValidator(req);
            }
            : function (req) {
                var error = validator(req);
                if (error)
                    throw error_1.RpcError.valueFromCode(error_1.RpcErrorCodes.BAD_REQUEST);
            };
        var isStaticMethodAlias = alias.type instanceof classes_1.FunctionType;
        var isStreamingMethodAlias = alias.type instanceof classes_1.FunctionStreamingType;
        var method = isStaticMethodAlias
            ? new StaticRpcMethod_1.StaticRpcMethod(tslib_1.__assign(tslib_1.__assign({}, definition), { req: type.req, res: type.res, validate: validate }))
            : isStreamingMethodAlias
                ? new StreamingRpcMethod_1.StreamingRpcMethod(tslib_1.__assign(tslib_1.__assign({}, definition), { req: type.req, res: type.res, validate: validate }))
                : null;
        if (!method)
            throw new Error("Type [alias = ".concat(alias.id, "] is not a function."));
        this.methods.set(id, method);
    };
    TypedApiCaller.prototype.get = function (id) {
        var method = this.methods.get(id);
        if (!method)
            throw error_1.RpcError.valueFromCode(error_1.RpcErrorCodes.METHOD_NOT_FOUND);
        return method;
    };
    return TypedApiCaller;
}(RpcCaller_1.RpcCaller));
exports.TypedApiCaller = TypedApiCaller;
