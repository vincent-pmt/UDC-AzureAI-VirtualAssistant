"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamingRpcClient = void 0;
var tslib_1 = require("tslib");
var rxjs_1 = require("rxjs");
var msg = tslib_1.__importStar(require("../../messages"));
var subscribeCompleteObserver_1 = require("../../util/subscribeCompleteObserver");
var TimedQueue_1 = require("../../util/TimedQueue");
var Value_1 = require("../../messages/Value");
var StreamingRpcClient = (function () {
    function StreamingRpcClient(_a) {
        var send = _a.send, _b = _a.bufferSize, bufferSize = _b === void 0 ? 100 : _b, _c = _a.bufferTime, bufferTime = _c === void 0 ? 10 : _c;
        this.id = 1;
        this.calls = new Map();
        this.buffer = new TimedQueue_1.TimedQueue();
        this.buffer.itemLimit = bufferSize;
        this.buffer.timeLimit = bufferTime;
        this.buffer.onFlush = send;
    }
    StreamingRpcClient.prototype.getInflightCallCount = function () {
        return this.calls.size;
    };
    StreamingRpcClient.prototype.onMessages = function (messages) {
        var length = messages.length;
        for (var i = 0; i < length; i++)
            this.onMessage(messages[i]);
    };
    StreamingRpcClient.prototype.onMessage = function (message) {
        if (message instanceof msg.ResponseCompleteMessage)
            return this.onResponseComplete(message);
        else if (message instanceof msg.ResponseDataMessage)
            return this.onResponseData(message);
        else if (message instanceof msg.ResponseErrorMessage)
            return this.onResponseError(message);
        return this.onRequestUnsubscribe(message);
    };
    StreamingRpcClient.prototype.onResponseComplete = function (message) {
        var id = message.id, value = message.value;
        var call = this.calls.get(id);
        if (!call)
            return;
        call.resFinalized = true;
        var data = value ? value.data : undefined;
        if (data !== undefined)
            call.res$.next(data);
        call.res$.complete();
    };
    StreamingRpcClient.prototype.onResponseData = function (message) {
        var id = message.id, value = message.value;
        var call = this.calls.get(id);
        if (!call)
            return;
        call.res$.next(value.data);
    };
    StreamingRpcClient.prototype.onResponseError = function (message) {
        var id = message.id, value = message.value;
        var call = this.calls.get(id);
        if (!call)
            return;
        call.resFinalized = true;
        call.res$.error(value.data);
    };
    StreamingRpcClient.prototype.onRequestUnsubscribe = function (message) {
        var id = message.id;
        var call = this.calls.get(id);
        if (!call)
            return;
        call.req$.complete();
    };
    StreamingRpcClient.prototype.call$ = function (method, data) {
        var _this = this;
        var id = this.id++;
        if (this.id >= 0xffff)
            this.id = 1;
        if (this.calls.has(id))
            return this.call$(method, data);
        var req$ = new rxjs_1.Subject();
        var res$ = new rxjs_1.Subject();
        var finalizedStreams = 0;
        var cleanup = function () {
            finalizedStreams++;
            if (finalizedStreams === 2)
                _this.calls.delete(id);
        };
        res$.subscribe({ error: cleanup, complete: cleanup });
        var entry = { req$: req$, res$: res$ };
        this.calls.set(id, entry);
        if ((0, rxjs_1.isObservable)(data)) {
            var firstMessageSent_1 = false;
            (0, subscribeCompleteObserver_1.subscribeCompleteObserver)(req$, {
                next: function (value) {
                    var messageMethod = firstMessageSent_1 ? '' : method;
                    firstMessageSent_1 = true;
                    var message = new msg.RequestDataMessage(id, messageMethod, new Value_1.Value(value, undefined));
                    _this.buffer.push(message);
                },
                error: function (error) {
                    cleanup();
                    var messageMethod = firstMessageSent_1 ? '' : method;
                    var message = new msg.RequestErrorMessage(id, messageMethod, new Value_1.Value(error, undefined));
                    _this.buffer.push(message);
                },
                complete: function (value) {
                    cleanup();
                    var messageMethod = firstMessageSent_1 ? '' : method;
                    var message = new msg.RequestCompleteMessage(id, messageMethod, new Value_1.Value(value, undefined));
                    _this.buffer.push(message);
                },
            });
            data.subscribe(req$);
        }
        else {
            this.buffer.push(new msg.RequestCompleteMessage(id, method, new Value_1.Value(data, undefined)));
            req$.complete();
            cleanup();
        }
        return new rxjs_1.Observable(function (observer) {
            res$.subscribe(observer);
            return function () {
                if (!entry.resFinalized)
                    _this.buffer.push(new msg.ResponseUnsubscribeMessage(id));
                res$.complete();
            };
        });
    };
    StreamingRpcClient.prototype.call = function (method, request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, (0, rxjs_1.firstValueFrom)(this.call$(method, request))];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    };
    StreamingRpcClient.prototype.notify = function (method, data) {
        var value = new Value_1.Value(data, undefined);
        this.buffer.push(new msg.NotificationMessage(method, value));
    };
    StreamingRpcClient.prototype.stop = function (reason) {
        var e_1, _a;
        if (reason === void 0) { reason = 'STOP'; }
        this.buffer.onFlush = function (message) { };
        try {
            for (var _b = tslib_1.__values(this.calls.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var call = _c.value;
                call.req$.error(new Error(reason));
                call.req$.error(new Error(reason));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.calls.clear();
    };
    StreamingRpcClient.prototype.disconnect = function () {
        this.stop('DISCONNECT');
    };
    return StreamingRpcClient;
}());
exports.StreamingRpcClient = StreamingRpcClient;
