"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionContext = void 0;
var tslib_1 = require("tslib");
var NullObject_1 = require("../../util/NullObject");
var copy_1 = require("../../util/buffers/copy");
var concat_1 = require("../../util/buffers/concat");
var X_AUTH_PARAM = 'X-Authorization=';
var X_AUTH_PARAM_LENGTH = X_AUTH_PARAM.length;
var CODECS_REGEX = /rpc.(\w{0,32})\.(\w{0,32})\.(\w{0,32})(?:\-(\w{0,32}))?/;
var ConnectionContext = (function () {
    function ConnectionContext(ip, token, params, meta, reqCodec, resCodec, msgCodec, res) {
        if (res === void 0) { res = undefined; }
        this.ip = ip;
        this.token = token;
        this.params = params;
        this.meta = meta;
        this.reqCodec = reqCodec;
        this.resCodec = resCodec;
        this.msgCodec = msgCodec;
        this.res = res;
    }
    ConnectionContext.fromReqRes = function (req, res, params, app) {
        var ip = req.getHeader('x-forwarded-for') ||
            req.getHeader('x-real-ip') ||
            Buffer.from(res.getRemoteAddressAsText()).toString();
        var token = req.getHeader('authorization') || '';
        if (!token) {
            var query = req.getQuery();
            var params_1 = new URLSearchParams(query);
            token = params_1.get('access_token') || '';
            if (!token)
                token = params_1.get('token') || '';
        }
        var secWebSocketProtocol = '';
        if (!token) {
            secWebSocketProtocol = String(req.getHeader('sec-websocket-protocol')) || '';
            if (secWebSocketProtocol) {
                var protocols = secWebSocketProtocol.split(',');
                var length_1 = protocols.length;
                for (var i = 0; i < length_1; i++) {
                    var protocol = protocols[i].trim();
                    if (protocol.startsWith(X_AUTH_PARAM)) {
                        protocol = protocol.slice(X_AUTH_PARAM_LENGTH);
                        if (protocol) {
                            token = Buffer.from(protocol, 'base64').toString();
                            break;
                        }
                    }
                }
            }
        }
        var codecs = app.codecs;
        var valueCodecs = codecs.value;
        var ctx = new ConnectionContext(ip, token, params, new NullObject_1.NullObject(), valueCodecs.json, valueCodecs.json, codecs.messages.compact, res);
        var contentType = req.getHeader('content-type');
        if (contentType)
            ctx.setCodecs(contentType, codecs);
        else if (secWebSocketProtocol)
            ctx.setCodecs(secWebSocketProtocol, codecs);
        return ctx;
    };
    ConnectionContext.prototype.setCodecs = function (specifier, codecs) {
        var match = CODECS_REGEX.exec(specifier);
        if (!match)
            return;
        var _a = tslib_1.__read(match, 5), protocol = _a[1], messageFormat = _a[2], request = _a[3], response = _a[4];
        switch (protocol) {
            case 'rx': {
                switch (messageFormat) {
                    case 'compact': {
                        this.msgCodec = codecs.messages.compact;
                        break;
                    }
                    case 'binary': {
                        this.msgCodec = codecs.messages.binary;
                        break;
                    }
                }
                break;
            }
            case 'json2': {
                this.msgCodec = codecs.messages.jsonRpc2;
                break;
            }
        }
        switch (request) {
            case 'cbor': {
                this.resCodec = this.reqCodec = codecs.value.cbor;
                break;
            }
            case 'json': {
                this.resCodec = this.reqCodec = codecs.value.json;
                break;
            }
            case 'msgpack': {
                this.resCodec = this.reqCodec = codecs.value.msgpack;
                break;
            }
        }
        switch (response) {
            case 'cbor': {
                this.resCodec = codecs.value.cbor;
                break;
            }
            case 'json': {
                this.resCodec = codecs.value.json;
                break;
            }
            case 'msgpack': {
                this.resCodec = codecs.value.msgpack;
                break;
            }
        }
    };
    ConnectionContext.prototype.requestBodyParts = function (max) {
        var res = this.res;
        return new Promise(function (resolve) {
            var list = [];
            if (!res)
                return resolve(list);
            var running = 0;
            res.onData(function (ab, isLast) {
                running += ab.byteLength;
                if (running > max)
                    res.end('too large');
                if (isLast)
                    list.push(new Uint8Array(ab)), resolve(list);
                else
                    list.push((0, copy_1.copy)(new Uint8Array(ab)));
            });
        });
    };
    ConnectionContext.prototype.requestBody = function (max) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var parts;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.requestBodyParts(max)];
                    case 1:
                        parts = _a.sent();
                        return [2, (0, concat_1.listToUint8)(parts)];
                }
            });
        });
    };
    ConnectionContext.prototype.requestBodyJson = function (max) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var parts, bodyUint8;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.requestBodyParts(max)];
                    case 1:
                        parts = _a.sent();
                        bodyUint8 = (0, concat_1.listToUint8)(parts);
                        return [2, this.reqCodec.decoder.read(bodyUint8)];
                }
            });
        });
    };
    ConnectionContext.prototype.sendResponse = function (response) {
        var res = this.res;
        if (!res)
            return;
        if (res.aborted)
            return;
        res.end(response);
    };
    return ConnectionContext;
}());
exports.ConnectionContext = ConnectionContext;
