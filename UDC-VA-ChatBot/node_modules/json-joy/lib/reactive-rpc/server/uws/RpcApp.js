"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcApp = void 0;
var tslib_1 = require("tslib");
var util_1 = require("./util");
var router_1 = require("../../../util/router");
var RpcMessageBatchProcessor_1 = require("../../common/rpc/RpcMessageBatchProcessor");
var error_1 = require("../../common/rpc/caller/error");
var context_1 = require("../context");
var RpcMessageCodecs_1 = require("../../common/codec/RpcMessageCodecs");
var Value_1 = require("../../common/messages/Value");
var RpcCodecs_1 = require("../../common/codec/RpcCodecs");
var common_1 = require("../../common");
var HDR_BAD_REQUEST = Buffer.from('400 Bad Request', 'utf8');
var HDR_NOT_FOUND = Buffer.from('404 Not Found', 'utf8');
var HDR_INTERNAL_SERVER_ERROR = Buffer.from('500 Internal Server Error', 'utf8');
var ERR_NOT_FOUND = error_1.RpcError.fromCode(error_1.RpcErrorCodes.NOT_FOUND, 'Not Found');
var ERR_INTERNAL = error_1.RpcError.internal();
var RpcApp = (function () {
    function RpcApp(options) {
        this.options = options;
        this.router = new router_1.Router();
        this.app = options.uws;
        this.maxRequestBodySize = options.maxRequestBodySize;
        this.codecs = new RpcCodecs_1.RpcCodecs(options.codecs, new RpcMessageCodecs_1.RpcMessageCodecs());
        this.batchProcessor = new RpcMessageBatchProcessor_1.RpcMessageBatchProcessor({ caller: options.caller });
    }
    RpcApp.prototype.enableCors = function () {
        (0, util_1.enableCors)(this.options.uws);
    };
    RpcApp.prototype.routeRaw = function (method, path, handler) {
        method = method.toLowerCase();
        this.router.add(method + path, handler);
    };
    RpcApp.prototype.route = function (method, path, handler) {
        var _this = this;
        this.routeRaw(method, path, function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var result, res, codec, encoder, writer;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, handler(ctx)];
                    case 1:
                        result = _a.sent();
                        res = ctx.res;
                        if (res.aborted)
                            return [2];
                        codec = ctx.resCodec;
                        encoder = codec.encoder;
                        writer = encoder.writer;
                        writer.reset();
                        if (res instanceof Value_1.Value) {
                            if (res.type)
                                res.type.encoder(codec.format)(res.data, encoder);
                            else
                                encoder.writeAny(res.data);
                        }
                        else {
                            encoder.writeAny(result);
                        }
                        if (res.aborted)
                            return [2];
                        ctx.sendResponse(writer.flush());
                        return [2];
                }
            });
        }); });
    };
    RpcApp.prototype.enableHttpPing = function (path) {
        var _this = this;
        if (path === void 0) { path = '/ping'; }
        this.route('GET', path, function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2, 'pong'];
            });
        }); });
        return this;
    };
    RpcApp.prototype.enableHttpRpc = function (path) {
        var _this = this;
        if (path === void 0) { path = '/rpc'; }
        this.routeRaw('POST', path, function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var res, bodyUint8, messageCodec, incomingMessages, outgoingMessages, resCodec, buf, err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        res = ctx.res;
                        return [4, ctx.requestBody(this.maxRequestBodySize)];
                    case 1:
                        bodyUint8 = _a.sent();
                        if (res.aborted)
                            return [2];
                        messageCodec = ctx.msgCodec;
                        incomingMessages = messageCodec.decodeBatch(ctx.reqCodec, bodyUint8);
                        return [4, this.batchProcessor.onBatch(incomingMessages, ctx)];
                    case 2:
                        outgoingMessages = _a.sent();
                        if (res.aborted)
                            return [2];
                        resCodec = ctx.resCodec;
                        messageCodec.encodeBatch(resCodec, outgoingMessages);
                        buf = resCodec.encoder.writer.flush();
                        if (res.aborted)
                            return [2];
                        res.end(buf);
                        return [3, 4];
                    case 3:
                        err_1 = _a.sent();
                        if (typeof err_1 === 'object' && err_1)
                            if (err_1.message === 'Invalid JSON')
                                throw error_1.RpcError.invalidRequest();
                        throw error_1.RpcError.from(err_1);
                    case 4: return [2];
                }
            });
        }); });
        return this;
    };
    RpcApp.prototype.enableWsRpc = function (path) {
        var _this = this;
        if (path === void 0) { path = '/rpc'; }
        var maxBackpressure = 4 * 1024 * 1024;
        this.app.ws(path, {
            idleTimeout: 0,
            maxPayloadLength: 4 * 1024 * 1024,
            upgrade: function (res, req, context) {
                var secWebSocketKey = req.getHeader('sec-websocket-key');
                var secWebSocketProtocol = req.getHeader('sec-websocket-protocol');
                var secWebSocketExtensions = req.getHeader('sec-websocket-extensions');
                var ctx = context_1.ConnectionContext.fromReqRes(req, res, null, _this);
                res.upgrade({ ctx: ctx }, secWebSocketKey, secWebSocketProtocol, secWebSocketExtensions, context);
            },
            open: function (ws_) {
                var ws = ws_;
                var ctx = ws.ctx;
                var resCodec = ctx.resCodec;
                var msgCodec = ctx.msgCodec;
                var encoder = resCodec.encoder;
                var isBinary = resCodec.format !== 2 || msgCodec.format === 0;
                ws.rpc = new common_1.RpcMessageStreamProcessor({
                    caller: _this.options.caller,
                    send: function (messages) {
                        if (ws.getBufferedAmount() > maxBackpressure)
                            return;
                        var writer = encoder.writer;
                        writer.reset();
                        msgCodec.encodeBatch(resCodec, messages);
                        var encoded = writer.flush();
                        ws.send(encoded, isBinary, false);
                    },
                    bufferSize: 1,
                    bufferTime: 0,
                });
            },
            message: function (ws_, buf, isBinary) {
                var ws = ws_;
                var ctx = ws.ctx;
                var reqCodec = ctx.reqCodec;
                var msgCodec = ctx.msgCodec;
                var uint8 = new Uint8Array(buf);
                var rpc = ws.rpc;
                try {
                    var messages = msgCodec.decodeBatch(reqCodec, uint8);
                    rpc.onMessages(messages, ctx);
                }
                catch (error) {
                    rpc.sendNotification('.err', error_1.RpcError.value(error_1.RpcError.invalidRequest()));
                }
            },
            close: function (ws_, code, message) {
                var ws = ws_;
                ws.rpc.stop();
            },
        });
        return this;
    };
    RpcApp.prototype.startRouting = function () {
        var _this = this;
        var matcher = this.router.compile();
        var codecs = this.codecs;
        var responseCodec = codecs.value.json;
        this.app.any('/*', function (res, req) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var method, url, match, handler, params, ctx, err_2, error_2, error_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        res.onAborted(function () {
                            res.aborted = true;
                        });
                        method = req.getMethod();
                        url = req.getUrl();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        match = matcher(method + url);
                        if (!match) {
                            res.cork(function () {
                                res.writeStatus(HDR_NOT_FOUND);
                                res.end(error_1.RpcErrorType.encode(responseCodec, ERR_NOT_FOUND));
                            });
                            return [2];
                        }
                        handler = match.data;
                        params = match.params;
                        ctx = context_1.ConnectionContext.fromReqRes(req, res, params, this);
                        responseCodec = ctx.resCodec;
                        return [4, handler(ctx)];
                    case 2:
                        _a.sent();
                        return [3, 4];
                    case 3:
                        err_2 = _a.sent();
                        if (err_2 instanceof error_1.RpcError) {
                            error_2 = err_2;
                            res.cork(function () {
                                res.writeStatus(HDR_BAD_REQUEST);
                                res.end(error_1.RpcErrorType.encode(responseCodec, error_2));
                            });
                            return [2];
                        }
                        if (err_2 instanceof Value_1.Value && err_2.data instanceof error_1.RpcError) {
                            error_3 = err_2.data;
                            res.cork(function () {
                                res.writeStatus(HDR_BAD_REQUEST);
                                res.end(error_1.RpcErrorType.encode(responseCodec, error_3));
                            });
                            return [2];
                        }
                        console.error(err_2);
                        res.cork(function () {
                            res.writeStatus(HDR_INTERNAL_SERVER_ERROR);
                            res.end(error_1.RpcErrorType.encode(responseCodec, ERR_INTERNAL));
                        });
                        return [3, 4];
                    case 4: return [2];
                }
            });
        }); });
    };
    return RpcApp;
}());
exports.RpcApp = RpcApp;
