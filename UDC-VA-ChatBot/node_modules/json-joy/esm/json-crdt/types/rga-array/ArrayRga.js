import { AbstractRga } from '../rga/AbstractRga';
import { tick } from '../../../json-crdt-patch/clock';
import { printBinary } from '../../../util/print/printBinary';
import { printTree } from '../../../util/print/printTree';
const Empty = [];
export class ArrayChunk {
    id;
    span;
    del;
    data;
    len;
    p;
    l;
    r;
    p2;
    l2;
    r2;
    s;
    constructor(id, span, data) {
        this.id = id;
        this.span = span;
        this.len = data ? span : 0;
        this.del = !data;
        this.p = undefined;
        this.l = undefined;
        this.r = undefined;
        this.s = undefined;
        this.data = data;
    }
    merge(data) {
        this.data.push(...data);
        this.span = this.data.length;
    }
    split(ticks) {
        const span = this.span;
        this.span = ticks;
        if (!this.del) {
            const data = this.data;
            const rightData = data.splice(ticks);
            const chunk = new ArrayChunk(tick(this.id, ticks), span - ticks, rightData);
            return chunk;
        }
        return new ArrayChunk(tick(this.id, ticks), span - ticks, undefined);
    }
    delete() {
        this.del = true;
        this.data = undefined;
    }
    clone() {
        return new ArrayChunk(this.id, this.span, this.data ? [...this.data] : undefined);
    }
}
export class ArrayRga extends AbstractRga {
    doc;
    constructor(doc, id) {
        super(id);
        this.doc = doc;
    }
    create() {
        return new ArrayRga(this.doc, this.id);
    }
    createChunk(id, data) {
        return new ArrayChunk(id, data ? data.length : 0, data);
    }
    onViewChange() {
        this._view = Empty;
    }
    _view = Empty;
    view() {
        const arr = [];
        let chunk = this.first();
        const index = this.doc.index;
        while (chunk) {
            if (!chunk.del)
                for (const node of chunk.data)
                    arr.push(index.get(node).view());
            chunk = this.next(chunk);
        }
        const _view = this._view;
        if (arr.length !== _view.length)
            return (this._view = arr);
        for (let i = 0; i < arr.length; i++)
            if (arr[i] !== _view[i])
                return (this._view = arr);
        return _view;
    }
    children(callback) {
        const index = this.doc.index;
        for (let chunk = this.first(); chunk; chunk = this.next(chunk))
            if (!chunk.del)
                for (const node of chunk.data)
                    callback(index.get(node));
    }
    get(position) {
        const pair = this.findChunk(position);
        if (!pair)
            return undefined;
        return pair[0].data[pair[1]];
    }
    getNode(position) {
        const id = this.get(position);
        if (!id)
            return undefined;
        return this.doc.index.get(id);
    }
    getById(id) {
        const chunk = this.findById(id);
        if (!chunk || chunk.del)
            return undefined;
        const offset = id.time - chunk.id.time;
        return chunk.data[offset];
    }
    child() {
        return undefined;
    }
    container() {
        return this;
    }
    printChunk(tab, chunk) {
        const pos = this.pos(chunk);
        let valueTree = '';
        if (!chunk.del) {
            const index = this.doc.index;
            valueTree = printTree(tab, chunk.data.map((id, i) => (tab) => `[${pos + i}]: ${index.get(id).toString(tab + '    ' + ' '.repeat(String(i).length))}`));
        }
        return (this.formatChunk(chunk) +
            valueTree +
            printBinary(tab, [
                chunk.l ? (tab) => this.printChunk(tab, chunk.l) : null,
                chunk.r ? (tab) => this.printChunk(tab, chunk.r) : null,
            ]));
    }
}
