import { ArrayRga } from '../types/rga-array/ArrayRga';
import { ArrInsOp } from '../../json-crdt-patch/operations/ArrInsOp';
import { ArrOp } from '../../json-crdt-patch/operations/ArrOp';
import { BinaryRga } from '../types/rga-binary/BinaryRga';
import { BinInsOp } from '../../json-crdt-patch/operations/BinInsOp';
import { BinOp } from '../../json-crdt-patch/operations/BinOp';
import { Const } from '../types/const/Const';
import { ConstOp } from '../../json-crdt-patch/operations/ConstOp';
import { DelOp } from '../../json-crdt-patch/operations/DelOp';
import { Timestamp, VectorClock, ServerVectorClock } from '../../json-crdt-patch/clock';
import { NodeIndex } from './NodeIndex';
import { ObjectLww } from '../types/lww-object/ObjectLww';
import { ObjOp } from '../../json-crdt-patch/operations/ObjOp';
import { ObjSetOp } from '../../json-crdt-patch/operations/ObjSetOp';
import { ORIGIN } from '../../json-crdt-patch/constants';
import { randomSessionId } from './util';
import { RootLww } from '../types/lww-root/RootLww';
import { StringRga } from '../types/rga-string/StringRga';
import { StrInsOp } from '../../json-crdt-patch/operations/StrInsOp';
import { StrOp } from '../../json-crdt-patch/operations/StrOp';
import { ValOp } from '../../json-crdt-patch/operations/ValOp';
import { ValSetOp } from '../../json-crdt-patch/operations/ValSetOp';
import { ValueLww } from '../types/lww-value/ValueLww';
import { printTree } from '../../util/print/printTree';
import { encode, decode } from '../../json-pack/msgpack/util';
import { Encoder } from '../codec/structural/json/Encoder';
import { Decoder } from '../codec/structural/json/Decoder';
const encoder = new Encoder();
const decoder = new Decoder();
export const UNDEFINED = new Const(ORIGIN, undefined);
export class Model {
    static withLogicalClock(clockOrSessionId) {
        const clock = typeof clockOrSessionId === 'number'
            ? new VectorClock(clockOrSessionId, 1)
            : clockOrSessionId || new VectorClock(randomSessionId(), 1);
        return new Model(clock);
    }
    static withServerClock(time = 0) {
        const clock = new ServerVectorClock(1, time);
        return new Model(clock);
    }
    static fromBinary(data) {
        return decoder.decode(decode(data));
    }
    root = new RootLww(this, ORIGIN);
    clock;
    index = new NodeIndex();
    constructor(clock) {
        this.clock = clock;
        if (!clock.time)
            clock.time = 1;
    }
    applyBatch(batch) {
        const patches = batch.patches;
        const { length } = patches;
        for (let i = 0; i < length; i++)
            this.applyPatch(patches[i]);
    }
    applyPatch(patch) {
        const ops = patch.ops;
        const { length } = ops;
        for (let i = 0; i < length; i++)
            this.applyOperation(ops[i]);
    }
    applyOperation(op) {
        this.clock.observe(op.id, op.span());
        const index = this.index;
        if (op instanceof StrInsOp) {
            const node = index.get(op.obj);
            if (node instanceof StringRga)
                node.ins(op.ref, op.id, op.data);
        }
        else if (op instanceof ObjOp) {
            if (!index.get(op.id))
                index.set(new ObjectLww(this, op.id));
        }
        else if (op instanceof ArrOp) {
            if (!index.get(op.id))
                index.set(new ArrayRga(this, op.id));
        }
        else if (op instanceof StrOp) {
            if (!index.get(op.id))
                index.set(new StringRga(op.id));
        }
        else if (op instanceof ValOp) {
            if (!index.get(op.id)) {
                const val = index.get(op.val);
                if (val)
                    index.set(new ValueLww(this, op.id, op.val));
            }
        }
        else if (op instanceof ConstOp) {
            if (!index.get(op.id))
                index.set(new Const(op.id, op.val));
        }
        else if (op instanceof ObjSetOp) {
            const node = index.get(op.obj);
            const tuples = op.data;
            const length = tuples.length;
            if (node instanceof ObjectLww) {
                for (let i = 0; i < length; i++) {
                    const tuple = tuples[i];
                    const valueNode = index.get(tuple[1]);
                    if (!valueNode)
                        continue;
                    if (node.id.time >= tuple[1].time)
                        continue;
                    const old = node.put(tuple[0] + '', valueNode.id);
                    if (old)
                        this.deleteNodeTree(old);
                }
            }
        }
        else if (op instanceof ValSetOp) {
            const obj = op.obj;
            const node = obj.sid === 0 && obj.time === 0 ? this.root : index.get(obj);
            if (node instanceof ValueLww) {
                const newValue = index.get(op.val);
                if (newValue) {
                    const old = node.set(op.val);
                    if (old)
                        this.deleteNodeTree(old);
                }
            }
        }
        else if (op instanceof ArrInsOp) {
            const node = index.get(op.obj);
            if (node instanceof ArrayRga) {
                const nodes = [];
                const data = op.data;
                const length = data.length;
                for (let i = 0; i < length; i++) {
                    const stamp = data[i];
                    const valueNode = index.get(stamp);
                    if (!valueNode)
                        continue;
                    if (node.id.time >= stamp.time)
                        continue;
                    nodes.push(stamp);
                }
                if (nodes.length)
                    node.ins(op.ref, op.id, nodes);
            }
        }
        else if (op instanceof DelOp) {
            const node = index.get(op.obj);
            if (node instanceof ArrayRga) {
                const length = op.what.length;
                for (let i = 0; i < length; i++) {
                    const span = op.what[i];
                    for (let j = 0; j < span.span; j++) {
                        const id = node.getById(new Timestamp(span.sid, span.time + j));
                        if (id)
                            this.deleteNodeTree(id);
                    }
                }
                node.delete(op.what);
            }
            else if (node instanceof StringRga)
                node.delete(op.what);
            else if (node instanceof BinaryRga)
                node.delete(op.what);
        }
        else if (op instanceof BinOp) {
            if (!index.get(op.id))
                index.set(new BinaryRga(op.id));
        }
        else if (op instanceof BinInsOp) {
            const node = index.get(op.obj);
            if (node instanceof BinaryRga)
                node.ins(op.ref, op.id, op.data);
        }
    }
    deleteNodeTree(value) {
        const isSystemNode = value.sid === 0;
        if (isSystemNode)
            return;
        const node = this.index.get(value);
        if (!node)
            return;
        node.children((child) => this.deleteNodeTree(child.id));
        this.index.delete(value);
    }
    fork(sessionId = randomSessionId()) {
        const copy = Model.fromBinary(this.toBinary());
        if (copy.clock.sid !== sessionId && copy.clock instanceof VectorClock)
            copy.clock = copy.clock.fork(sessionId);
        return copy;
    }
    clone() {
        return this.fork(this.clock.sid);
    }
    view() {
        return this.root.view();
    }
    toString(tab = '') {
        const nl = () => '';
        return (this.constructor.name +
            printTree(tab, [
                (tab) => this.root.toString(tab),
                nl,
                (tab) => this.index.toString(tab),
                nl,
                (tab) => this.clock.toString(tab),
            ]));
    }
    toBinary() {
        return encode(encoder.encode(this));
    }
}
