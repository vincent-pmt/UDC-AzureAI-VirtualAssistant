import { ArrayRga, ArrayChunk } from '../../../types/rga-array/ArrayRga';
import { BinaryRga, BinaryChunk } from '../../../types/rga-binary/BinaryRga';
import { Const } from '../../../types/const/Const';
import { RootLww } from '../../../types/lww-root/RootLww';
import { fromBase64 } from '../../../../util/base64/fromBase64';
import { ts, VectorClock } from '../../../../json-crdt-patch/clock';
import { Model } from '../../../model';
import { ObjectLww } from '../../../types/lww-object/ObjectLww';
import { StringRga, StringChunk } from '../../../types/rga-string/StringRga';
import { ValueLww } from '../../../types/lww-value/ValueLww';
export class Decoder {
    decode({ time, root }) {
        const isServerClock = typeof time === 'number';
        const doc = isServerClock ? Model.withServerClock(time) : Model.withLogicalClock(this.cClock(time));
        this.cRoot(doc, root);
        return doc;
    }
    cClock(timestamps) {
        const [stamp] = timestamps;
        const vectorClock = new VectorClock(stamp[0], stamp[1]);
        const length = timestamps.length;
        for (let i = 1; i < length; i++) {
            const stamp = timestamps[i];
            const [sessionId, time] = stamp;
            vectorClock.observe(ts(sessionId, time), 1);
        }
        return vectorClock;
    }
    cTs(stamp) {
        const isServerClock = typeof stamp === 'number';
        return isServerClock ? ts(1, stamp) : ts(stamp[0], stamp[1]);
    }
    cRoot(doc, { node }) {
        const val = node ? this.cNode(doc, node) : new Const(doc.clock.tick(0), null);
        const root = new RootLww(doc, val.id);
        doc.root = root;
    }
    cNode(doc, node) {
        switch (node.type) {
            case 'obj':
                return this.cObj(doc, node);
            case 'arr':
                return this.cArr(doc, node);
            case 'str':
                return this.cStr(doc, node);
            case 'val':
                return this.cVal(doc, node);
            case 'const':
                return this.cConst(doc, node);
            case 'bin':
                return this.cBin(doc, node);
        }
        throw new Error('UNKNOWN_NODE');
    }
    cObj(doc, node) {
        const id = this.cTs(node.id);
        const obj = new ObjectLww(doc, id);
        const keys = Object.keys(node.keys);
        for (const key of keys) {
            const keyNode = node.keys[key];
            obj.put(key, this.cNode(doc, keyNode).id);
        }
        doc.index.set(obj);
        return obj;
    }
    cArr(doc, node) {
        const rga = new ArrayRga(doc, this.cTs(node.id));
        const chunks = node.chunks;
        const length = chunks.length;
        if (length) {
            const self = this;
            let i = 0;
            rga.ingest(length, () => {
                const c = chunks[i++];
                const id = self.cTs(c.id);
                if (typeof c.span === 'number')
                    return new ArrayChunk(id, c.span, undefined);
                else {
                    const ids = c.nodes.map((n) => this.cNode(doc, n).id);
                    return new ArrayChunk(id, ids.length, ids);
                }
            });
        }
        doc.index.set(rga);
        return rga;
    }
    cStr(doc, node) {
        const rga = new StringRga(this.cTs(node.id));
        const chunks = node.chunks;
        const length = chunks.length;
        if (length) {
            const self = this;
            let i = 0;
            rga.ingest(length, () => {
                const c = chunks[i++];
                const id = self.cTs(c.id);
                if (typeof c.span === 'number')
                    return new StringChunk(id, c.span, '');
                else {
                    const value = c.value;
                    return new StringChunk(id, value.length, value);
                }
            });
        }
        doc.index.set(rga);
        return rga;
    }
    cBin(doc, node) {
        const rga = new BinaryRga(this.cTs(node.id));
        const chunks = node.chunks;
        const length = chunks.length;
        const self = this;
        if (length) {
            let i = 0;
            rga.ingest(length, () => {
                const c = chunks[i++];
                const id = self.cTs(c.id);
                if (typeof c.span === 'number')
                    return new BinaryChunk(id, c.span, undefined);
                else {
                    const value = c.value;
                    const buf = fromBase64(value);
                    return new BinaryChunk(id, buf.length, buf);
                }
            });
        }
        doc.index.set(rga);
        return rga;
    }
    cVal(doc, node) {
        const id = this.cTs(node.id);
        const val = this.cNode(doc, node.node);
        const obj = new ValueLww(doc, id, val.id);
        doc.index.set(obj);
        return obj;
    }
    cConst(doc, node) {
        const id = this.cTs(node.id);
        const val = node.timestamp ? this.cTs(node.value) : node.value;
        const obj = new Const(id, val);
        doc.index.set(obj);
        return obj;
    }
}
