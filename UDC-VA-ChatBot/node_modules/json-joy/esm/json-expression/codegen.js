import { Codegen } from '../util/codegen/Codegen';
import { deepEqual } from '../json-equal/deepEqual';
import { $$deepEqual } from '../json-equal/$$deepEqual';
import { $$find } from '../json-pointer/codegen/find';
import { toPath, validateJsonPointer } from '../json-pointer';
import { get, throwOnUndef, str, type, starts, contains, ends, isInContainer, substr, num, slash, isLiteral, betweenNeNe, betweenEqNe, betweenNeEq, betweenEqEq, } from './util';
const isExpression = (expr) => expr instanceof Array && typeof expr[0] === 'string';
const toBoxed = (value) => (value instanceof Array ? [value] : value);
const linkable = {
    get,
    throwOnUndef,
    deepEqual,
    type,
    str,
    starts,
    contains,
    ends,
    isInContainer,
    substr,
    slash,
    betweenNeNe,
    betweenEqNe,
    betweenNeEq,
    betweenEqEq,
};
class Literal {
    val;
    constructor(val) {
        this.val = val;
    }
    toString() {
        return JSON.stringify(this.val);
    }
}
class Expression {
    val;
    constructor(val) {
        this.val = val;
    }
    toString() {
        return this.val;
    }
}
export class JsonExpressionCodegen {
    options;
    codegen;
    constructor(options) {
        this.options = options;
        this.codegen = new Codegen({
            args: ['ctx'],
            prologue: 'var data = ctx.data;',
            epilogue: '',
            linkable,
        });
    }
    onGet(expr) {
        if (expr.length < 2 || expr.length > 3)
            throw new Error('"get" operator expects two or three operands.');
        const path = this.onExpression(expr[1]);
        const def = expr[2] === undefined ? undefined : this.onExpression(expr[2]);
        if (def !== undefined && !isLiteral(expr[2]))
            throw new Error('"get" operator expects a default value to be a literal.');
        this.codegen.link('throwOnUndef');
        if (path instanceof Literal) {
            if (typeof path.val !== 'string')
                throw new Error('Invalid JSON pointer.');
            validateJsonPointer(path.val);
            const fn = $$find(toPath(path.val));
            const d = this.codegen.addConstant(fn);
            return new Expression(`throwOnUndef(${d}(data), ${def})`);
        }
        else {
            this.codegen.link('get');
            return new Expression(`throwOnUndef(get(${path}, data), ${def})`);
        }
    }
    onEqualsLiteralLiteral(a, b) {
        return new Literal(deepEqual(a.val, b.val));
    }
    onEqualsLiteralExpression(literal, expression) {
        const fn = $$deepEqual(literal.val);
        const d = this.codegen.addConstant(fn);
        return new Expression(`${d}(${expression})`);
    }
    onEquals(expr) {
        if (expr.length !== 3)
            throw new Error('"==" operator expects two operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return this.onEqualsLiteralLiteral(a, b);
        if (a instanceof Literal && b instanceof Expression)
            return this.onEqualsLiteralExpression(a, b);
        if (b instanceof Literal && a instanceof Expression)
            return this.onEqualsLiteralExpression(b, a);
        this.codegen.link('deepEqual');
        return new Expression(`deepEqual(${a}, ${b})`);
    }
    onNotEquals(expr) {
        if (expr.length !== 3)
            throw new Error('"!=" operator expects two operands.');
        const [, a, b] = expr;
        const res = this.onEquals(['eq', a, b]);
        if (res instanceof Literal)
            return new Literal(!res.val);
        return new Expression(`!(${res})`);
    }
    onNot(expr) {
        if (expr.length > 2)
            throw new Error('"not" operator expects one operand.');
        const [, a] = expr;
        const res = this.onExpression(a);
        if (res instanceof Literal)
            return new Literal(!res.val);
        return new Expression(`!(${res})`);
    }
    onIf(expr) {
        if (expr.length !== 4)
            throw new Error('"if" operator expects three operands.');
        const [, a, b, c] = expr;
        const condition = this.onExpression(a);
        if (condition instanceof Literal)
            return condition.val ? this.onExpression(b) : this.onExpression(c);
        return new Expression(`${condition} ? ${this.onExpression(b)} : ${this.onExpression(c)}`);
    }
    onAnd(expr) {
        if (expr.length <= 2)
            throw new Error('"and" operator expects at least two operands.');
        const [, ...operands] = expr;
        const expressions = [];
        let allLiteral = true;
        for (let i = 0; i < operands.length; i++) {
            const expression = this.onExpression(operands[i]);
            if (!(expression instanceof Literal))
                allLiteral = false;
            expressions.push(expression);
        }
        if (allLiteral) {
            for (let i = 0; i < expressions.length; i++) {
                const expression = expressions[i];
                if (!expression.val)
                    return new Literal(false);
            }
            return new Literal(true);
        }
        return new Expression(expressions.map((expr) => `!!(${expr})`).join(' && '));
    }
    onOr(expr) {
        if (expr.length <= 2)
            throw new Error('"or" operator expects at least two operands.');
        const [, ...operands] = expr;
        const expressions = [];
        let allLiteral = true;
        for (let i = 0; i < operands.length; i++) {
            const expression = this.onExpression(operands[i]);
            if (!(expression instanceof Literal))
                allLiteral = false;
            expressions.push(expression);
        }
        if (allLiteral) {
            for (let i = 0; i < expressions.length; i++) {
                const expression = expressions[i];
                if (expression.val)
                    return new Literal(true);
            }
            return new Literal(false);
        }
        return new Expression(expressions.map((expr) => `!!(${expr})`).join(' || '));
    }
    onType(expr) {
        if (expr.length !== 2)
            throw new Error('"type" operator expects one operand.');
        const [, operand] = expr;
        const expression = this.onExpression(operand);
        if (expression instanceof Literal)
            return new Literal(type(expression.val));
        this.codegen.link('type');
        return new Expression(`type(${expression})`);
    }
    onBool(expr) {
        if (expr.length !== 2)
            throw new Error('"bool" operator expects one operand.');
        const [, operand] = expr;
        const expression = this.onExpression(operand);
        if (expression instanceof Literal)
            return new Literal(!!expression.val);
        return new Expression(`!!(${expression})`);
    }
    onNum(expr) {
        if (expr.length !== 2)
            throw new Error('"num" operator expects one operand.');
        const [, operand] = expr;
        const expression = this.onExpression(operand);
        if (expression instanceof Literal)
            return new Literal(+expression.val || 0);
        return new Expression(`+(${expression}) || 0`);
    }
    onInt(expr) {
        if (expr.length !== 2)
            throw new Error('"int" operator expects one operand.');
        const [, operand] = expr;
        const expression = this.onExpression(operand);
        if (expression instanceof Literal)
            return new Literal(~~expression.val);
        return new Expression(`+(${expression})`);
    }
    onStr(expr) {
        if (expr.length !== 2)
            throw new Error('"str" operator expects one operand.');
        const [, operand] = expr;
        const expression = this.onExpression(operand);
        if (expression instanceof Literal)
            return new Literal(str(expression.val));
        this.codegen.link('str');
        return new Expression(`str(${expression})`);
    }
    onStarts(expr) {
        if (expr.length !== 3)
            throw new Error('"starts" operator expects two operands.');
        const [, a, b] = expr;
        const outer = this.onExpression(a);
        const inner = this.onExpression(b);
        if (outer instanceof Literal && inner instanceof Literal)
            return new Literal(starts(outer.val, inner.val));
        this.codegen.link('starts');
        return new Expression(`starts(${outer}, ${inner})`);
    }
    onContains(expr) {
        if (expr.length !== 3)
            throw new Error('"contains" operator expects two operands.');
        const [, a, b] = expr;
        const outer = this.onExpression(a);
        const inner = this.onExpression(b);
        if (outer instanceof Literal && inner instanceof Literal)
            return new Literal(contains(outer.val, inner.val));
        this.codegen.link('contains');
        return new Expression(`contains(${outer}, ${inner})`);
    }
    onEnds(expr) {
        if (expr.length !== 3)
            throw new Error('"ends" operator expects two operands.');
        const [, a, b] = expr;
        const outer = this.onExpression(a);
        const inner = this.onExpression(b);
        if (outer instanceof Literal && inner instanceof Literal)
            return new Literal(ends(outer.val, inner.val));
        this.codegen.link('ends');
        return new Expression(`ends(${outer}, ${inner})`);
    }
    onMatches(expr) {
        if (expr.length !== 3)
            throw new Error('"matches" operator expects two operands.');
        const [, a, pattern] = expr;
        if (typeof pattern !== 'string')
            throw new Error('"matches" second argument should be a regular expression string.');
        const subject = this.onExpression(a);
        if (!this.options.createPattern)
            throw new Error('"matches" operator requires ".createPattern()" option to be implemented.');
        const fn = this.options.createPattern(pattern);
        if (subject instanceof Literal)
            return new Literal(fn(str(subject.val)));
        const d = this.codegen.linkDependency(fn);
        this.codegen.link('str');
        return new Expression(`${d}(str(${subject}))`);
    }
    onDefined(expr) {
        if (expr.length > 2)
            throw new Error('"defined" operator expects one operand.');
        const [, pointer] = expr;
        if (typeof pointer !== 'string')
            throw new Error('Invalid JSON pointer.');
        validateJsonPointer(pointer);
        const fn = $$find(toPath(pointer));
        const d = this.codegen.addConstant(fn);
        return new Expression(`${d}(data) !== undefined`);
    }
    onIn(expr) {
        if (expr.length > 3)
            throw new Error('"in" operator expects two operands.');
        const [, a, b] = expr;
        const container = this.onExpression(b);
        const what = this.onExpression(a);
        if (container instanceof Literal) {
            if (!(container.val instanceof Array))
                throw new Error('"in" operator expects second operand to be an array.');
            if (what instanceof Literal)
                return new Literal(isInContainer(what.val, container.val));
            if (container.val.length === 0)
                return new Literal(false);
            if (container.val.length === 1)
                return this.onExpression(['==', a, toBoxed(container.val[0])]);
        }
        this.codegen.link('isInContainer');
        return new Expression(`isInContainer(${what}, ${container})`);
    }
    onCat(expr) {
        if (expr.length <= 2)
            throw new Error('"cat" operator expects at least two operands.');
        const [, ...operands] = expr;
        const expressions = operands.map((operand) => this.onExpression(operand));
        let areAllLiteral = true;
        for (let i = 0; i < expressions.length; i++) {
            const expression = expressions[i];
            if (!(expression instanceof Literal)) {
                areAllLiteral = false;
                break;
            }
        }
        if (areAllLiteral)
            return new Literal(expressions.map((expr) => str(expr.val)).join(''));
        this.codegen.link('str');
        const params = expressions.map((expr) => `str(${expr})`);
        return new Expression(params.join(' + '));
    }
    onSubstr(expr) {
        if (expr.length < 3 || expr.length > 4)
            throw new Error('"substr" operator expects two or three operands.');
        const str = this.onExpression(expr[1]);
        const from = this.onExpression(expr[2]);
        const length = expr[3] ? this.onExpression(expr[3]) : new Literal(0);
        if (str instanceof Literal && from instanceof Literal && length instanceof Literal)
            return new Literal(substr(str.val, from.val, length.val));
        this.codegen.link('substr');
        return new Expression(`substr(${str}, ${from}, ${length})`);
    }
    onLessThan(expr) {
        if (expr.length !== 3)
            throw new Error('"<" operator expects two operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal(num(a.val) < num(b.val));
        return new Expression(`(+(${a})||0) < (+(${b})||0)`);
    }
    onLessThanOrEqual(expr) {
        if (expr.length !== 3)
            throw new Error('"<=" operator expects two operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal(num(a.val) <= num(b.val));
        return new Expression(`(+(${a})||0) <= (+(${b})||0)`);
    }
    onGreaterThan(expr) {
        if (expr.length !== 3)
            throw new Error('">" operator expects two operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal(num(a.val) > num(b.val));
        return new Expression(`(+(${a})||0) > (+(${b})||0)`);
    }
    onGreaterThanOrEqual(expr) {
        if (expr.length !== 3)
            throw new Error('">=" operator expects two operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal(num(a.val) >= num(b.val));
        return new Expression(`(+(${a})||0) >= (+(${b})||0)`);
    }
    onBetweenNeNe(expr) {
        if (expr.length !== 4)
            throw new Error('"><" operator expects three operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        const c = this.onExpression(expr[3]);
        if (a instanceof Literal && b instanceof Literal && c instanceof Literal)
            return new Literal(betweenNeNe(num(a.val), num(b.val), num(c.val)));
        this.codegen.link('betweenNeNe');
        return new Expression(`betweenNeNe((+(${a})||0), (+(${b})||0), (+(${c})||0))`);
    }
    onBetweenEqNe(expr) {
        if (expr.length !== 4)
            throw new Error('"=><" operator expects three operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        const c = this.onExpression(expr[3]);
        if (a instanceof Literal && b instanceof Literal && c instanceof Literal)
            return new Literal(betweenEqNe(num(a.val), num(b.val), num(c.val)));
        this.codegen.link('betweenEqNe');
        return new Expression(`betweenEqNe((+(${a})||0), (+(${b})||0), (+(${c})||0))`);
    }
    onBetweenNeEq(expr) {
        if (expr.length !== 4)
            throw new Error('"><=" operator expects three operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        const c = this.onExpression(expr[3]);
        if (a instanceof Literal && b instanceof Literal && c instanceof Literal)
            return new Literal(betweenNeEq(num(a.val), num(b.val), num(c.val)));
        this.codegen.link('betweenNeEq');
        return new Expression(`betweenNeEq((+(${a})||0), (+(${b})||0), (+(${c})||0))`);
    }
    onBetweenEqEq(expr) {
        if (expr.length !== 4)
            throw new Error('"=><=" operator expects three operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        const c = this.onExpression(expr[3]);
        if (a instanceof Literal && b instanceof Literal && c instanceof Literal)
            return new Literal(betweenEqEq(num(a.val), num(b.val), num(c.val)));
        this.codegen.link('betweenEqEq');
        return new Expression(`betweenEqEq((+(${a})||0), (+(${b})||0), (+(${c})||0))`);
    }
    onMin(expr) {
        if (expr.length < 3)
            throw new Error('"min" operator expects at least two operands.');
        const expressions = expr.slice(1).map((operand) => this.onExpression(operand));
        const allLiterals = expressions.every((expr) => expr instanceof Literal);
        if (allLiterals)
            return new Literal(num(Math.min(...expressions.map((expr) => expr.val))));
        const params = expressions.map((expr) => `${expr}`);
        return new Expression(`+Math.min(${params.join(', ')}) || 0`);
    }
    onMax(expr) {
        if (expr.length < 3)
            throw new Error('"max" operator expects at least two operands.');
        const expressions = expr.slice(1).map((operand) => this.onExpression(operand));
        const allLiterals = expressions.every((expr) => expr instanceof Literal);
        if (allLiterals)
            return new Literal(num(Math.max(...expressions.map((expr) => expr.val))));
        const params = expressions.map((expr) => `${expr}`);
        return new Expression(`+Math.max(${params.join(', ')}) || 0`);
    }
    onPlus(expr) {
        if (expr.length < 3)
            throw new Error('"+" operator expects at least two operands.');
        const expressions = expr.slice(1).map((operand) => this.onExpression(operand));
        const allLiterals = expressions.every((expr) => expr instanceof Literal);
        if (allLiterals)
            return new Literal(expressions.reduce((a, b) => a + num(b.val), 0));
        const params = expressions.map((expr) => `(+(${expr})||0)`);
        return new Expression(`${params.join(' + ')}`);
    }
    onMinus(expr) {
        if (expr.length < 3)
            throw new Error('"-" operator expects at least two operands.');
        const expressions = expr.slice(1).map((operand) => this.onExpression(operand));
        const allLiterals = expressions.every((expr) => expr instanceof Literal);
        if (allLiterals)
            return new Literal(expressions.slice(1).reduce((a, b) => a - num(b.val), num(expressions[0].val)));
        const params = expressions.map((expr) => `(+(${expr})||0)`);
        return new Expression(`${params.join(' - ')}`);
    }
    onAsterisk(expr) {
        if (expr.length < 3)
            throw new Error('"*" operator expects at least two operands.');
        const expressions = expr.slice(1).map((operand) => this.onExpression(operand));
        const allLiterals = expressions.every((expr) => expr instanceof Literal);
        if (allLiterals)
            return new Literal(expressions.reduce((a, b) => a * num(b.val), 1));
        const params = expressions.map((expr) => `(+(${expr})||0)`);
        return new Expression(`${params.join(' * ')}`);
    }
    onSlash(expr) {
        if (expr.length !== 3)
            throw new Error('"/" operator expects two operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal(slash(a.val, b.val));
        this.codegen.link('slash');
        return new Expression(`slash(${a}, ${b})`);
    }
    onMod(expr) {
        if (expr.length !== 3)
            throw new Error('"%" operator expects two operands.');
        const a = this.onExpression(expr[1]);
        const b = this.onExpression(expr[2]);
        if (a instanceof Literal && b instanceof Literal)
            return new Literal(num(a.val % b.val));
        return new Expression(`+(${a} % ${b}) || 0`);
    }
    onRound(expr) {
        if (expr.length !== 2)
            throw new Error('"round" operator expects one operand.');
        const a = this.onExpression(expr[1]);
        if (a instanceof Literal)
            return new Literal(Math.round(num(a.val)));
        return new Expression(`Math.round(+(${a}) || 0)`);
    }
    onCeil(expr) {
        if (expr.length !== 2)
            throw new Error('"ceil" operator expects one operand.');
        const a = this.onExpression(expr[1]);
        if (a instanceof Literal)
            return new Literal(Math.ceil(num(a.val)));
        return new Expression(`Math.ceil(+(${a}) || 0)`);
    }
    onFloor(expr) {
        if (expr.length !== 2)
            throw new Error('"floor" operator expects one operand.');
        const a = this.onExpression(expr[1]);
        if (a instanceof Literal)
            return new Literal(Math.floor(num(a.val)));
        return new Expression(`Math.floor(+(${a}) || 0)`);
    }
    onExpression(expr) {
        if (!isExpression(expr)) {
            if (expr instanceof Array) {
                if (expr.length !== 1 || !(expr[0] instanceof Array))
                    throw new Error('Expected array literal to be boxed as single array element.');
                return new Literal(expr[0]);
            }
            else
                return new Literal(expr);
        }
        switch (expr[0]) {
            case '=':
            case 'get':
                return this.onGet(expr);
            case '==':
            case 'eq':
                return this.onEquals(expr);
            case '!=':
            case 'ne':
                return this.onNotEquals(expr);
            case '?':
            case 'if':
                return this.onIf(expr);
            case '&&':
            case 'and':
                return this.onAnd(expr);
            case '||':
            case 'or':
                return this.onOr(expr);
            case '!':
            case 'not':
                return this.onNot(expr);
            case 'type':
                return this.onType(expr);
            case 'bool':
                return this.onBool(expr);
            case 'num':
                return this.onNum(expr);
            case 'int':
                return this.onInt(expr);
            case 'str':
                return this.onStr(expr);
            case 'starts':
                return this.onStarts(expr);
            case 'contains':
                return this.onContains(expr);
            case 'ends':
                return this.onEnds(expr);
            case 'matches':
                return this.onMatches(expr);
            case 'defined':
                return this.onDefined(expr);
            case 'in':
                return this.onIn(expr);
            case '.':
            case 'cat':
                return this.onCat(expr);
            case 'substr':
                return this.onSubstr(expr);
            case '<':
                return this.onLessThan(expr);
            case '<=':
                return this.onLessThanOrEqual(expr);
            case '>':
                return this.onGreaterThan(expr);
            case '>=':
                return this.onGreaterThanOrEqual(expr);
            case '><':
                return this.onBetweenNeNe(expr);
            case '=><':
                return this.onBetweenEqNe(expr);
            case '><=':
                return this.onBetweenNeEq(expr);
            case '=><=':
                return this.onBetweenEqEq(expr);
            case 'min':
                return this.onMin(expr);
            case 'max':
                return this.onMax(expr);
            case '+':
                return this.onPlus(expr);
            case '-':
                return this.onMinus(expr);
            case '*':
                return this.onAsterisk(expr);
            case '/':
                return this.onSlash(expr);
            case '%':
            case 'mod':
                return this.onMod(expr);
            case 'round':
                return this.onRound(expr);
            case 'ceil':
                return this.onCeil(expr);
            case 'floor':
                return this.onFloor(expr);
        }
        return new Literal(false);
    }
    run() {
        const expr = this.onExpression(this.options.expression);
        this.codegen.js(`return ${expr};`);
        return this;
    }
    generate() {
        return this.codegen.generate();
    }
    compile() {
        return this.codegen.compile();
    }
}
