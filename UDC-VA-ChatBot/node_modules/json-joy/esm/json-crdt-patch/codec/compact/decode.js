import { fromBase64 } from '../../../util/base64/fromBase64';
import { interval, VectorClock, ServerVectorClock, ts } from '../../clock';
import { PatchBuilder } from '../../PatchBuilder';
export const decode = (data) => {
    const x = data[0];
    const clock = Array.isArray(x) ? new VectorClock(x[0], x[1]) : new ServerVectorClock(1, x);
    const sessionId = clock.sid;
    const time = clock.time;
    const builder = new PatchBuilder(clock);
    const length = data.length;
    let i = 1;
    const decodeTimestamp = () => {
        const x = data[i++];
        if (Array.isArray(x))
            return ts(x[0], x[1]);
        else if (x < 0)
            return ts(sessionId, time - x - 1);
        else
            return ts(1, x);
    };
    const decodeTimespan = () => {
        const time = decodeTimestamp();
        const span = data[i++];
        return interval(time, 0, span);
    };
    while (i < length) {
        switch (data[i++]) {
            case 3: {
                builder.obj();
                break;
            }
            case 5: {
                builder.arr();
                break;
            }
            case 4: {
                builder.str();
                break;
            }
            case 6: {
                builder.bin();
                break;
            }
            case 11: {
                const length = data[i++];
                const obj = decodeTimestamp();
                const tuples = [];
                for (let j = 0; j < length; j++) {
                    const key = data[i++];
                    tuples.push([key, decodeTimestamp()]);
                }
                builder.setKeys(obj, tuples);
                break;
            }
            case 9: {
                const value = data[i++];
                builder.insStr(decodeTimestamp(), decodeTimestamp(), value);
                break;
            }
            case 17: {
                const value = data[i++];
                builder.insBin(decodeTimestamp(), decodeTimestamp(), fromBase64(value));
                break;
            }
            case 13: {
                const length = data[i++];
                const arr = decodeTimestamp();
                const after = decodeTimestamp();
                const values = [];
                for (let j = 0; j < length; j++)
                    values.push(decodeTimestamp());
                builder.insArr(arr, after, values);
                break;
            }
            case 14: {
                const obj = decodeTimestamp();
                const what = decodeTimespan();
                builder.del(obj, [what]);
                break;
            }
            case 10: {
                const length = data[i++];
                const obj = decodeTimestamp();
                const what = [];
                for (let i = 0; i < length; i++)
                    what.push(decodeTimespan());
                builder.del(obj, what);
                break;
            }
            case 15: {
                builder.noop(1);
                break;
            }
            case 16: {
                builder.noop(data[i++]);
                break;
            }
            case 1: {
                builder.const(data[i++]);
                break;
            }
            case 0: {
                builder.const(undefined);
                break;
            }
            case 8: {
                builder.const(decodeTimestamp());
                break;
            }
            case 2: {
                builder.val(decodeTimestamp());
                break;
            }
            case 12: {
                const obj = decodeTimestamp();
                const value = decodeTimestamp();
                builder.setVal(obj, value);
                break;
            }
            case 7: {
                builder.tup();
                break;
            }
        }
    }
    return builder.patch;
};
