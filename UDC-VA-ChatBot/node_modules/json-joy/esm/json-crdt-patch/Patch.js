import { ArrInsOp } from './operations/ArrInsOp';
import { ArrOp } from './operations/ArrOp';
import { BinInsOp } from './operations/BinInsOp';
import { BinOp } from './operations/BinOp';
import { ConstOp } from './operations/ConstOp';
import { DelOp } from './operations/DelOp';
import { ts, toDisplayString } from './clock';
import { NoopOp } from './operations/NoopOp';
import { ObjOp } from './operations/ObjOp';
import { ObjSetOp } from './operations/ObjSetOp';
import { StrInsOp } from './operations/StrInsOp';
import { StrOp } from './operations/StrOp';
import { ValOp } from './operations/ValOp';
import { ValSetOp } from './operations/ValSetOp';
import { encode } from './codec/binary/encode';
import { decode } from './codec/binary/decode';
import { TupOp } from './operations/TupOp';
export class Patch {
    static fromBinary(data) {
        return decode(data);
    }
    ops = [];
    getId() {
        const op = this.ops[0];
        if (!op)
            return undefined;
        return op.id;
    }
    span() {
        let span = 0;
        for (const op of this.ops)
            span += op.span();
        return span;
    }
    nextTime() {
        const ops = this.ops;
        const length = ops.length;
        if (!length)
            return 0;
        const lastOp = ops[length - 1];
        return lastOp.id.time + lastOp.span();
    }
    rewriteTime(ts) {
        const patch = new Patch();
        const ops = this.ops;
        const length = ops.length;
        for (let i = 0; i < length; i++) {
            const op = ops[i];
            if (op instanceof DelOp)
                patch.ops.push(new DelOp(ts(op.id), ts(op.obj), op.what));
            else if (op instanceof ArrInsOp)
                patch.ops.push(new ArrInsOp(ts(op.id), ts(op.obj), ts(op.ref), op.data.map(ts)));
            else if (op instanceof StrInsOp)
                patch.ops.push(new StrInsOp(ts(op.id), ts(op.obj), ts(op.ref), op.data));
            else if (op instanceof BinInsOp)
                patch.ops.push(new BinInsOp(ts(op.id), ts(op.obj), ts(op.ref), op.data));
            else if (op instanceof ArrOp)
                patch.ops.push(new ArrOp(ts(op.id)));
            else if (op instanceof TupOp)
                patch.ops.push(new TupOp(ts(op.id)));
            else if (op instanceof ConstOp)
                patch.ops.push(new ConstOp(ts(op.id), op.val));
            else if (op instanceof ValOp)
                patch.ops.push(new ValOp(ts(op.id), ts(op.val)));
            else if (op instanceof ObjOp)
                patch.ops.push(new ObjOp(ts(op.id)));
            else if (op instanceof StrOp)
                patch.ops.push(new StrOp(ts(op.id)));
            else if (op instanceof BinOp)
                patch.ops.push(new BinOp(ts(op.id)));
            else if (op instanceof ValSetOp)
                patch.ops.push(new ValSetOp(ts(op.id), ts(op.obj), ts(op.val)));
            else if (op instanceof ObjSetOp)
                patch.ops.push(new ObjSetOp(ts(op.id), ts(op.obj), op.data.map(([key, value]) => [key, ts(value)])));
            else if (op instanceof NoopOp)
                patch.ops.push(new NoopOp(ts(op.id), op.len));
        }
        return patch;
    }
    rebase(serverTime, transformHorizon) {
        const id = this.getId();
        if (!id)
            throw new Error('EMPTY_PATCH');
        const patchStartTime = id.time;
        if (patchStartTime === serverTime)
            return this;
        const delta = serverTime - patchStartTime;
        return this.rewriteTime((id) => {
            const sessionId = id.sid;
            const isServerTimestamp = sessionId === 1;
            if (!isServerTimestamp)
                return id;
            const time = id.time;
            if (time < transformHorizon)
                return id;
            return ts(1, time + delta);
        });
    }
    clone() {
        return this.rewriteTime((id) => id);
    }
    toString(tab = '') {
        const id = this.getId();
        let out = `${this.constructor.name} ${id ? toDisplayString(id) : '(nil)'}!${this.span()}`;
        for (let i = 0; i < this.ops.length; i++) {
            const isLast = i === this.ops.length - 1;
            out += `\n${tab}${isLast ? '└─' : '├─'} ${this.ops[i].toString(tab + (isLast ? '  ' : '│ '))}`;
        }
        return out;
    }
    toBinary() {
        return encode(this);
    }
}
