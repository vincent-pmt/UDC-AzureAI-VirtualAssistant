import { ArrInsOp } from './operations/ArrInsOp';
import { ArrOp } from './operations/ArrOp';
import { BinInsOp } from './operations/BinInsOp';
import { BinOp } from './operations/BinOp';
import { ConstOp } from './operations/ConstOp';
import { DelOp } from './operations/DelOp';
import { ts, Timestamp } from './clock';
import { isUint8Array } from '../util/buffers/isUint8Array';
import { NoopOp } from './operations/NoopOp';
import { ObjOp } from './operations/ObjOp';
import { ObjSetOp } from './operations/ObjSetOp';
import { Patch } from './Patch';
import { StrInsOp } from './operations/StrInsOp';
import { StrOp } from './operations/StrOp';
import { ValOp } from './operations/ValOp';
import { ValSetOp } from './operations/ValSetOp';
import { TupOp } from './operations/TupOp';
import { ORIGIN } from './constants';
import { Tuple } from './builder/Tuple';
import { Konst } from './builder/Konst';
import { DelayedValueBuilder } from './builder/DelayedValueBuilder';
const maybeConst = (x) => {
    switch (typeof x) {
        case 'number':
        case 'boolean':
            return true;
        default:
            return x === null;
    }
};
export class PatchBuilder {
    clock;
    patch;
    constructor(clock) {
        this.clock = clock;
        this.patch = new Patch();
    }
    nextTime() {
        return this.patch.nextTime() || this.clock.time;
    }
    flush() {
        const patch = this.patch;
        this.patch = new Patch();
        return patch;
    }
    obj() {
        this.pad();
        const id = this.clock.tick(1);
        this.patch.ops.push(new ObjOp(id));
        return id;
    }
    arr() {
        this.pad();
        const id = this.clock.tick(1);
        this.patch.ops.push(new ArrOp(id));
        return id;
    }
    tup() {
        this.pad();
        const id = this.clock.tick(1);
        this.patch.ops.push(new TupOp(id));
        return id;
    }
    str() {
        this.pad();
        const id = this.clock.tick(1);
        this.patch.ops.push(new StrOp(id));
        return id;
    }
    bin() {
        this.pad();
        const id = this.clock.tick(1);
        this.patch.ops.push(new BinOp(id));
        return id;
    }
    const(value) {
        this.pad();
        const id = this.clock.tick(1);
        this.patch.ops.push(new ConstOp(id, value));
        return id;
    }
    val(val) {
        this.pad();
        const id = this.clock.tick(1);
        this.patch.ops.push(new ValOp(id, val));
        return id;
    }
    root(val) {
        this.pad();
        const id = this.clock.tick(1);
        this.patch.ops.push(new ValSetOp(id, ORIGIN, val));
        return id;
    }
    setKeys(obj, data) {
        this.pad();
        if (!data.length)
            throw new Error('EMPTY_TUPLES');
        const id = this.clock.tick(0);
        const op = new ObjSetOp(id, obj, data);
        const span = op.span();
        if (span > 1)
            this.clock.tick(span - 1);
        this.patch.ops.push(op);
        return id;
    }
    setVal(obj, val) {
        this.pad();
        const id = this.clock.tick(0);
        const op = new ValSetOp(id, obj, val);
        this.patch.ops.push(op);
        return id;
    }
    insStr(obj, ref, data) {
        this.pad();
        if (!data.length)
            throw new Error('EMPTY_STRING');
        const id = this.clock.tick(1);
        const op = new StrInsOp(id, obj, ref, data);
        const span = op.span();
        if (span > 1)
            this.clock.tick(span - 1);
        this.patch.ops.push(op);
        return id;
    }
    insBin(obj, ref, data) {
        this.pad();
        if (!data.length)
            throw new Error('EMPTY_BINARY');
        const id = this.clock.tick(1);
        const op = new BinInsOp(id, obj, ref, data);
        const span = op.span();
        if (span > 1)
            this.clock.tick(span - 1);
        this.patch.ops.push(op);
        return id;
    }
    insArr(arr, ref, data) {
        this.pad();
        const id = this.clock.tick(1);
        const op = new ArrInsOp(id, arr, ref, data);
        const span = op.span();
        if (span > 1)
            this.clock.tick(span - 1);
        this.patch.ops.push(op);
        return id;
    }
    del(obj, what) {
        this.pad();
        const id = this.clock.tick(0);
        this.patch.ops.push(new DelOp(id, obj, what));
        return id;
    }
    noop(span) {
        this.pad();
        const id = this.clock.tick(span);
        this.patch.ops.push(new NoopOp(id, span));
        return id;
    }
    jsonObj(json) {
        const obj = this.obj();
        const keys = Object.keys(json);
        if (keys.length) {
            const tuples = [];
            for (const k of keys) {
                const value = json[k];
                const valueId = value instanceof Timestamp ? value : maybeConst(value) ? this.const(value) : this.json(value);
                tuples.push([k, valueId]);
            }
            this.setKeys(obj, tuples);
        }
        return obj;
    }
    jsonArr(json) {
        const arr = this.arr();
        if (json.length) {
            const values = [];
            for (const el of json)
                values.push(this.json(el));
            this.insArr(arr, arr, values);
        }
        return arr;
    }
    jsonStr(json) {
        const str = this.str();
        if (json)
            this.insStr(str, str, json);
        return str;
    }
    jsonBin(json) {
        const bin = this.bin();
        if (json.length)
            this.insBin(bin, bin, json);
        return bin;
    }
    jsonVal(json) {
        const val = this.const(json);
        return this.val(val);
    }
    jsonTup(slots) {
        const tup = this.tup();
        const length = slots.length;
        if (length) {
            const writes = [];
            for (let i = 0; i < length; i++)
                writes.push([i, this.constOrJson(slots[i])]);
            this.setKeys(tup, writes);
        }
        return tup;
    }
    json(json) {
        if (json instanceof Timestamp)
            return json;
        if (json === undefined)
            return this.const(json);
        if (json instanceof Array)
            return this.jsonArr(json);
        if (isUint8Array(json))
            return this.jsonBin(json);
        if (json instanceof Tuple)
            return this.jsonTup(json.slots);
        if (json instanceof Konst)
            return this.const(json.val);
        if (json instanceof DelayedValueBuilder)
            return json.build(this);
        switch (typeof json) {
            case 'object':
                return json === null ? this.jsonVal(json) : this.jsonObj(json);
            case 'string':
                return this.jsonStr(json);
            case 'number':
            case 'boolean':
                return this.jsonVal(json);
        }
        throw new Error('INVALID_JSON');
    }
    constOrJson(value) {
        if (value instanceof Timestamp)
            return value;
        return maybeConst(value) ? this.const(value) : this.json(value);
    }
    maybeConst(value) {
        return value instanceof Timestamp ? value : this.const(value);
    }
    pad() {
        const nextTime = this.patch.nextTime();
        if (!nextTime)
            return;
        const drift = this.clock.time - nextTime;
        if (drift > 0) {
            const id = ts(this.clock.sid, nextTime);
            const padding = new NoopOp(id, drift);
            this.patch.ops.push(padding);
        }
    }
}
