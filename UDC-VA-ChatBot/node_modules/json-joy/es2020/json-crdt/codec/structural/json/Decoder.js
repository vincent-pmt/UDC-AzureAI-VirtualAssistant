"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decoder = void 0;
const ArrayRga_1 = require("../../../types/rga-array/ArrayRga");
const BinaryRga_1 = require("../../../types/rga-binary/BinaryRga");
const Const_1 = require("../../../types/const/Const");
const RootLww_1 = require("../../../types/lww-root/RootLww");
const fromBase64_1 = require("../../../../util/base64/fromBase64");
const clock_1 = require("../../../../json-crdt-patch/clock");
const model_1 = require("../../../model");
const ObjectLww_1 = require("../../../types/lww-object/ObjectLww");
const StringRga_1 = require("../../../types/rga-string/StringRga");
const ValueLww_1 = require("../../../types/lww-value/ValueLww");
class Decoder {
    decode({ time, root }) {
        const isServerClock = typeof time === 'number';
        const doc = isServerClock ? model_1.Model.withServerClock(time) : model_1.Model.withLogicalClock(this.cClock(time));
        this.cRoot(doc, root);
        return doc;
    }
    cClock(timestamps) {
        const [stamp] = timestamps;
        const vectorClock = new clock_1.VectorClock(stamp[0], stamp[1]);
        const length = timestamps.length;
        for (let i = 1; i < length; i++) {
            const stamp = timestamps[i];
            const [sessionId, time] = stamp;
            vectorClock.observe((0, clock_1.ts)(sessionId, time), 1);
        }
        return vectorClock;
    }
    cTs(stamp) {
        const isServerClock = typeof stamp === 'number';
        return isServerClock ? (0, clock_1.ts)(1, stamp) : (0, clock_1.ts)(stamp[0], stamp[1]);
    }
    cRoot(doc, { node }) {
        const val = node ? this.cNode(doc, node) : new Const_1.Const(doc.clock.tick(0), null);
        const root = new RootLww_1.RootLww(doc, val.id);
        doc.root = root;
    }
    cNode(doc, node) {
        switch (node.type) {
            case 'obj':
                return this.cObj(doc, node);
            case 'arr':
                return this.cArr(doc, node);
            case 'str':
                return this.cStr(doc, node);
            case 'val':
                return this.cVal(doc, node);
            case 'const':
                return this.cConst(doc, node);
            case 'bin':
                return this.cBin(doc, node);
        }
        throw new Error('UNKNOWN_NODE');
    }
    cObj(doc, node) {
        const id = this.cTs(node.id);
        const obj = new ObjectLww_1.ObjectLww(doc, id);
        const keys = Object.keys(node.keys);
        for (const key of keys) {
            const keyNode = node.keys[key];
            obj.put(key, this.cNode(doc, keyNode).id);
        }
        doc.index.set(obj);
        return obj;
    }
    cArr(doc, node) {
        const rga = new ArrayRga_1.ArrayRga(doc, this.cTs(node.id));
        const chunks = node.chunks;
        const length = chunks.length;
        if (length) {
            const self = this;
            let i = 0;
            rga.ingest(length, () => {
                const c = chunks[i++];
                const id = self.cTs(c.id);
                if (typeof c.span === 'number')
                    return new ArrayRga_1.ArrayChunk(id, c.span, undefined);
                else {
                    const ids = c.nodes.map((n) => this.cNode(doc, n).id);
                    return new ArrayRga_1.ArrayChunk(id, ids.length, ids);
                }
            });
        }
        doc.index.set(rga);
        return rga;
    }
    cStr(doc, node) {
        const rga = new StringRga_1.StringRga(this.cTs(node.id));
        const chunks = node.chunks;
        const length = chunks.length;
        if (length) {
            const self = this;
            let i = 0;
            rga.ingest(length, () => {
                const c = chunks[i++];
                const id = self.cTs(c.id);
                if (typeof c.span === 'number')
                    return new StringRga_1.StringChunk(id, c.span, '');
                else {
                    const value = c.value;
                    return new StringRga_1.StringChunk(id, value.length, value);
                }
            });
        }
        doc.index.set(rga);
        return rga;
    }
    cBin(doc, node) {
        const rga = new BinaryRga_1.BinaryRga(this.cTs(node.id));
        const chunks = node.chunks;
        const length = chunks.length;
        const self = this;
        if (length) {
            let i = 0;
            rga.ingest(length, () => {
                const c = chunks[i++];
                const id = self.cTs(c.id);
                if (typeof c.span === 'number')
                    return new BinaryRga_1.BinaryChunk(id, c.span, undefined);
                else {
                    const value = c.value;
                    const buf = (0, fromBase64_1.fromBase64)(value);
                    return new BinaryRga_1.BinaryChunk(id, buf.length, buf);
                }
            });
        }
        doc.index.set(rga);
        return rga;
    }
    cVal(doc, node) {
        const id = this.cTs(node.id);
        const val = this.cNode(doc, node.node);
        const obj = new ValueLww_1.ValueLww(doc, id, val.id);
        doc.index.set(obj);
        return obj;
    }
    cConst(doc, node) {
        const id = this.cTs(node.id);
        const val = node.timestamp ? this.cTs(node.value) : node.value;
        const obj = new Const_1.Const(id, val);
        doc.index.set(obj);
        return obj;
    }
}
exports.Decoder = Decoder;
