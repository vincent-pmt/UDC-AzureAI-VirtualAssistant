"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Encoder = void 0;
const ArrayRga_1 = require("../../../types/rga-array/ArrayRga");
const BinaryRga_1 = require("../../../types/rga-binary/BinaryRga");
const Const_1 = require("../../../types/const/Const");
const ObjectLww_1 = require("../../../types/lww-object/ObjectLww");
const StringRga_1 = require("../../../types/rga-string/StringRga");
const toBase64_1 = require("../../../../util/base64/toBase64");
const ValueLww_1 = require("../../../types/lww-value/ValueLww");
const clock_1 = require("../../../../json-crdt-patch/clock");
class Encoder {
    encode(model) {
        this.model = model;
        const clock = model.clock;
        const isServerClock = clock.sid === 1;
        return {
            time: isServerClock ? clock.time : this.cClock(model.clock),
            root: this.cVal(model.root),
        };
    }
    cClock(clock) {
        const data = [];
        const sessionId = clock.sid;
        const localTs = clock.peers.get(sessionId);
        if (!localTs)
            data.push([sessionId, clock.time]);
        for (const c of clock.peers.values())
            data.push([c.sid, c.time]);
        return data;
    }
    cTs(ts) {
        return ts.sid === 1 ? ts.time : [ts.sid, ts.time];
    }
    cNode(node) {
        if (node instanceof ObjectLww_1.ObjectLww)
            return this.cObj(node);
        else if (node instanceof ArrayRga_1.ArrayRga)
            return this.cArr(node);
        else if (node instanceof StringRga_1.StringRga)
            return this.cStr(node);
        else if (node instanceof ValueLww_1.ValueLww)
            return this.cVal(node);
        else if (node instanceof Const_1.Const)
            return this.cConst(node);
        else if (node instanceof BinaryRga_1.BinaryRga)
            return this.cBin(node);
        throw new Error('UNKNOWN_NODE');
    }
    cObj(obj) {
        const keys = {};
        obj.nodes((node, key) => {
            keys[key] = this.cNode(node);
        });
        return {
            type: 'obj',
            id: this.cTs(obj.id),
            keys,
        };
    }
    cArr(obj) {
        const chunks = [];
        const iterator = obj.iterator();
        let chunk;
        while ((chunk = iterator()))
            chunks.push(this.cArrChunk(chunk));
        return {
            type: 'arr',
            id: this.cTs(obj.id),
            chunks,
        };
    }
    cArrChunk(chunk) {
        if (chunk.del) {
            const tombstone = {
                id: this.cTs(chunk.id),
                span: chunk.span,
            };
            return tombstone;
        }
        const index = this.model.index;
        const res = {
            id: this.cTs(chunk.id),
            nodes: chunk.data.map((n) => this.cNode(index.get(n))),
        };
        return res;
    }
    cStr(obj) {
        const chunks = [];
        const iterator = obj.iterator();
        let chunk;
        while ((chunk = iterator()))
            chunks.push(this.cStrChunk(chunk));
        return {
            type: 'str',
            id: this.cTs(obj.id),
            chunks,
        };
    }
    cStrChunk(chunk) {
        if (chunk.del) {
            const tombstone = {
                id: this.cTs(chunk.id),
                span: chunk.span,
            };
            return tombstone;
        }
        const res = {
            id: this.cTs(chunk.id),
            value: chunk.data,
        };
        return res;
    }
    cBin(obj) {
        const chunks = [];
        const iterator = obj.iterator();
        let chunk;
        while ((chunk = iterator()))
            chunks.push(this.cBinChunk(chunk));
        return {
            type: 'bin',
            id: this.cTs(obj.id),
            chunks,
        };
    }
    cBinChunk(chunk) {
        if (chunk.del) {
            const tombstone = {
                id: this.cTs(chunk.id),
                span: chunk.span,
            };
            return tombstone;
        }
        const res = {
            id: this.cTs(chunk.id),
            value: (0, toBase64_1.toBase64)(chunk.data),
        };
        return res;
    }
    cVal(obj) {
        return {
            type: 'val',
            id: this.cTs(obj.id),
            node: this.cNode(obj.node()),
        };
    }
    cConst(obj) {
        const node = {
            type: 'const',
            id: this.cTs(obj.id),
        };
        const val = obj.val;
        if (val instanceof clock_1.Timestamp) {
            node.timestamp = true;
            node.value = this.cTs(val);
        }
        else {
            if (val !== undefined)
                node.value = val;
        }
        return node;
    }
}
exports.Encoder = Encoder;
