"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluate = void 0;
const deepEqual_1 = require("../json-equal/deepEqual");
const json_pointer_1 = require("../json-pointer");
const util_1 = require("./util");
const toNumber = util_1.num;
const evaluate = (expr, ctx) => {
    if (!(expr instanceof Array))
        return expr;
    if (expr.length === 1 && expr[0] instanceof Array)
        return expr[0];
    const fn = expr[0];
    switch (fn) {
        case '=':
        case 'get': {
            const pointer = (0, exports.evaluate)(expr[1], ctx);
            if (expr[2] !== undefined && !(0, util_1.isLiteral)(expr[2]))
                throw new Error('"get" operator expects a default value to be a literal.');
            const def = (0, exports.evaluate)(expr[2], ctx);
            if (typeof pointer !== 'string')
                throw new Error('Invalid JSON pointer.');
            (0, json_pointer_1.validateJsonPointer)(pointer);
            return (0, util_1.throwOnUndef)((0, json_pointer_1.get)(ctx.data, (0, json_pointer_1.toPath)(pointer)), def);
        }
        case '==':
        case 'eq': {
            const left = (0, exports.evaluate)(expr[1], ctx);
            const right = (0, exports.evaluate)(expr[2], ctx);
            return (0, deepEqual_1.deepEqual)(left, right);
        }
        case 'in': {
            const v2 = (0, exports.evaluate)(expr[2], ctx);
            if (!(v2 instanceof Array) || !v2.length)
                return false;
            const v1 = (0, exports.evaluate)(expr[1], ctx);
            return v2.some((item) => (0, deepEqual_1.deepEqual)(item, v1));
        }
        case '!=':
        case 'ne': {
            const left = (0, exports.evaluate)(expr[1], ctx);
            const right = (0, exports.evaluate)(expr[2], ctx);
            return !(0, deepEqual_1.deepEqual)(left, right);
        }
        case '?':
        case 'if': {
            return (0, exports.evaluate)(expr[1], ctx) ? (0, exports.evaluate)(expr[2], ctx) : (0, exports.evaluate)(expr[3], ctx);
        }
        case '&&':
        case 'and':
            return expr.slice(1).every((e) => (0, exports.evaluate)(e, ctx));
        case '||':
        case 'or':
            return expr.slice(1).some((e) => (0, exports.evaluate)(e, ctx));
        case '!':
        case 'not':
            return !(0, exports.evaluate)(expr[1], ctx);
        case 'type':
            return (0, util_1.type)((0, exports.evaluate)(expr[1], ctx));
        case 'defined': {
            const pointer = (0, exports.evaluate)(expr[1], ctx);
            if (typeof pointer !== 'string')
                throw new Error('Invalid JSON pointer.');
            (0, json_pointer_1.validateJsonPointer)(pointer);
            const value = (0, json_pointer_1.get)(ctx.data, (0, json_pointer_1.toPath)(pointer));
            return value !== undefined;
        }
        case 'bool':
            return !!(0, exports.evaluate)(expr[1], ctx);
        case 'num':
            return toNumber((0, exports.evaluate)(expr[1], ctx));
        case 'int':
            return ~~(0, exports.evaluate)(expr[1], ctx);
        case 'str':
            return (0, util_1.str)((0, exports.evaluate)(expr[1], ctx));
        case 'starts': {
            const subject = (0, exports.evaluate)(expr[1], ctx);
            const test = (0, exports.evaluate)(expr[2], ctx);
            return (0, util_1.starts)(subject, test);
        }
        case 'contains': {
            const subject = (0, exports.evaluate)(expr[1], ctx);
            const test = (0, exports.evaluate)(expr[2], ctx);
            return (0, util_1.contains)(subject, test);
        }
        case 'ends': {
            const subject = (0, exports.evaluate)(expr[1], ctx);
            const test = (0, exports.evaluate)(expr[2], ctx);
            return (0, util_1.ends)(subject, test);
        }
        case 'cat':
        case '.': {
            return expr
                .slice(1)
                .map((e) => (0, exports.evaluate)(e, ctx))
                .join('');
        }
        case 'substr': {
            const str2 = (0, util_1.str)((0, exports.evaluate)(expr[1], ctx));
            const from = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            const length = expr.length > 3 ? (0, util_1.num)((0, exports.evaluate)(expr[3], ctx)) : undefined;
            return str2.substr(from, length);
        }
        case 'matches': {
            const [, a, pattern] = expr;
            if (typeof pattern !== 'string')
                throw new Error('"matches" second argument should be a regular expression string.');
            if (!ctx.createPattern)
                throw new Error('"matches" operator requires ".createPattern()" option to be implemented.');
            const subject = (0, exports.evaluate)(a, ctx);
            const fn = ctx.createPattern(pattern);
            return fn((0, util_1.str)(subject));
        }
        case '<': {
            const left = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            const right = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            return left < right;
        }
        case '<=': {
            const left = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            const right = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            return left <= right;
        }
        case '>': {
            const left = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            const right = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            return left > right;
        }
        case '>=': {
            const left = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            const right = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            return left >= right;
        }
        case '><': {
            const val = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            const min = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            const max = (0, util_1.num)((0, exports.evaluate)(expr[3], ctx));
            return (0, util_1.betweenNeNe)(val, min, max);
        }
        case '=><': {
            const val = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            const min = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            const max = (0, util_1.num)((0, exports.evaluate)(expr[3], ctx));
            return (0, util_1.betweenEqNe)(val, min, max);
        }
        case '><=': {
            const val = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            const min = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            const max = (0, util_1.num)((0, exports.evaluate)(expr[3], ctx));
            return (0, util_1.betweenNeEq)(val, min, max);
        }
        case '=><=': {
            const val = (0, util_1.num)((0, exports.evaluate)(expr[1], ctx));
            const min = (0, util_1.num)((0, exports.evaluate)(expr[2], ctx));
            const max = (0, util_1.num)((0, exports.evaluate)(expr[3], ctx));
            return (0, util_1.betweenEqEq)(val, min, max);
        }
        case 'min': {
            return Math.min(...expr.slice(1).map((e) => (0, util_1.num)((0, exports.evaluate)(e, ctx))));
        }
        case 'max': {
            return Math.max(...expr.slice(1).map((e) => (0, util_1.num)((0, exports.evaluate)(e, ctx))));
        }
        case '+': {
            return expr.slice(1).reduce((acc, e) => (0, util_1.num)((0, exports.evaluate)(e, ctx)) + acc, 0);
        }
        case '-': {
            return expr.slice(2).reduce((acc, e) => acc - (0, util_1.num)((0, exports.evaluate)(e, ctx)), (0, util_1.num)((0, exports.evaluate)(expr[1], ctx)));
        }
        case '*': {
            return expr.slice(1).reduce((acc, e) => (0, util_1.num)((0, exports.evaluate)(e, ctx)) * acc, 1);
        }
        case '/': {
            return (0, util_1.slash)((0, exports.evaluate)(expr[1], ctx), (0, exports.evaluate)(expr[2], ctx));
        }
        case '%': {
            return (0, util_1.num)((0, exports.evaluate)(expr[1], ctx) % (0, exports.evaluate)(expr[2], ctx));
        }
        case 'round': {
            return Math.round((0, util_1.num)((0, exports.evaluate)(expr[1], ctx)));
        }
        case 'ceil': {
            return Math.ceil((0, util_1.num)((0, exports.evaluate)(expr[1], ctx)));
        }
        case 'floor': {
            return Math.floor((0, util_1.num)((0, exports.evaluate)(expr[1], ctx)));
        }
    }
    throw new Error('Unknown expression.');
};
exports.evaluate = evaluate;
