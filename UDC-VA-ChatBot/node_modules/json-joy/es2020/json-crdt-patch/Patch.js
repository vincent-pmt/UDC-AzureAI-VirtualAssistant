"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Patch = void 0;
const ArrInsOp_1 = require("./operations/ArrInsOp");
const ArrOp_1 = require("./operations/ArrOp");
const BinInsOp_1 = require("./operations/BinInsOp");
const BinOp_1 = require("./operations/BinOp");
const ConstOp_1 = require("./operations/ConstOp");
const DelOp_1 = require("./operations/DelOp");
const clock_1 = require("./clock");
const NoopOp_1 = require("./operations/NoopOp");
const ObjOp_1 = require("./operations/ObjOp");
const ObjSetOp_1 = require("./operations/ObjSetOp");
const StrInsOp_1 = require("./operations/StrInsOp");
const StrOp_1 = require("./operations/StrOp");
const ValOp_1 = require("./operations/ValOp");
const ValSetOp_1 = require("./operations/ValSetOp");
const encode_1 = require("./codec/binary/encode");
const decode_1 = require("./codec/binary/decode");
const TupOp_1 = require("./operations/TupOp");
class Patch {
    constructor() {
        this.ops = [];
    }
    static fromBinary(data) {
        return (0, decode_1.decode)(data);
    }
    getId() {
        const op = this.ops[0];
        if (!op)
            return undefined;
        return op.id;
    }
    span() {
        let span = 0;
        for (const op of this.ops)
            span += op.span();
        return span;
    }
    nextTime() {
        const ops = this.ops;
        const length = ops.length;
        if (!length)
            return 0;
        const lastOp = ops[length - 1];
        return lastOp.id.time + lastOp.span();
    }
    rewriteTime(ts) {
        const patch = new Patch();
        const ops = this.ops;
        const length = ops.length;
        for (let i = 0; i < length; i++) {
            const op = ops[i];
            if (op instanceof DelOp_1.DelOp)
                patch.ops.push(new DelOp_1.DelOp(ts(op.id), ts(op.obj), op.what));
            else if (op instanceof ArrInsOp_1.ArrInsOp)
                patch.ops.push(new ArrInsOp_1.ArrInsOp(ts(op.id), ts(op.obj), ts(op.ref), op.data.map(ts)));
            else if (op instanceof StrInsOp_1.StrInsOp)
                patch.ops.push(new StrInsOp_1.StrInsOp(ts(op.id), ts(op.obj), ts(op.ref), op.data));
            else if (op instanceof BinInsOp_1.BinInsOp)
                patch.ops.push(new BinInsOp_1.BinInsOp(ts(op.id), ts(op.obj), ts(op.ref), op.data));
            else if (op instanceof ArrOp_1.ArrOp)
                patch.ops.push(new ArrOp_1.ArrOp(ts(op.id)));
            else if (op instanceof TupOp_1.TupOp)
                patch.ops.push(new TupOp_1.TupOp(ts(op.id)));
            else if (op instanceof ConstOp_1.ConstOp)
                patch.ops.push(new ConstOp_1.ConstOp(ts(op.id), op.val));
            else if (op instanceof ValOp_1.ValOp)
                patch.ops.push(new ValOp_1.ValOp(ts(op.id), ts(op.val)));
            else if (op instanceof ObjOp_1.ObjOp)
                patch.ops.push(new ObjOp_1.ObjOp(ts(op.id)));
            else if (op instanceof StrOp_1.StrOp)
                patch.ops.push(new StrOp_1.StrOp(ts(op.id)));
            else if (op instanceof BinOp_1.BinOp)
                patch.ops.push(new BinOp_1.BinOp(ts(op.id)));
            else if (op instanceof ValSetOp_1.ValSetOp)
                patch.ops.push(new ValSetOp_1.ValSetOp(ts(op.id), ts(op.obj), ts(op.val)));
            else if (op instanceof ObjSetOp_1.ObjSetOp)
                patch.ops.push(new ObjSetOp_1.ObjSetOp(ts(op.id), ts(op.obj), op.data.map(([key, value]) => [key, ts(value)])));
            else if (op instanceof NoopOp_1.NoopOp)
                patch.ops.push(new NoopOp_1.NoopOp(ts(op.id), op.len));
        }
        return patch;
    }
    rebase(serverTime, transformHorizon) {
        const id = this.getId();
        if (!id)
            throw new Error('EMPTY_PATCH');
        const patchStartTime = id.time;
        if (patchStartTime === serverTime)
            return this;
        const delta = serverTime - patchStartTime;
        return this.rewriteTime((id) => {
            const sessionId = id.sid;
            const isServerTimestamp = sessionId === 1;
            if (!isServerTimestamp)
                return id;
            const time = id.time;
            if (time < transformHorizon)
                return id;
            return (0, clock_1.ts)(1, time + delta);
        });
    }
    clone() {
        return this.rewriteTime((id) => id);
    }
    toString(tab = '') {
        const id = this.getId();
        let out = `${this.constructor.name} ${id ? (0, clock_1.toDisplayString)(id) : '(nil)'}!${this.span()}`;
        for (let i = 0; i < this.ops.length; i++) {
            const isLast = i === this.ops.length - 1;
            out += `\n${tab}${isLast ? '└─' : '├─'} ${this.ops[i].toString(tab + (isLast ? '  ' : '│ '))}`;
        }
        return out;
    }
    toBinary() {
        return (0, encode_1.encode)(this);
    }
}
exports.Patch = Patch;
