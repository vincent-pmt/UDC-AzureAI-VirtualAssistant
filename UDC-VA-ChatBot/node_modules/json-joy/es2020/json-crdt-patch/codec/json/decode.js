"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = void 0;
const fromBase64_1 = require("../../../util/base64/fromBase64");
const clock_1 = require("../../clock");
const PatchBuilder_1 = require("../../PatchBuilder");
const decodeId = (time) => typeof time === 'number' ? (0, clock_1.ts)(1, time) : (0, clock_1.ts)(time[0], time[1]);
const decode = (data) => {
    const { id, ops } = data;
    const clock = typeof id === 'number' ? new clock_1.ServerVectorClock(1, id) : new clock_1.VectorClock(id[0], id[1]);
    const builder = new PatchBuilder_1.PatchBuilder(clock);
    for (const op of ops) {
        switch (op.op) {
            case 'obj': {
                builder.obj();
                break;
            }
            case 'arr': {
                builder.arr();
                break;
            }
            case 'str': {
                builder.str();
                break;
            }
            case 'bin': {
                builder.bin();
                break;
            }
            case 'val': {
                builder.val(decodeId(op.value));
                break;
            }
            case 'const': {
                if (op.timestamp) {
                    builder.const(decodeId(op.value));
                }
                else {
                    builder.const(op.value);
                }
                break;
            }
            case 'obj_set': {
                builder.setKeys(decodeId(op.obj), op.tuples.map(([key, id]) => [key, decodeId(id)]));
                break;
            }
            case 'val_set': {
                builder.setVal(decodeId(op.obj), decodeId(op.value));
                break;
            }
            case 'str_ins': {
                builder.insStr(decodeId(op.obj), decodeId(op.after || op.obj), op.value);
                break;
            }
            case 'bin_ins': {
                builder.insBin(decodeId(op.obj), decodeId(op.after || op.obj), (0, fromBase64_1.fromBase64)(op.value));
                break;
            }
            case 'arr_ins': {
                builder.insArr(decodeId(op.obj), decodeId(op.after || op.obj), op.values.map(decodeId));
                break;
            }
            case 'del': {
                builder.del(decodeId(op.obj), op.what.map((tuple) => (0, clock_1.tss)(...tuple)));
                break;
            }
            case 'noop': {
                builder.noop(op.len || 1);
                break;
            }
            case 'tup': {
                builder.tup();
                break;
            }
        }
    }
    return builder.patch;
};
exports.decode = decode;
